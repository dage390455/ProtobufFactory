// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MsgNode_1v1_m22.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_MsgNode_5f1v1_5fm22_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_MsgNode_5f1v1_5fm22_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3008000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3008000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_MsgNode_5f1v1_5fm22_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_MsgNode_5f1v1_5fm22_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[19]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_MsgNode_5f1v1_5fm22_2eproto;
class AcrelData;
class AcrelDataDefaultTypeInternal;
extern AcrelDataDefaultTypeInternal _AcrelData_default_instance_;
class AppParam;
class AppParamDefaultTypeInternal;
extern AppParamDefaultTypeInternal _AppParam_default_instance_;
class AxisData;
class AxisDataDefaultTypeInternal;
extern AxisDataDefaultTypeInternal _AxisData_default_instance_;
class Baymax;
class BaymaxDefaultTypeInternal;
extern BaymaxDefaultTypeInternal _Baymax_default_instance_;
class BleParam;
class BleParamDefaultTypeInternal;
extern BleParamDefaultTypeInternal _BleParam_default_instance_;
class Cayman;
class CaymanDefaultTypeInternal;
extern CaymanDefaultTypeInternal _Cayman_default_instance_;
class Channel;
class ChannelDefaultTypeInternal;
extern ChannelDefaultTypeInternal _Channel_default_instance_;
class ElecFireData;
class ElecFireDataDefaultTypeInternal;
extern ElecFireDataDefaultTypeInternal _ElecFireData_default_instance_;
class ExtSmoke;
class ExtSmokeDefaultTypeInternal;
extern ExtSmokeDefaultTypeInternal _ExtSmoke_default_instance_;
class GpsData;
class GpsDataDefaultTypeInternal;
extern GpsDataDefaultTypeInternal _GpsData_default_instance_;
class LpwanParam;
class LpwanParamDefaultTypeInternal;
extern LpwanParamDefaultTypeInternal _LpwanParam_default_instance_;
class MantunData;
class MantunDataDefaultTypeInternal;
extern MantunDataDefaultTypeInternal _MantunData_default_instance_;
class MsgNode;
class MsgNodeDefaultTypeInternal;
extern MsgNodeDefaultTypeInternal _MsgNode_default_instance_;
class MultiSensorData;
class MultiSensorDataDefaultTypeInternal;
extern MultiSensorDataDefaultTypeInternal _MultiSensorData_default_instance_;
class MultiSensorDataInt;
class MultiSensorDataIntDefaultTypeInternal;
extern MultiSensorDataIntDefaultTypeInternal _MultiSensorDataInt_default_instance_;
class SensorData;
class SensorDataDefaultTypeInternal;
extern SensorDataDefaultTypeInternal _SensorData_default_instance_;
class SensorDataFloat;
class SensorDataFloatDefaultTypeInternal;
extern SensorDataFloatDefaultTypeInternal _SensorDataFloat_default_instance_;
class SensorDataInt;
class SensorDataIntDefaultTypeInternal;
extern SensorDataIntDefaultTypeInternal _SensorDataInt_default_instance_;
class iBeacon;
class iBeaconDefaultTypeInternal;
extern iBeaconDefaultTypeInternal _iBeacon_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::AcrelData* Arena::CreateMaybeMessage<::AcrelData>(Arena*);
template<> ::AppParam* Arena::CreateMaybeMessage<::AppParam>(Arena*);
template<> ::AxisData* Arena::CreateMaybeMessage<::AxisData>(Arena*);
template<> ::Baymax* Arena::CreateMaybeMessage<::Baymax>(Arena*);
template<> ::BleParam* Arena::CreateMaybeMessage<::BleParam>(Arena*);
template<> ::Cayman* Arena::CreateMaybeMessage<::Cayman>(Arena*);
template<> ::Channel* Arena::CreateMaybeMessage<::Channel>(Arena*);
template<> ::ElecFireData* Arena::CreateMaybeMessage<::ElecFireData>(Arena*);
template<> ::ExtSmoke* Arena::CreateMaybeMessage<::ExtSmoke>(Arena*);
template<> ::GpsData* Arena::CreateMaybeMessage<::GpsData>(Arena*);
template<> ::LpwanParam* Arena::CreateMaybeMessage<::LpwanParam>(Arena*);
template<> ::MantunData* Arena::CreateMaybeMessage<::MantunData>(Arena*);
template<> ::MsgNode* Arena::CreateMaybeMessage<::MsgNode>(Arena*);
template<> ::MultiSensorData* Arena::CreateMaybeMessage<::MultiSensorData>(Arena*);
template<> ::MultiSensorDataInt* Arena::CreateMaybeMessage<::MultiSensorDataInt>(Arena*);
template<> ::SensorData* Arena::CreateMaybeMessage<::SensorData>(Arena*);
template<> ::SensorDataFloat* Arena::CreateMaybeMessage<::SensorDataFloat>(Arena*);
template<> ::SensorDataInt* Arena::CreateMaybeMessage<::SensorDataInt>(Arena*);
template<> ::iBeacon* Arena::CreateMaybeMessage<::iBeacon>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum Activtion : int {
  ABP = 0,
  OTA = 1
};
bool Activtion_IsValid(int value);
constexpr Activtion Activtion_MIN = ABP;
constexpr Activtion Activtion_MAX = OTA;
constexpr int Activtion_ARRAYSIZE = Activtion_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Activtion_descriptor();
template<typename T>
inline const std::string& Activtion_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Activtion>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Activtion_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Activtion_descriptor(), enum_t_value);
}
inline bool Activtion_Parse(
    const std::string& name, Activtion* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Activtion>(
    Activtion_descriptor(), name, value);
}
enum ClassType : int {
  CLASS_A = 0,
  CLASS_B = 1,
  CLASS_C = 2
};
bool ClassType_IsValid(int value);
constexpr ClassType ClassType_MIN = CLASS_A;
constexpr ClassType ClassType_MAX = CLASS_C;
constexpr int ClassType_ARRAYSIZE = ClassType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ClassType_descriptor();
template<typename T>
inline const std::string& ClassType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ClassType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ClassType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ClassType_descriptor(), enum_t_value);
}
inline bool ClassType_Parse(
    const std::string& name, ClassType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ClassType>(
    ClassType_descriptor(), name, value);
}
enum SensorError : int {
  SENSOR_ERR_NONE = 0,
  SENSOR_ERR_NO_DATA = 1,
  SENSOR_ERR_CRC = 2,
  SENSOR_ERR_DATA = 3,
  SENSOR_ERR_FAULT = 4,
  SENSOR_ERR_ALARM = 5,
  SENSOR_ERR_ALARM_HIGH = 6,
  SENSOR_ERR_ALARM_LOW = 7,
  SENSOR_ERR_UNKNOWN = 127
};
bool SensorError_IsValid(int value);
constexpr SensorError SensorError_MIN = SENSOR_ERR_NONE;
constexpr SensorError SensorError_MAX = SENSOR_ERR_UNKNOWN;
constexpr int SensorError_ARRAYSIZE = SensorError_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SensorError_descriptor();
template<typename T>
inline const std::string& SensorError_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SensorError>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SensorError_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SensorError_descriptor(), enum_t_value);
}
inline bool SensorError_Parse(
    const std::string& name, SensorError* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SensorError>(
    SensorError_descriptor(), name, value);
}
enum SensorType : int {
  SENSOR_TYPE_TEMP = 0,
  SENSOR_TYPE_HUMI = 1,
  SENSOR_TYPE_LIGHT = 2,
  SENSOR_TYPE_GPS = 3,
  SENSOR_TYPE_ANGLE = 4,
  SENSOR_TYPE_PM2_5 = 5,
  SENSOR_TYPE_PM10 = 6,
  SENSOR_TYPE_LEAK = 7,
  SENSOR_TYPE_CO = 8,
  SENSOR_TYPE_CO2 = 9,
  SENSOR_TYPE_NO2 = 10,
  SENSOR_TYPE_CH4 = 11,
  SENSOR_TYPE_LPG = 12,
  SENSOR_TYPE_FLAME = 13,
  SENSOR_TYPE_ARTIFICIAL_GAS = 14,
  SENSOR_TYPE_WATER_GAGE = 15,
  SENSOR_TYPE_TRACKER = 16
};
bool SensorType_IsValid(int value);
constexpr SensorType SensorType_MIN = SENSOR_TYPE_TEMP;
constexpr SensorType SensorType_MAX = SENSOR_TYPE_TRACKER;
constexpr int SensorType_ARRAYSIZE = SensorType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SensorType_descriptor();
template<typename T>
inline const std::string& SensorType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SensorType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SensorType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SensorType_descriptor(), enum_t_value);
}
inline bool SensorType_Parse(
    const std::string& name, SensorType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SensorType>(
    SensorType_descriptor(), name, value);
}
enum SensorStatus : int {
  SENSORO_STATUS_NONE = 0,
  SENSORO_STATUS_SELF_INSPECTION = 1,
  SENSORO_STATUS_ALARM = 2
};
bool SensorStatus_IsValid(int value);
constexpr SensorStatus SensorStatus_MIN = SENSORO_STATUS_NONE;
constexpr SensorStatus SensorStatus_MAX = SENSORO_STATUS_ALARM;
constexpr int SensorStatus_ARRAYSIZE = SensorStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SensorStatus_descriptor();
template<typename T>
inline const std::string& SensorStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SensorStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SensorStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SensorStatus_descriptor(), enum_t_value);
}
inline bool SensorStatus_Parse(
    const std::string& name, SensorStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SensorStatus>(
    SensorStatus_descriptor(), name, value);
}
enum AppCmd : int {
  APP_CMD_NONE = 0,
  APP_CMD_RESET = 1,
  APP_CMD_FAC_RESET = 2,
  APP_CMD_DFU = 3
};
bool AppCmd_IsValid(int value);
constexpr AppCmd AppCmd_MIN = APP_CMD_NONE;
constexpr AppCmd AppCmd_MAX = APP_CMD_DFU;
constexpr int AppCmd_ARRAYSIZE = AppCmd_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AppCmd_descriptor();
template<typename T>
inline const std::string& AppCmd_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AppCmd>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AppCmd_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AppCmd_descriptor(), enum_t_value);
}
inline bool AppCmd_Parse(
    const std::string& name, AppCmd* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AppCmd>(
    AppCmd_descriptor(), name, value);
}
enum NodeState : int {
  NODE_STATE_UNKNOWN = 0,
  NODE_STATE_STATIC = 1,
  NODE_STATE_MOVE = 2
};
bool NodeState_IsValid(int value);
constexpr NodeState NodeState_MIN = NODE_STATE_UNKNOWN;
constexpr NodeState NodeState_MAX = NODE_STATE_MOVE;
constexpr int NodeState_ARRAYSIZE = NodeState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NodeState_descriptor();
template<typename T>
inline const std::string& NodeState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NodeState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NodeState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NodeState_descriptor(), enum_t_value);
}
inline bool NodeState_Parse(
    const std::string& name, NodeState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NodeState>(
    NodeState_descriptor(), name, value);
}
enum NodeAlarm : int {
  NODE_ALARM_NONE = 0,
  NODE_ALARM_STATIC = 1,
  NODE_ALARM_MOVE = 2,
  NODE_ALARM_COLLISION = 3,
  NODE_ALARM_ROLL = 4,
  NODE_ALARM_INVERTED = 5,
  NODE_ALARM_FALL = 6
};
bool NodeAlarm_IsValid(int value);
constexpr NodeAlarm NodeAlarm_MIN = NODE_ALARM_NONE;
constexpr NodeAlarm NodeAlarm_MAX = NODE_ALARM_FALL;
constexpr int NodeAlarm_ARRAYSIZE = NodeAlarm_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NodeAlarm_descriptor();
template<typename T>
inline const std::string& NodeAlarm_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NodeAlarm>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NodeAlarm_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NodeAlarm_descriptor(), enum_t_value);
}
inline bool NodeAlarm_Parse(
    const std::string& name, NodeAlarm* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NodeAlarm>(
    NodeAlarm_descriptor(), name, value);
}
enum SmokeCtrl : int {
  SMOKE_CTRL_NONE = 0,
  SMOKE_ERASURE = 1,
  SMOKE_INSPECTION_TEST = 2,
  SMOKE_INSPECTION_OVER = 3,
  SMOKE_ERASURE_LONE = 4
};
bool SmokeCtrl_IsValid(int value);
constexpr SmokeCtrl SmokeCtrl_MIN = SMOKE_CTRL_NONE;
constexpr SmokeCtrl SmokeCtrl_MAX = SMOKE_ERASURE_LONE;
constexpr int SmokeCtrl_ARRAYSIZE = SmokeCtrl_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SmokeCtrl_descriptor();
template<typename T>
inline const std::string& SmokeCtrl_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SmokeCtrl>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SmokeCtrl_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SmokeCtrl_descriptor(), enum_t_value);
}
inline bool SmokeCtrl_Parse(
    const std::string& name, SmokeCtrl* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SmokeCtrl>(
    SmokeCtrl_descriptor(), name, value);
}
enum TrackerCtrl : int {
  TRACKER_Ctrl = 0,
  TRACKER_BOOT = 1,
  TRACKER_SHUTDOWN = 2,
  TRACKER_CALL_START = 3,
  TRACKER_CALL_END = 4,
  TRACKER_EMERGENCE_START = 5,
  TRACKER_EMERGENCE_END = 6
};
bool TrackerCtrl_IsValid(int value);
constexpr TrackerCtrl TrackerCtrl_MIN = TRACKER_Ctrl;
constexpr TrackerCtrl TrackerCtrl_MAX = TRACKER_EMERGENCE_END;
constexpr int TrackerCtrl_ARRAYSIZE = TrackerCtrl_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TrackerCtrl_descriptor();
template<typename T>
inline const std::string& TrackerCtrl_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TrackerCtrl>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TrackerCtrl_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TrackerCtrl_descriptor(), enum_t_value);
}
inline bool TrackerCtrl_Parse(
    const std::string& name, TrackerCtrl* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TrackerCtrl>(
    TrackerCtrl_descriptor(), name, value);
}
// ===================================================================

class Channel :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Channel) */ {
 public:
  Channel();
  virtual ~Channel();

  Channel(const Channel& from);
  Channel(Channel&& from) noexcept
    : Channel() {
    *this = ::std::move(from);
  }

  inline Channel& operator=(const Channel& from) {
    CopyFrom(from);
    return *this;
  }
  inline Channel& operator=(Channel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Channel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Channel* internal_default_instance() {
    return reinterpret_cast<const Channel*>(
               &_Channel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Channel* other);
  friend void swap(Channel& a, Channel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Channel* New() const final {
    return CreateMaybeMessage<Channel>(nullptr);
  }

  Channel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Channel>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Channel& from);
  void MergeFrom(const Channel& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Channel* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Channel";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_MsgNode_5f1v1_5fm22_2eproto);
    return ::descriptor_table_MsgNode_5f1v1_5fm22_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 frequency = 1;
  bool has_frequency() const;
  void clear_frequency();
  static const int kFrequencyFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 frequency() const;
  void set_frequency(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 rx1Frequency = 2;
  bool has_rx1frequency() const;
  void clear_rx1frequency();
  static const int kRx1FrequencyFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::uint32 rx1frequency() const;
  void set_rx1frequency(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:Channel)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 frequency_;
  ::PROTOBUF_NAMESPACE_ID::uint32 rx1frequency_;
  friend struct ::TableStruct_MsgNode_5f1v1_5fm22_2eproto;
};
// -------------------------------------------------------------------

class LpwanParam :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LpwanParam) */ {
 public:
  LpwanParam();
  virtual ~LpwanParam();

  LpwanParam(const LpwanParam& from);
  LpwanParam(LpwanParam&& from) noexcept
    : LpwanParam() {
    *this = ::std::move(from);
  }

  inline LpwanParam& operator=(const LpwanParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline LpwanParam& operator=(LpwanParam&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LpwanParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LpwanParam* internal_default_instance() {
    return reinterpret_cast<const LpwanParam*>(
               &_LpwanParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(LpwanParam* other);
  friend void swap(LpwanParam& a, LpwanParam& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LpwanParam* New() const final {
    return CreateMaybeMessage<LpwanParam>(nullptr);
  }

  LpwanParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LpwanParam>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LpwanParam& from);
  void MergeFrom(const LpwanParam& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LpwanParam* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LpwanParam";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_MsgNode_5f1v1_5fm22_2eproto);
    return ::descriptor_table_MsgNode_5f1v1_5fm22_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 channelMask = 13;
  int channelmask_size() const;
  void clear_channelmask();
  static const int kChannelMaskFieldNumber = 13;
  ::PROTOBUF_NAMESPACE_ID::uint32 channelmask(int index) const;
  void set_channelmask(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_channelmask(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      channelmask() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_channelmask();

  // repeated .Channel channels = 20;
  int channels_size() const;
  void clear_channels();
  static const int kChannelsFieldNumber = 20;
  ::Channel* mutable_channels(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Channel >*
      mutable_channels();
  const ::Channel& channels(int index) const;
  ::Channel* add_channels();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Channel >&
      channels() const;

  // optional bytes devEui = 1;
  bool has_deveui() const;
  void clear_deveui();
  static const int kDevEuiFieldNumber = 1;
  const std::string& deveui() const;
  void set_deveui(const std::string& value);
  void set_deveui(std::string&& value);
  void set_deveui(const char* value);
  void set_deveui(const void* value, size_t size);
  std::string* mutable_deveui();
  std::string* release_deveui();
  void set_allocated_deveui(std::string* deveui);

  // optional bytes appEui = 2;
  bool has_appeui() const;
  void clear_appeui();
  static const int kAppEuiFieldNumber = 2;
  const std::string& appeui() const;
  void set_appeui(const std::string& value);
  void set_appeui(std::string&& value);
  void set_appeui(const char* value);
  void set_appeui(const void* value, size_t size);
  std::string* mutable_appeui();
  std::string* release_appeui();
  void set_allocated_appeui(std::string* appeui);

  // optional bytes appKey = 3;
  bool has_appkey() const;
  void clear_appkey();
  static const int kAppKeyFieldNumber = 3;
  const std::string& appkey() const;
  void set_appkey(const std::string& value);
  void set_appkey(std::string&& value);
  void set_appkey(const char* value);
  void set_appkey(const void* value, size_t size);
  std::string* mutable_appkey();
  std::string* release_appkey();
  void set_allocated_appkey(std::string* appkey);

  // optional bytes appSkey = 4;
  bool has_appskey() const;
  void clear_appskey();
  static const int kAppSkeyFieldNumber = 4;
  const std::string& appskey() const;
  void set_appskey(const std::string& value);
  void set_appskey(std::string&& value);
  void set_appskey(const char* value);
  void set_appskey(const void* value, size_t size);
  std::string* mutable_appskey();
  std::string* release_appskey();
  void set_allocated_appskey(std::string* appskey);

  // optional bytes nwkSkey = 5;
  bool has_nwkskey() const;
  void clear_nwkskey();
  static const int kNwkSkeyFieldNumber = 5;
  const std::string& nwkskey() const;
  void set_nwkskey(const std::string& value);
  void set_nwkskey(std::string&& value);
  void set_nwkskey(const char* value);
  void set_nwkskey(const void* value, size_t size);
  std::string* mutable_nwkskey();
  std::string* release_nwkskey();
  void set_allocated_nwkskey(std::string* nwkskey);

  // optional uint32 devAddr = 6;
  bool has_devaddr() const;
  void clear_devaddr();
  static const int kDevAddrFieldNumber = 6;
  ::PROTOBUF_NAMESPACE_ID::uint32 devaddr() const;
  void set_devaddr(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 datarate = 7;
  bool has_datarate() const;
  void clear_datarate();
  static const int kDatarateFieldNumber = 7;
  ::PROTOBUF_NAMESPACE_ID::uint32 datarate() const;
  void set_datarate(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional sint32 txPower = 8;
  bool has_txpower() const;
  void clear_txpower();
  static const int kTxPowerFieldNumber = 8;
  ::PROTOBUF_NAMESPACE_ID::int32 txpower() const;
  void set_txpower(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional uint32 adr = 9;
  bool has_adr() const;
  void clear_adr();
  static const int kAdrFieldNumber = 9;
  ::PROTOBUF_NAMESPACE_ID::uint32 adr() const;
  void set_adr(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional .Activtion activition = 10;
  bool has_activition() const;
  void clear_activition();
  static const int kActivitionFieldNumber = 10;
  ::Activtion activition() const;
  void set_activition(::Activtion value);

  // optional .ClassType classType = 11;
  bool has_classtype() const;
  void clear_classtype();
  static const int kClassTypeFieldNumber = 11;
  ::ClassType classtype() const;
  void set_classtype(::ClassType value);

  // optional uint32 delay = 12;
  bool has_delay() const;
  void clear_delay();
  static const int kDelayFieldNumber = 12;
  ::PROTOBUF_NAMESPACE_ID::uint32 delay() const;
  void set_delay(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 maxEIRP = 14;
  bool has_maxeirp() const;
  void clear_maxeirp();
  static const int kMaxEIRPFieldNumber = 14;
  ::PROTOBUF_NAMESPACE_ID::uint32 maxeirp() const;
  void set_maxeirp(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 sglStatus = 15;
  bool has_sglstatus() const;
  void clear_sglstatus();
  static const int kSglStatusFieldNumber = 15;
  ::PROTOBUF_NAMESPACE_ID::uint32 sglstatus() const;
  void set_sglstatus(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 sglFrequency = 16;
  bool has_sglfrequency() const;
  void clear_sglfrequency();
  static const int kSglFrequencyFieldNumber = 16;
  ::PROTOBUF_NAMESPACE_ID::uint32 sglfrequency() const;
  void set_sglfrequency(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 sglDatarate = 17;
  bool has_sgldatarate() const;
  void clear_sgldatarate();
  static const int kSglDatarateFieldNumber = 17;
  ::PROTOBUF_NAMESPACE_ID::uint32 sgldatarate() const;
  void set_sgldatarate(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 lbtStatus = 18;
  bool has_lbtstatus() const;
  void clear_lbtstatus();
  static const int kLbtStatusFieldNumber = 18;
  ::PROTOBUF_NAMESPACE_ID::uint32 lbtstatus() const;
  void set_lbtstatus(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional sint32 lbtThreshold = 19;
  bool has_lbtthreshold() const;
  void clear_lbtthreshold();
  static const int kLbtThresholdFieldNumber = 19;
  ::PROTOBUF_NAMESPACE_ID::int32 lbtthreshold() const;
  void set_lbtthreshold(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:LpwanParam)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > channelmask_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Channel > channels_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deveui_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr appeui_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr appkey_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr appskey_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nwkskey_;
  ::PROTOBUF_NAMESPACE_ID::uint32 devaddr_;
  ::PROTOBUF_NAMESPACE_ID::uint32 datarate_;
  ::PROTOBUF_NAMESPACE_ID::int32 txpower_;
  ::PROTOBUF_NAMESPACE_ID::uint32 adr_;
  int activition_;
  int classtype_;
  ::PROTOBUF_NAMESPACE_ID::uint32 delay_;
  ::PROTOBUF_NAMESPACE_ID::uint32 maxeirp_;
  ::PROTOBUF_NAMESPACE_ID::uint32 sglstatus_;
  ::PROTOBUF_NAMESPACE_ID::uint32 sglfrequency_;
  ::PROTOBUF_NAMESPACE_ID::uint32 sgldatarate_;
  ::PROTOBUF_NAMESPACE_ID::uint32 lbtstatus_;
  ::PROTOBUF_NAMESPACE_ID::int32 lbtthreshold_;
  friend struct ::TableStruct_MsgNode_5f1v1_5fm22_2eproto;
};
// -------------------------------------------------------------------

class BleParam :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:BleParam) */ {
 public:
  BleParam();
  virtual ~BleParam();

  BleParam(const BleParam& from);
  BleParam(BleParam&& from) noexcept
    : BleParam() {
    *this = ::std::move(from);
  }

  inline BleParam& operator=(const BleParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline BleParam& operator=(BleParam&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BleParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BleParam* internal_default_instance() {
    return reinterpret_cast<const BleParam*>(
               &_BleParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(BleParam* other);
  friend void swap(BleParam& a, BleParam& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BleParam* New() const final {
    return CreateMaybeMessage<BleParam>(nullptr);
  }

  BleParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BleParam>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BleParam& from);
  void MergeFrom(const BleParam& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BleParam* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BleParam";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_MsgNode_5f1v1_5fm22_2eproto);
    return ::descriptor_table_MsgNode_5f1v1_5fm22_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float bleInterval = 1;
  bool has_bleinterval() const;
  void clear_bleinterval();
  static const int kBleIntervalFieldNumber = 1;
  float bleinterval() const;
  void set_bleinterval(float value);

  // optional sint32 bleTxp = 2;
  bool has_bletxp() const;
  void clear_bletxp();
  static const int kBleTxpFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::int32 bletxp() const;
  void set_bletxp(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional uint32 bleOnTime = 3;
  bool has_bleontime() const;
  void clear_bleontime();
  static const int kBleOnTimeFieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::uint32 bleontime() const;
  void set_bleontime(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 bleOffTime = 4;
  bool has_bleofftime() const;
  void clear_bleofftime();
  static const int kBleOffTimeFieldNumber = 4;
  ::PROTOBUF_NAMESPACE_ID::uint32 bleofftime() const;
  void set_bleofftime(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 bleOnOff = 5;
  bool has_bleonoff() const;
  void clear_bleonoff();
  static const int kBleOnOffFieldNumber = 5;
  ::PROTOBUF_NAMESPACE_ID::uint32 bleonoff() const;
  void set_bleonoff(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:BleParam)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float bleinterval_;
  ::PROTOBUF_NAMESPACE_ID::int32 bletxp_;
  ::PROTOBUF_NAMESPACE_ID::uint32 bleontime_;
  ::PROTOBUF_NAMESPACE_ID::uint32 bleofftime_;
  ::PROTOBUF_NAMESPACE_ID::uint32 bleonoff_;
  friend struct ::TableStruct_MsgNode_5f1v1_5fm22_2eproto;
};
// -------------------------------------------------------------------

class SensorData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SensorData) */ {
 public:
  SensorData();
  virtual ~SensorData();

  SensorData(const SensorData& from);
  SensorData(SensorData&& from) noexcept
    : SensorData() {
    *this = ::std::move(from);
  }

  inline SensorData& operator=(const SensorData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorData& operator=(SensorData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SensorData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SensorData* internal_default_instance() {
    return reinterpret_cast<const SensorData*>(
               &_SensorData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(SensorData* other);
  friend void swap(SensorData& a, SensorData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SensorData* New() const final {
    return CreateMaybeMessage<SensorData>(nullptr);
  }

  SensorData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SensorData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SensorData& from);
  void MergeFrom(const SensorData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SensorData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_MsgNode_5f1v1_5fm22_2eproto);
    return ::descriptor_table_MsgNode_5f1v1_5fm22_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float data = 1;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 1;
  float data() const;
  void set_data(float value);

  // optional float alarmHigh = 2;
  bool has_alarmhigh() const;
  void clear_alarmhigh();
  static const int kAlarmHighFieldNumber = 2;
  float alarmhigh() const;
  void set_alarmhigh(float value);

  // optional float alarmLow = 3;
  bool has_alarmlow() const;
  void clear_alarmlow();
  static const int kAlarmLowFieldNumber = 3;
  float alarmlow() const;
  void set_alarmlow(float value);

  // optional uint32 calibration = 4;
  bool has_calibration() const;
  void clear_calibration();
  static const int kCalibrationFieldNumber = 4;
  ::PROTOBUF_NAMESPACE_ID::uint32 calibration() const;
  void set_calibration(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional .SensorError error = 5;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 5;
  ::SensorError error() const;
  void set_error(::SensorError value);

  // optional uint32 status = 6;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 6;
  ::PROTOBUF_NAMESPACE_ID::uint32 status() const;
  void set_status(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional float alarmStepHigh = 7;
  bool has_alarmstephigh() const;
  void clear_alarmstephigh();
  static const int kAlarmStepHighFieldNumber = 7;
  float alarmstephigh() const;
  void set_alarmstephigh(float value);

  // optional float alarmStepLow = 8;
  bool has_alarmsteplow() const;
  void clear_alarmsteplow();
  static const int kAlarmStepLowFieldNumber = 8;
  float alarmsteplow() const;
  void set_alarmsteplow(float value);

  // optional .SensorType type = 9;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 9;
  ::SensorType type() const;
  void set_type(::SensorType value);

  // @@protoc_insertion_point(class_scope:SensorData)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float data_;
  float alarmhigh_;
  float alarmlow_;
  ::PROTOBUF_NAMESPACE_ID::uint32 calibration_;
  int error_;
  ::PROTOBUF_NAMESPACE_ID::uint32 status_;
  float alarmstephigh_;
  float alarmsteplow_;
  int type_;
  friend struct ::TableStruct_MsgNode_5f1v1_5fm22_2eproto;
};
// -------------------------------------------------------------------

class SensorDataInt :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SensorDataInt) */ {
 public:
  SensorDataInt();
  virtual ~SensorDataInt();

  SensorDataInt(const SensorDataInt& from);
  SensorDataInt(SensorDataInt&& from) noexcept
    : SensorDataInt() {
    *this = ::std::move(from);
  }

  inline SensorDataInt& operator=(const SensorDataInt& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorDataInt& operator=(SensorDataInt&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SensorDataInt& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SensorDataInt* internal_default_instance() {
    return reinterpret_cast<const SensorDataInt*>(
               &_SensorDataInt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(SensorDataInt* other);
  friend void swap(SensorDataInt& a, SensorDataInt& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SensorDataInt* New() const final {
    return CreateMaybeMessage<SensorDataInt>(nullptr);
  }

  SensorDataInt* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SensorDataInt>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SensorDataInt& from);
  void MergeFrom(const SensorDataInt& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorDataInt* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SensorDataInt";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_MsgNode_5f1v1_5fm22_2eproto);
    return ::descriptor_table_MsgNode_5f1v1_5fm22_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SensorType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::SensorType type() const;
  void set_type(::SensorType value);

  // optional sint32 data = 2;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::int32 data() const;
  void set_data(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional sint32 alarmHigh = 3;
  bool has_alarmhigh() const;
  void clear_alarmhigh();
  static const int kAlarmHighFieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::int32 alarmhigh() const;
  void set_alarmhigh(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional sint32 alarmLow = 4;
  bool has_alarmlow() const;
  void clear_alarmlow();
  static const int kAlarmLowFieldNumber = 4;
  ::PROTOBUF_NAMESPACE_ID::int32 alarmlow() const;
  void set_alarmlow(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional sint32 calibration = 5;
  bool has_calibration() const;
  void clear_calibration();
  static const int kCalibrationFieldNumber = 5;
  ::PROTOBUF_NAMESPACE_ID::int32 calibration() const;
  void set_calibration(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional .SensorError error = 6;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 6;
  ::SensorError error() const;
  void set_error(::SensorError value);

  // optional uint32 status = 7;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 7;
  ::PROTOBUF_NAMESPACE_ID::uint32 status() const;
  void set_status(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional sint32 alarmStepHigh = 8;
  bool has_alarmstephigh() const;
  void clear_alarmstephigh();
  static const int kAlarmStepHighFieldNumber = 8;
  ::PROTOBUF_NAMESPACE_ID::int32 alarmstephigh() const;
  void set_alarmstephigh(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional sint32 alarmStepLow = 9;
  bool has_alarmsteplow() const;
  void clear_alarmsteplow();
  static const int kAlarmStepLowFieldNumber = 9;
  ::PROTOBUF_NAMESPACE_ID::int32 alarmsteplow() const;
  void set_alarmsteplow(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:SensorDataInt)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int type_;
  ::PROTOBUF_NAMESPACE_ID::int32 data_;
  ::PROTOBUF_NAMESPACE_ID::int32 alarmhigh_;
  ::PROTOBUF_NAMESPACE_ID::int32 alarmlow_;
  ::PROTOBUF_NAMESPACE_ID::int32 calibration_;
  int error_;
  ::PROTOBUF_NAMESPACE_ID::uint32 status_;
  ::PROTOBUF_NAMESPACE_ID::int32 alarmstephigh_;
  ::PROTOBUF_NAMESPACE_ID::int32 alarmsteplow_;
  friend struct ::TableStruct_MsgNode_5f1v1_5fm22_2eproto;
};
// -------------------------------------------------------------------

class SensorDataFloat :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SensorDataFloat) */ {
 public:
  SensorDataFloat();
  virtual ~SensorDataFloat();

  SensorDataFloat(const SensorDataFloat& from);
  SensorDataFloat(SensorDataFloat&& from) noexcept
    : SensorDataFloat() {
    *this = ::std::move(from);
  }

  inline SensorDataFloat& operator=(const SensorDataFloat& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorDataFloat& operator=(SensorDataFloat&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SensorDataFloat& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SensorDataFloat* internal_default_instance() {
    return reinterpret_cast<const SensorDataFloat*>(
               &_SensorDataFloat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(SensorDataFloat* other);
  friend void swap(SensorDataFloat& a, SensorDataFloat& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SensorDataFloat* New() const final {
    return CreateMaybeMessage<SensorDataFloat>(nullptr);
  }

  SensorDataFloat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SensorDataFloat>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SensorDataFloat& from);
  void MergeFrom(const SensorDataFloat& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorDataFloat* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SensorDataFloat";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_MsgNode_5f1v1_5fm22_2eproto);
    return ::descriptor_table_MsgNode_5f1v1_5fm22_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SensorType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::SensorType type() const;
  void set_type(::SensorType value);

  // optional float data = 2;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  float data() const;
  void set_data(float value);

  // optional float alarmHigh = 3;
  bool has_alarmhigh() const;
  void clear_alarmhigh();
  static const int kAlarmHighFieldNumber = 3;
  float alarmhigh() const;
  void set_alarmhigh(float value);

  // optional float alarmLow = 4;
  bool has_alarmlow() const;
  void clear_alarmlow();
  static const int kAlarmLowFieldNumber = 4;
  float alarmlow() const;
  void set_alarmlow(float value);

  // optional sint32 calibration = 5;
  bool has_calibration() const;
  void clear_calibration();
  static const int kCalibrationFieldNumber = 5;
  ::PROTOBUF_NAMESPACE_ID::int32 calibration() const;
  void set_calibration(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional .SensorError error = 6;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 6;
  ::SensorError error() const;
  void set_error(::SensorError value);

  // optional uint32 status = 7;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 7;
  ::PROTOBUF_NAMESPACE_ID::uint32 status() const;
  void set_status(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional float alarmStepHigh = 8;
  bool has_alarmstephigh() const;
  void clear_alarmstephigh();
  static const int kAlarmStepHighFieldNumber = 8;
  float alarmstephigh() const;
  void set_alarmstephigh(float value);

  // optional float alarmStepLow = 9;
  bool has_alarmsteplow() const;
  void clear_alarmsteplow();
  static const int kAlarmStepLowFieldNumber = 9;
  float alarmsteplow() const;
  void set_alarmsteplow(float value);

  // @@protoc_insertion_point(class_scope:SensorDataFloat)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int type_;
  float data_;
  float alarmhigh_;
  float alarmlow_;
  ::PROTOBUF_NAMESPACE_ID::int32 calibration_;
  int error_;
  ::PROTOBUF_NAMESPACE_ID::uint32 status_;
  float alarmstephigh_;
  float alarmsteplow_;
  friend struct ::TableStruct_MsgNode_5f1v1_5fm22_2eproto;
};
// -------------------------------------------------------------------

class MultiSensorData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MultiSensorData) */ {
 public:
  MultiSensorData();
  virtual ~MultiSensorData();

  MultiSensorData(const MultiSensorData& from);
  MultiSensorData(MultiSensorData&& from) noexcept
    : MultiSensorData() {
    *this = ::std::move(from);
  }

  inline MultiSensorData& operator=(const MultiSensorData& from) {
    CopyFrom(from);
    return *this;
  }
  inline MultiSensorData& operator=(MultiSensorData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MultiSensorData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MultiSensorData* internal_default_instance() {
    return reinterpret_cast<const MultiSensorData*>(
               &_MultiSensorData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(MultiSensorData* other);
  friend void swap(MultiSensorData& a, MultiSensorData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MultiSensorData* New() const final {
    return CreateMaybeMessage<MultiSensorData>(nullptr);
  }

  MultiSensorData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MultiSensorData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MultiSensorData& from);
  void MergeFrom(const MultiSensorData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiSensorData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MultiSensorData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_MsgNode_5f1v1_5fm22_2eproto);
    return ::descriptor_table_MsgNode_5f1v1_5fm22_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float data = 1;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 1;
  float data(int index) const;
  void set_data(int index, float value);
  void add_data(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_data();

  // optional float alarmHigh = 2;
  bool has_alarmhigh() const;
  void clear_alarmhigh();
  static const int kAlarmHighFieldNumber = 2;
  float alarmhigh() const;
  void set_alarmhigh(float value);

  // optional float alarmLow = 3;
  bool has_alarmlow() const;
  void clear_alarmlow();
  static const int kAlarmLowFieldNumber = 3;
  float alarmlow() const;
  void set_alarmlow(float value);

  // optional uint32 calibration = 4;
  bool has_calibration() const;
  void clear_calibration();
  static const int kCalibrationFieldNumber = 4;
  ::PROTOBUF_NAMESPACE_ID::uint32 calibration() const;
  void set_calibration(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional .SensorError error = 5;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 5;
  ::SensorError error() const;
  void set_error(::SensorError value);

  // optional uint32 status = 6;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 6;
  ::PROTOBUF_NAMESPACE_ID::uint32 status() const;
  void set_status(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional float alarmStepHigh = 7;
  bool has_alarmstephigh() const;
  void clear_alarmstephigh();
  static const int kAlarmStepHighFieldNumber = 7;
  float alarmstephigh() const;
  void set_alarmstephigh(float value);

  // optional float alarmStepLow = 8;
  bool has_alarmsteplow() const;
  void clear_alarmsteplow();
  static const int kAlarmStepLowFieldNumber = 8;
  float alarmsteplow() const;
  void set_alarmsteplow(float value);

  // @@protoc_insertion_point(class_scope:MultiSensorData)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > data_;
  float alarmhigh_;
  float alarmlow_;
  ::PROTOBUF_NAMESPACE_ID::uint32 calibration_;
  int error_;
  ::PROTOBUF_NAMESPACE_ID::uint32 status_;
  float alarmstephigh_;
  float alarmsteplow_;
  friend struct ::TableStruct_MsgNode_5f1v1_5fm22_2eproto;
};
// -------------------------------------------------------------------

class MultiSensorDataInt :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MultiSensorDataInt) */ {
 public:
  MultiSensorDataInt();
  virtual ~MultiSensorDataInt();

  MultiSensorDataInt(const MultiSensorDataInt& from);
  MultiSensorDataInt(MultiSensorDataInt&& from) noexcept
    : MultiSensorDataInt() {
    *this = ::std::move(from);
  }

  inline MultiSensorDataInt& operator=(const MultiSensorDataInt& from) {
    CopyFrom(from);
    return *this;
  }
  inline MultiSensorDataInt& operator=(MultiSensorDataInt&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MultiSensorDataInt& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MultiSensorDataInt* internal_default_instance() {
    return reinterpret_cast<const MultiSensorDataInt*>(
               &_MultiSensorDataInt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(MultiSensorDataInt* other);
  friend void swap(MultiSensorDataInt& a, MultiSensorDataInt& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MultiSensorDataInt* New() const final {
    return CreateMaybeMessage<MultiSensorDataInt>(nullptr);
  }

  MultiSensorDataInt* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MultiSensorDataInt>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MultiSensorDataInt& from);
  void MergeFrom(const MultiSensorDataInt& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiSensorDataInt* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MultiSensorDataInt";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_MsgNode_5f1v1_5fm22_2eproto);
    return ::descriptor_table_MsgNode_5f1v1_5fm22_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated sint32 data = 1;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::int32 data(int index) const;
  void set_data(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_data(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_data();

  // optional sint32 alarmHigh = 2;
  bool has_alarmhigh() const;
  void clear_alarmhigh();
  static const int kAlarmHighFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::int32 alarmhigh() const;
  void set_alarmhigh(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional sint32 alarmLow = 3;
  bool has_alarmlow() const;
  void clear_alarmlow();
  static const int kAlarmLowFieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::int32 alarmlow() const;
  void set_alarmlow(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional uint32 calibration = 4;
  bool has_calibration() const;
  void clear_calibration();
  static const int kCalibrationFieldNumber = 4;
  ::PROTOBUF_NAMESPACE_ID::uint32 calibration() const;
  void set_calibration(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional .SensorError error = 5;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 5;
  ::SensorError error() const;
  void set_error(::SensorError value);

  // optional uint32 status = 6;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 6;
  ::PROTOBUF_NAMESPACE_ID::uint32 status() const;
  void set_status(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional sint32 alarmStepHigh = 7;
  bool has_alarmstephigh() const;
  void clear_alarmstephigh();
  static const int kAlarmStepHighFieldNumber = 7;
  ::PROTOBUF_NAMESPACE_ID::int32 alarmstephigh() const;
  void set_alarmstephigh(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional sint32 alarmStepLow = 8;
  bool has_alarmsteplow() const;
  void clear_alarmsteplow();
  static const int kAlarmStepLowFieldNumber = 8;
  ::PROTOBUF_NAMESPACE_ID::int32 alarmsteplow() const;
  void set_alarmsteplow(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:MultiSensorDataInt)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > data_;
  ::PROTOBUF_NAMESPACE_ID::int32 alarmhigh_;
  ::PROTOBUF_NAMESPACE_ID::int32 alarmlow_;
  ::PROTOBUF_NAMESPACE_ID::uint32 calibration_;
  int error_;
  ::PROTOBUF_NAMESPACE_ID::uint32 status_;
  ::PROTOBUF_NAMESPACE_ID::int32 alarmstephigh_;
  ::PROTOBUF_NAMESPACE_ID::int32 alarmsteplow_;
  friend struct ::TableStruct_MsgNode_5f1v1_5fm22_2eproto;
};
// -------------------------------------------------------------------

class GpsData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GpsData) */ {
 public:
  GpsData();
  virtual ~GpsData();

  GpsData(const GpsData& from);
  GpsData(GpsData&& from) noexcept
    : GpsData() {
    *this = ::std::move(from);
  }

  inline GpsData& operator=(const GpsData& from) {
    CopyFrom(from);
    return *this;
  }
  inline GpsData& operator=(GpsData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GpsData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GpsData* internal_default_instance() {
    return reinterpret_cast<const GpsData*>(
               &_GpsData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(GpsData* other);
  friend void swap(GpsData& a, GpsData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GpsData* New() const final {
    return CreateMaybeMessage<GpsData>(nullptr);
  }

  GpsData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GpsData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GpsData& from);
  void MergeFrom(const GpsData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GpsData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GpsData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_MsgNode_5f1v1_5fm22_2eproto);
    return ::descriptor_table_MsgNode_5f1v1_5fm22_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double latitude = 1;
  bool has_latitude() const;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 1;
  double latitude() const;
  void set_latitude(double value);

  // optional double longitude = 2;
  bool has_longitude() const;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 2;
  double longitude() const;
  void set_longitude(double value);

  // optional double altitude = 3;
  bool has_altitude() const;
  void clear_altitude();
  static const int kAltitudeFieldNumber = 3;
  double altitude() const;
  void set_altitude(double value);

  // @@protoc_insertion_point(class_scope:GpsData)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double latitude_;
  double longitude_;
  double altitude_;
  friend struct ::TableStruct_MsgNode_5f1v1_5fm22_2eproto;
};
// -------------------------------------------------------------------

class AxisData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AxisData) */ {
 public:
  AxisData();
  virtual ~AxisData();

  AxisData(const AxisData& from);
  AxisData(AxisData&& from) noexcept
    : AxisData() {
    *this = ::std::move(from);
  }

  inline AxisData& operator=(const AxisData& from) {
    CopyFrom(from);
    return *this;
  }
  inline AxisData& operator=(AxisData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AxisData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AxisData* internal_default_instance() {
    return reinterpret_cast<const AxisData*>(
               &_AxisData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(AxisData* other);
  friend void swap(AxisData& a, AxisData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AxisData* New() const final {
    return CreateMaybeMessage<AxisData>(nullptr);
  }

  AxisData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AxisData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AxisData& from);
  void MergeFrom(const AxisData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AxisData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AxisData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_MsgNode_5f1v1_5fm22_2eproto);
    return ::descriptor_table_MsgNode_5f1v1_5fm22_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // optional float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // optional float z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:AxisData)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float x_;
  float y_;
  float z_;
  friend struct ::TableStruct_MsgNode_5f1v1_5fm22_2eproto;
};
// -------------------------------------------------------------------

class iBeacon :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iBeacon) */ {
 public:
  iBeacon();
  virtual ~iBeacon();

  iBeacon(const iBeacon& from);
  iBeacon(iBeacon&& from) noexcept
    : iBeacon() {
    *this = ::std::move(from);
  }

  inline iBeacon& operator=(const iBeacon& from) {
    CopyFrom(from);
    return *this;
  }
  inline iBeacon& operator=(iBeacon&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const iBeacon& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const iBeacon* internal_default_instance() {
    return reinterpret_cast<const iBeacon*>(
               &_iBeacon_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(iBeacon* other);
  friend void swap(iBeacon& a, iBeacon& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline iBeacon* New() const final {
    return CreateMaybeMessage<iBeacon>(nullptr);
  }

  iBeacon* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<iBeacon>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const iBeacon& from);
  void MergeFrom(const iBeacon& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(iBeacon* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iBeacon";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_MsgNode_5f1v1_5fm22_2eproto);
    return ::descriptor_table_MsgNode_5f1v1_5fm22_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes uuid = 1;
  bool has_uuid() const;
  void clear_uuid();
  static const int kUuidFieldNumber = 1;
  const std::string& uuid() const;
  void set_uuid(const std::string& value);
  void set_uuid(std::string&& value);
  void set_uuid(const char* value);
  void set_uuid(const void* value, size_t size);
  std::string* mutable_uuid();
  std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);

  // optional uint32 major = 2;
  bool has_major() const;
  void clear_major();
  static const int kMajorFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::uint32 major() const;
  void set_major(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 minor = 3;
  bool has_minor() const;
  void clear_minor();
  static const int kMinorFieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::uint32 minor() const;
  void set_minor(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional sint32 mrssi = 4;
  bool has_mrssi() const;
  void clear_mrssi();
  static const int kMrssiFieldNumber = 4;
  ::PROTOBUF_NAMESPACE_ID::int32 mrssi() const;
  void set_mrssi(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:iBeacon)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
  ::PROTOBUF_NAMESPACE_ID::uint32 major_;
  ::PROTOBUF_NAMESPACE_ID::uint32 minor_;
  ::PROTOBUF_NAMESPACE_ID::int32 mrssi_;
  friend struct ::TableStruct_MsgNode_5f1v1_5fm22_2eproto;
};
// -------------------------------------------------------------------

class ExtSmoke :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ExtSmoke) */ {
 public:
  ExtSmoke();
  virtual ~ExtSmoke();

  ExtSmoke(const ExtSmoke& from);
  ExtSmoke(ExtSmoke&& from) noexcept
    : ExtSmoke() {
    *this = ::std::move(from);
  }

  inline ExtSmoke& operator=(const ExtSmoke& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExtSmoke& operator=(ExtSmoke&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ExtSmoke& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExtSmoke* internal_default_instance() {
    return reinterpret_cast<const ExtSmoke*>(
               &_ExtSmoke_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(ExtSmoke* other);
  friend void swap(ExtSmoke& a, ExtSmoke& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExtSmoke* New() const final {
    return CreateMaybeMessage<ExtSmoke>(nullptr);
  }

  ExtSmoke* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExtSmoke>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ExtSmoke& from);
  void MergeFrom(const ExtSmoke& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExtSmoke* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ExtSmoke";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_MsgNode_5f1v1_5fm22_2eproto);
    return ::descriptor_table_MsgNode_5f1v1_5fm22_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 bgSignal = 1;
  bool has_bgsignal() const;
  void clear_bgsignal();
  static const int kBgSignalFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 bgsignal() const;
  void set_bgsignal(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 bgSignalThreshold = 2;
  bool has_bgsignalthreshold() const;
  void clear_bgsignalthreshold();
  static const int kBgSignalThresholdFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::uint32 bgsignalthreshold() const;
  void set_bgsignalthreshold(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 bgSignalCalibration = 3;
  bool has_bgsignalcalibration() const;
  void clear_bgsignalcalibration();
  static const int kBgSignalCalibrationFieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::uint32 bgsignalcalibration() const;
  void set_bgsignalcalibration(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:ExtSmoke)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 bgsignal_;
  ::PROTOBUF_NAMESPACE_ID::uint32 bgsignalthreshold_;
  ::PROTOBUF_NAMESPACE_ID::uint32 bgsignalcalibration_;
  friend struct ::TableStruct_MsgNode_5f1v1_5fm22_2eproto;
};
// -------------------------------------------------------------------

class AppParam :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AppParam) */ {
 public:
  AppParam();
  virtual ~AppParam();

  AppParam(const AppParam& from);
  AppParam(AppParam&& from) noexcept
    : AppParam() {
    *this = ::std::move(from);
  }

  inline AppParam& operator=(const AppParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppParam& operator=(AppParam&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AppParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AppParam* internal_default_instance() {
    return reinterpret_cast<const AppParam*>(
               &_AppParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(AppParam* other);
  friend void swap(AppParam& a, AppParam& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AppParam* New() const final {
    return CreateMaybeMessage<AppParam>(nullptr);
  }

  AppParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AppParam>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AppParam& from);
  void MergeFrom(const AppParam& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppParam* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AppParam";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_MsgNode_5f1v1_5fm22_2eproto);
    return ::descriptor_table_MsgNode_5f1v1_5fm22_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .AppCmd cmd = 1;
  bool has_cmd() const;
  void clear_cmd();
  static const int kCmdFieldNumber = 1;
  ::AppCmd cmd() const;
  void set_cmd(::AppCmd value);

  // optional uint32 uploadInterval = 2;
  bool has_uploadinterval() const;
  void clear_uploadinterval();
  static const int kUploadIntervalFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::uint32 uploadinterval() const;
  void set_uploadinterval(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 syncTime = 3;
  bool has_synctime() const;
  void clear_synctime();
  static const int kSyncTimeFieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::uint32 synctime() const;
  void set_synctime(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional .NodeState nodeState = 4;
  bool has_nodestate() const;
  void clear_nodestate();
  static const int kNodeStateFieldNumber = 4;
  ::NodeState nodestate() const;
  void set_nodestate(::NodeState value);

  // optional .NodeAlarm nodeAlarm = 5;
  bool has_nodealarm() const;
  void clear_nodealarm();
  static const int kNodeAlarmFieldNumber = 5;
  ::NodeAlarm nodealarm() const;
  void set_nodealarm(::NodeAlarm value);

  // optional uint32 nodeAlarmSet = 6;
  bool has_nodealarmset() const;
  void clear_nodealarmset();
  static const int kNodeAlarmSetFieldNumber = 6;
  ::PROTOBUF_NAMESPACE_ID::uint32 nodealarmset() const;
  void set_nodealarmset(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 confirm = 7;
  bool has_confirm() const;
  void clear_confirm();
  static const int kConfirmFieldNumber = 7;
  ::PROTOBUF_NAMESPACE_ID::uint32 confirm() const;
  void set_confirm(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional .SmokeCtrl smokeCtrl = 8;
  bool has_smokectrl() const;
  void clear_smokectrl();
  static const int kSmokeCtrlFieldNumber = 8;
  ::SmokeCtrl smokectrl() const;
  void set_smokectrl(::SmokeCtrl value);

  // optional uint32 uploadRepeat = 9;
  bool has_uploadrepeat() const;
  void clear_uploadrepeat();
  static const int kUploadRepeatFieldNumber = 9;
  ::PROTOBUF_NAMESPACE_ID::uint32 uploadrepeat() const;
  void set_uploadrepeat(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 alarmUploadInterval = 10;
  bool has_alarmuploadinterval() const;
  void clear_alarmuploadinterval();
  static const int kAlarmUploadIntervalFieldNumber = 10;
  ::PROTOBUF_NAMESPACE_ID::uint32 alarmuploadinterval() const;
  void set_alarmuploadinterval(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 alarmUploadNb = 11;
  bool has_alarmuploadnb() const;
  void clear_alarmuploadnb();
  static const int kAlarmUploadNbFieldNumber = 11;
  ::PROTOBUF_NAMESPACE_ID::uint32 alarmuploadnb() const;
  void set_alarmuploadnb(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional .TrackerCtrl trackerCtrl = 12;
  bool has_trackerctrl() const;
  void clear_trackerctrl();
  static const int kTrackerCtrlFieldNumber = 12;
  ::TrackerCtrl trackerctrl() const;
  void set_trackerctrl(::TrackerCtrl value);

  // optional uint32 trackerEmergencyTime = 13;
  bool has_trackeremergencytime() const;
  void clear_trackeremergencytime();
  static const int kTrackerEmergencyTimeFieldNumber = 13;
  ::PROTOBUF_NAMESPACE_ID::uint32 trackeremergencytime() const;
  void set_trackeremergencytime(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 demoMode = 14;
  bool has_demomode() const;
  void clear_demomode();
  static const int kDemoModeFieldNumber = 14;
  ::PROTOBUF_NAMESPACE_ID::uint32 demomode() const;
  void set_demomode(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:AppParam)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int cmd_;
  ::PROTOBUF_NAMESPACE_ID::uint32 uploadinterval_;
  ::PROTOBUF_NAMESPACE_ID::uint32 synctime_;
  int nodestate_;
  int nodealarm_;
  ::PROTOBUF_NAMESPACE_ID::uint32 nodealarmset_;
  ::PROTOBUF_NAMESPACE_ID::uint32 confirm_;
  int smokectrl_;
  ::PROTOBUF_NAMESPACE_ID::uint32 uploadrepeat_;
  ::PROTOBUF_NAMESPACE_ID::uint32 alarmuploadinterval_;
  ::PROTOBUF_NAMESPACE_ID::uint32 alarmuploadnb_;
  int trackerctrl_;
  ::PROTOBUF_NAMESPACE_ID::uint32 trackeremergencytime_;
  ::PROTOBUF_NAMESPACE_ID::uint32 demomode_;
  friend struct ::TableStruct_MsgNode_5f1v1_5fm22_2eproto;
};
// -------------------------------------------------------------------

class ElecFireData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ElecFireData) */ {
 public:
  ElecFireData();
  virtual ~ElecFireData();

  ElecFireData(const ElecFireData& from);
  ElecFireData(ElecFireData&& from) noexcept
    : ElecFireData() {
    *this = ::std::move(from);
  }

  inline ElecFireData& operator=(const ElecFireData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ElecFireData& operator=(ElecFireData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ElecFireData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ElecFireData* internal_default_instance() {
    return reinterpret_cast<const ElecFireData*>(
               &_ElecFireData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(ElecFireData* other);
  friend void swap(ElecFireData& a, ElecFireData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ElecFireData* New() const final {
    return CreateMaybeMessage<ElecFireData>(nullptr);
  }

  ElecFireData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ElecFireData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ElecFireData& from);
  void MergeFrom(const ElecFireData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ElecFireData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ElecFireData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_MsgNode_5f1v1_5fm22_2eproto);
    return ::descriptor_table_MsgNode_5f1v1_5fm22_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint32 vol_val = 1;
  bool has_vol_val() const;
  void clear_vol_val();
  static const int kVolValFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::int32 vol_val() const;
  void set_vol_val(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional uint32 curr_val = 2;
  bool has_curr_val() const;
  void clear_curr_val();
  static const int kCurrValFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::uint32 curr_val() const;
  void set_curr_val(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional sint32 leakage_val = 3;
  bool has_leakage_val() const;
  void clear_leakage_val();
  static const int kLeakageValFieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::int32 leakage_val() const;
  void set_leakage_val(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional uint32 power_val = 4;
  bool has_power_val() const;
  void clear_power_val();
  static const int kPowerValFieldNumber = 4;
  ::PROTOBUF_NAMESPACE_ID::uint32 power_val() const;
  void set_power_val(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 elec_energy_val = 5;
  bool has_elec_energy_val() const;
  void clear_elec_energy_val();
  static const int kElecEnergyValFieldNumber = 5;
  ::PROTOBUF_NAMESPACE_ID::uint32 elec_energy_val() const;
  void set_elec_energy_val(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 temp_val = 6;
  bool has_temp_val() const;
  void clear_temp_val();
  static const int kTempValFieldNumber = 6;
  ::PROTOBUF_NAMESPACE_ID::uint32 temp_val() const;
  void set_temp_val(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 status = 7;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 7;
  ::PROTOBUF_NAMESPACE_ID::uint32 status() const;
  void set_status(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 alarm = 8;
  bool has_alarm() const;
  void clear_alarm();
  static const int kAlarmFieldNumber = 8;
  ::PROTOBUF_NAMESPACE_ID::uint32 alarm() const;
  void set_alarm(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 error = 9;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 9;
  ::PROTOBUF_NAMESPACE_ID::uint32 error() const;
  void set_error(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 sensorPwd = 10;
  bool has_sensorpwd() const;
  void clear_sensorpwd();
  static const int kSensorPwdFieldNumber = 10;
  ::PROTOBUF_NAMESPACE_ID::uint32 sensorpwd() const;
  void set_sensorpwd(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 leakageTh = 11;
  bool has_leakageth() const;
  void clear_leakageth();
  static const int kLeakageThFieldNumber = 11;
  ::PROTOBUF_NAMESPACE_ID::uint32 leakageth() const;
  void set_leakageth(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 tempTh = 12;
  bool has_tempth() const;
  void clear_tempth();
  static const int kTempThFieldNumber = 12;
  ::PROTOBUF_NAMESPACE_ID::uint32 tempth() const;
  void set_tempth(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 currentTh = 13;
  bool has_currentth() const;
  void clear_currentth();
  static const int kCurrentThFieldNumber = 13;
  ::PROTOBUF_NAMESPACE_ID::uint32 currentth() const;
  void set_currentth(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 loadTh = 14;
  bool has_loadth() const;
  void clear_loadth();
  static const int kLoadThFieldNumber = 14;
  ::PROTOBUF_NAMESPACE_ID::uint32 loadth() const;
  void set_loadth(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 volHighTh = 15;
  bool has_volhighth() const;
  void clear_volhighth();
  static const int kVolHighThFieldNumber = 15;
  ::PROTOBUF_NAMESPACE_ID::uint32 volhighth() const;
  void set_volhighth(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 volLowTh = 16;
  bool has_vollowth() const;
  void clear_vollowth();
  static const int kVolLowThFieldNumber = 16;
  ::PROTOBUF_NAMESPACE_ID::uint32 vollowth() const;
  void set_vollowth(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 cmd = 17;
  bool has_cmd() const;
  void clear_cmd();
  static const int kCmdFieldNumber = 17;
  ::PROTOBUF_NAMESPACE_ID::uint32 cmd() const;
  void set_cmd(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 autoSwitch = 18;
  bool has_autoswitch() const;
  void clear_autoswitch();
  static const int kAutoSwitchFieldNumber = 18;
  ::PROTOBUF_NAMESPACE_ID::uint32 autoswitch() const;
  void set_autoswitch(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:ElecFireData)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 vol_val_;
  ::PROTOBUF_NAMESPACE_ID::uint32 curr_val_;
  ::PROTOBUF_NAMESPACE_ID::int32 leakage_val_;
  ::PROTOBUF_NAMESPACE_ID::uint32 power_val_;
  ::PROTOBUF_NAMESPACE_ID::uint32 elec_energy_val_;
  ::PROTOBUF_NAMESPACE_ID::uint32 temp_val_;
  ::PROTOBUF_NAMESPACE_ID::uint32 status_;
  ::PROTOBUF_NAMESPACE_ID::uint32 alarm_;
  ::PROTOBUF_NAMESPACE_ID::uint32 error_;
  ::PROTOBUF_NAMESPACE_ID::uint32 sensorpwd_;
  ::PROTOBUF_NAMESPACE_ID::uint32 leakageth_;
  ::PROTOBUF_NAMESPACE_ID::uint32 tempth_;
  ::PROTOBUF_NAMESPACE_ID::uint32 currentth_;
  ::PROTOBUF_NAMESPACE_ID::uint32 loadth_;
  ::PROTOBUF_NAMESPACE_ID::uint32 volhighth_;
  ::PROTOBUF_NAMESPACE_ID::uint32 vollowth_;
  ::PROTOBUF_NAMESPACE_ID::uint32 cmd_;
  ::PROTOBUF_NAMESPACE_ID::uint32 autoswitch_;
  friend struct ::TableStruct_MsgNode_5f1v1_5fm22_2eproto;
};
// -------------------------------------------------------------------

class MantunData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MantunData) */ {
 public:
  MantunData();
  virtual ~MantunData();

  MantunData(const MantunData& from);
  MantunData(MantunData&& from) noexcept
    : MantunData() {
    *this = ::std::move(from);
  }

  inline MantunData& operator=(const MantunData& from) {
    CopyFrom(from);
    return *this;
  }
  inline MantunData& operator=(MantunData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MantunData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MantunData* internal_default_instance() {
    return reinterpret_cast<const MantunData*>(
               &_MantunData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(MantunData* other);
  friend void swap(MantunData& a, MantunData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MantunData* New() const final {
    return CreateMaybeMessage<MantunData>(nullptr);
  }

  MantunData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MantunData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MantunData& from);
  void MergeFrom(const MantunData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MantunData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MantunData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_MsgNode_5f1v1_5fm22_2eproto);
    return ::descriptor_table_MsgNode_5f1v1_5fm22_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 volVal = 1;
  bool has_volval() const;
  void clear_volval();
  static const int kVolValFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 volval() const;
  void set_volval(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 leakageVal = 2;
  bool has_leakageval() const;
  void clear_leakageval();
  static const int kLeakageValFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::uint32 leakageval() const;
  void set_leakageval(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 powerVal = 3;
  bool has_powerval() const;
  void clear_powerval();
  static const int kPowerValFieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::uint32 powerval() const;
  void set_powerval(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 tempVal = 4;
  bool has_tempval() const;
  void clear_tempval();
  static const int kTempValFieldNumber = 4;
  ::PROTOBUF_NAMESPACE_ID::uint32 tempval() const;
  void set_tempval(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 currVal = 5;
  bool has_currval() const;
  void clear_currval();
  static const int kCurrValFieldNumber = 5;
  ::PROTOBUF_NAMESPACE_ID::uint32 currval() const;
  void set_currval(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 status = 6;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 6;
  ::PROTOBUF_NAMESPACE_ID::uint32 status() const;
  void set_status(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 kwhVal = 7;
  bool has_kwhval() const;
  void clear_kwhval();
  static const int kKwhValFieldNumber = 7;
  ::PROTOBUF_NAMESPACE_ID::uint32 kwhval() const;
  void set_kwhval(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 swOnOff = 8;
  bool has_swonoff() const;
  void clear_swonoff();
  static const int kSwOnOffFieldNumber = 8;
  ::PROTOBUF_NAMESPACE_ID::uint32 swonoff() const;
  void set_swonoff(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 volHighTh = 9;
  bool has_volhighth() const;
  void clear_volhighth();
  static const int kVolHighThFieldNumber = 9;
  ::PROTOBUF_NAMESPACE_ID::uint32 volhighth() const;
  void set_volhighth(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 volLowTh = 10;
  bool has_vollowth() const;
  void clear_vollowth();
  static const int kVolLowThFieldNumber = 10;
  ::PROTOBUF_NAMESPACE_ID::uint32 vollowth() const;
  void set_vollowth(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 leakageTh = 11;
  bool has_leakageth() const;
  void clear_leakageth();
  static const int kLeakageThFieldNumber = 11;
  ::PROTOBUF_NAMESPACE_ID::uint32 leakageth() const;
  void set_leakageth(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 tempTh = 12;
  bool has_tempth() const;
  void clear_tempth();
  static const int kTempThFieldNumber = 12;
  ::PROTOBUF_NAMESPACE_ID::uint32 tempth() const;
  void set_tempth(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 currentTh = 13;
  bool has_currentth() const;
  void clear_currentth();
  static const int kCurrentThFieldNumber = 13;
  ::PROTOBUF_NAMESPACE_ID::uint32 currentth() const;
  void set_currentth(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 powerTh = 14;
  bool has_powerth() const;
  void clear_powerth();
  static const int kPowerThFieldNumber = 14;
  ::PROTOBUF_NAMESPACE_ID::uint32 powerth() const;
  void set_powerth(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 attribute = 15;
  bool has_attribute() const;
  void clear_attribute();
  static const int kAttributeFieldNumber = 15;
  ::PROTOBUF_NAMESPACE_ID::uint32 attribute() const;
  void set_attribute(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 cmd = 16;
  bool has_cmd() const;
  void clear_cmd();
  static const int kCmdFieldNumber = 16;
  ::PROTOBUF_NAMESPACE_ID::uint32 cmd() const;
  void set_cmd(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 devError = 17;
  bool has_deverror() const;
  void clear_deverror();
  static const int kDevErrorFieldNumber = 17;
  ::PROTOBUF_NAMESPACE_ID::uint32 deverror() const;
  void set_deverror(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 version = 18;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 18;
  ::PROTOBUF_NAMESPACE_ID::uint32 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 id = 19;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 19;
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:MantunData)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 volval_;
  ::PROTOBUF_NAMESPACE_ID::uint32 leakageval_;
  ::PROTOBUF_NAMESPACE_ID::uint32 powerval_;
  ::PROTOBUF_NAMESPACE_ID::uint32 tempval_;
  ::PROTOBUF_NAMESPACE_ID::uint32 currval_;
  ::PROTOBUF_NAMESPACE_ID::uint32 status_;
  ::PROTOBUF_NAMESPACE_ID::uint32 kwhval_;
  ::PROTOBUF_NAMESPACE_ID::uint32 swonoff_;
  ::PROTOBUF_NAMESPACE_ID::uint32 volhighth_;
  ::PROTOBUF_NAMESPACE_ID::uint32 vollowth_;
  ::PROTOBUF_NAMESPACE_ID::uint32 leakageth_;
  ::PROTOBUF_NAMESPACE_ID::uint32 tempth_;
  ::PROTOBUF_NAMESPACE_ID::uint32 currentth_;
  ::PROTOBUF_NAMESPACE_ID::uint32 powerth_;
  ::PROTOBUF_NAMESPACE_ID::uint32 attribute_;
  ::PROTOBUF_NAMESPACE_ID::uint32 cmd_;
  ::PROTOBUF_NAMESPACE_ID::uint32 deverror_;
  ::PROTOBUF_NAMESPACE_ID::uint32 version_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  friend struct ::TableStruct_MsgNode_5f1v1_5fm22_2eproto;
};
// -------------------------------------------------------------------

class Cayman :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Cayman) */ {
 public:
  Cayman();
  virtual ~Cayman();

  Cayman(const Cayman& from);
  Cayman(Cayman&& from) noexcept
    : Cayman() {
    *this = ::std::move(from);
  }

  inline Cayman& operator=(const Cayman& from) {
    CopyFrom(from);
    return *this;
  }
  inline Cayman& operator=(Cayman&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Cayman& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Cayman* internal_default_instance() {
    return reinterpret_cast<const Cayman*>(
               &_Cayman_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(Cayman* other);
  friend void swap(Cayman& a, Cayman& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Cayman* New() const final {
    return CreateMaybeMessage<Cayman>(nullptr);
  }

  Cayman* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Cayman>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Cayman& from);
  void MergeFrom(const Cayman& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Cayman* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Cayman";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_MsgNode_5f1v1_5fm22_2eproto);
    return ::descriptor_table_MsgNode_5f1v1_5fm22_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 isSmoke = 1;
  bool has_issmoke() const;
  void clear_issmoke();
  static const int kIsSmokeFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 issmoke() const;
  void set_issmoke(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 isMoved = 2;
  bool has_ismoved() const;
  void clear_ismoved();
  static const int kIsMovedFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::uint32 ismoved() const;
  void set_ismoved(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional sint32 valueOfTem = 3;
  bool has_valueoftem() const;
  void clear_valueoftem();
  static const int kValueOfTemFieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::int32 valueoftem() const;
  void set_valueoftem(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional uint32 valueOfHum = 4;
  bool has_valueofhum() const;
  void clear_valueofhum();
  static const int kValueOfHumFieldNumber = 4;
  ::PROTOBUF_NAMESPACE_ID::uint32 valueofhum() const;
  void set_valueofhum(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 valueOfSmoke = 5;
  bool has_valueofsmoke() const;
  void clear_valueofsmoke();
  static const int kValueOfSmokeFieldNumber = 5;
  ::PROTOBUF_NAMESPACE_ID::uint32 valueofsmoke() const;
  void set_valueofsmoke(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 standarOfSmoke = 6;
  bool has_standarofsmoke() const;
  void clear_standarofsmoke();
  static const int kStandarOfSmokeFieldNumber = 6;
  ::PROTOBUF_NAMESPACE_ID::uint32 standarofsmoke() const;
  void set_standarofsmoke(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional sint32 alarmOfHighTem = 7;
  bool has_alarmofhightem() const;
  void clear_alarmofhightem();
  static const int kAlarmOfHighTemFieldNumber = 7;
  ::PROTOBUF_NAMESPACE_ID::int32 alarmofhightem() const;
  void set_alarmofhightem(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional sint32 alarmOfLowTem = 8;
  bool has_alarmoflowtem() const;
  void clear_alarmoflowtem();
  static const int kAlarmOfLowTemFieldNumber = 8;
  ::PROTOBUF_NAMESPACE_ID::int32 alarmoflowtem() const;
  void set_alarmoflowtem(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional uint32 alarmOfHighHum = 9;
  bool has_alarmofhighhum() const;
  void clear_alarmofhighhum();
  static const int kAlarmOfHighHumFieldNumber = 9;
  ::PROTOBUF_NAMESPACE_ID::uint32 alarmofhighhum() const;
  void set_alarmofhighhum(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 alarmOfLowHum = 10;
  bool has_alarmoflowhum() const;
  void clear_alarmoflowhum();
  static const int kAlarmOfLowHumFieldNumber = 10;
  ::PROTOBUF_NAMESPACE_ID::uint32 alarmoflowhum() const;
  void set_alarmoflowhum(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 cmd = 11;
  bool has_cmd() const;
  void clear_cmd();
  static const int kCmdFieldNumber = 11;
  ::PROTOBUF_NAMESPACE_ID::uint32 cmd() const;
  void set_cmd(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 valueOfphotor = 12;
  bool has_valueofphotor() const;
  void clear_valueofphotor();
  static const int kValueOfphotorFieldNumber = 12;
  ::PROTOBUF_NAMESPACE_ID::uint32 valueofphotor() const;
  void set_valueofphotor(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 devceState = 13;
  bool has_devcestate() const;
  void clear_devcestate();
  static const int kDevceStateFieldNumber = 13;
  ::PROTOBUF_NAMESPACE_ID::uint32 devcestate() const;
  void set_devcestate(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 bleAdvType = 14;
  bool has_bleadvtype() const;
  void clear_bleadvtype();
  static const int kBleAdvTypeFieldNumber = 14;
  ::PROTOBUF_NAMESPACE_ID::uint32 bleadvtype() const;
  void set_bleadvtype(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 bleAdvStartTime = 15;
  bool has_bleadvstarttime() const;
  void clear_bleadvstarttime();
  static const int kBleAdvStartTimeFieldNumber = 15;
  ::PROTOBUF_NAMESPACE_ID::uint32 bleadvstarttime() const;
  void set_bleadvstarttime(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 bleAdvEndTime = 16;
  bool has_bleadvendtime() const;
  void clear_bleadvendtime();
  static const int kBleAdvEndTimeFieldNumber = 16;
  ::PROTOBUF_NAMESPACE_ID::uint32 bleadvendtime() const;
  void set_bleadvendtime(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 valueOfBatb = 17;
  bool has_valueofbatb() const;
  void clear_valueofbatb();
  static const int kValueOfBatbFieldNumber = 17;
  ::PROTOBUF_NAMESPACE_ID::uint32 valueofbatb() const;
  void set_valueofbatb(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 levelOfAlarm = 18;
  bool has_levelofalarm() const;
  void clear_levelofalarm();
  static const int kLevelOfAlarmFieldNumber = 18;
  ::PROTOBUF_NAMESPACE_ID::uint32 levelofalarm() const;
  void set_levelofalarm(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 isSelfCheck = 19;
  bool has_isselfcheck() const;
  void clear_isselfcheck();
  static const int kIsSelfCheckFieldNumber = 19;
  ::PROTOBUF_NAMESPACE_ID::uint32 isselfcheck() const;
  void set_isselfcheck(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:Cayman)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 issmoke_;
  ::PROTOBUF_NAMESPACE_ID::uint32 ismoved_;
  ::PROTOBUF_NAMESPACE_ID::int32 valueoftem_;
  ::PROTOBUF_NAMESPACE_ID::uint32 valueofhum_;
  ::PROTOBUF_NAMESPACE_ID::uint32 valueofsmoke_;
  ::PROTOBUF_NAMESPACE_ID::uint32 standarofsmoke_;
  ::PROTOBUF_NAMESPACE_ID::int32 alarmofhightem_;
  ::PROTOBUF_NAMESPACE_ID::int32 alarmoflowtem_;
  ::PROTOBUF_NAMESPACE_ID::uint32 alarmofhighhum_;
  ::PROTOBUF_NAMESPACE_ID::uint32 alarmoflowhum_;
  ::PROTOBUF_NAMESPACE_ID::uint32 cmd_;
  ::PROTOBUF_NAMESPACE_ID::uint32 valueofphotor_;
  ::PROTOBUF_NAMESPACE_ID::uint32 devcestate_;
  ::PROTOBUF_NAMESPACE_ID::uint32 bleadvtype_;
  ::PROTOBUF_NAMESPACE_ID::uint32 bleadvstarttime_;
  ::PROTOBUF_NAMESPACE_ID::uint32 bleadvendtime_;
  ::PROTOBUF_NAMESPACE_ID::uint32 valueofbatb_;
  ::PROTOBUF_NAMESPACE_ID::uint32 levelofalarm_;
  ::PROTOBUF_NAMESPACE_ID::uint32 isselfcheck_;
  friend struct ::TableStruct_MsgNode_5f1v1_5fm22_2eproto;
};
// -------------------------------------------------------------------

class AcrelData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AcrelData) */ {
 public:
  AcrelData();
  virtual ~AcrelData();

  AcrelData(const AcrelData& from);
  AcrelData(AcrelData&& from) noexcept
    : AcrelData() {
    *this = ::std::move(from);
  }

  inline AcrelData& operator=(const AcrelData& from) {
    CopyFrom(from);
    return *this;
  }
  inline AcrelData& operator=(AcrelData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AcrelData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AcrelData* internal_default_instance() {
    return reinterpret_cast<const AcrelData*>(
               &_AcrelData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(AcrelData* other);
  friend void swap(AcrelData& a, AcrelData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AcrelData* New() const final {
    return CreateMaybeMessage<AcrelData>(nullptr);
  }

  AcrelData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AcrelData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AcrelData& from);
  void MergeFrom(const AcrelData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AcrelData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AcrelData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_MsgNode_5f1v1_5fm22_2eproto);
    return ::descriptor_table_MsgNode_5f1v1_5fm22_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 channelType = 1;
  bool has_channeltype() const;
  void clear_channeltype();
  static const int kChannelTypeFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 channeltype() const;
  void set_channeltype(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 shortCircuit = 2;
  bool has_shortcircuit() const;
  void clear_shortcircuit();
  static const int kShortCircuitFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::uint32 shortcircuit() const;
  void set_shortcircuit(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 openCircuit = 3;
  bool has_opencircuit() const;
  void clear_opencircuit();
  static const int kOpenCircuitFieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::uint32 opencircuit() const;
  void set_opencircuit(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 chStatus = 4;
  bool has_chstatus() const;
  void clear_chstatus();
  static const int kChStatusFieldNumber = 4;
  ::PROTOBUF_NAMESPACE_ID::uint32 chstatus() const;
  void set_chstatus(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional sint32 leakageVal = 5;
  bool has_leakageval() const;
  void clear_leakageval();
  static const int kLeakageValFieldNumber = 5;
  ::PROTOBUF_NAMESPACE_ID::int32 leakageval() const;
  void set_leakageval(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional sint32 t1Val = 6;
  bool has_t1val() const;
  void clear_t1val();
  static const int kT1ValFieldNumber = 6;
  ::PROTOBUF_NAMESPACE_ID::int32 t1val() const;
  void set_t1val(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional sint32 t2Val = 7;
  bool has_t2val() const;
  void clear_t2val();
  static const int kT2ValFieldNumber = 7;
  ::PROTOBUF_NAMESPACE_ID::int32 t2val() const;
  void set_t2val(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional sint32 t3Val = 8;
  bool has_t3val() const;
  void clear_t3val();
  static const int kT3ValFieldNumber = 8;
  ::PROTOBUF_NAMESPACE_ID::int32 t3val() const;
  void set_t3val(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional sint32 t4Val = 9;
  bool has_t4val() const;
  void clear_t4val();
  static const int kT4ValFieldNumber = 9;
  ::PROTOBUF_NAMESPACE_ID::int32 t4val() const;
  void set_t4val(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional uint32 connectSw = 10;
  bool has_connectsw() const;
  void clear_connectsw();
  static const int kConnectSwFieldNumber = 10;
  ::PROTOBUF_NAMESPACE_ID::uint32 connectsw() const;
  void set_connectsw(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 chEnable = 11;
  bool has_chenable() const;
  void clear_chenable();
  static const int kChEnableFieldNumber = 11;
  ::PROTOBUF_NAMESPACE_ID::uint32 chenable() const;
  void set_chenable(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 leakageTh = 12;
  bool has_leakageth() const;
  void clear_leakageth();
  static const int kLeakageThFieldNumber = 12;
  ::PROTOBUF_NAMESPACE_ID::uint32 leakageth() const;
  void set_leakageth(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 t1Th = 13;
  bool has_t1th() const;
  void clear_t1th();
  static const int kT1ThFieldNumber = 13;
  ::PROTOBUF_NAMESPACE_ID::uint32 t1th() const;
  void set_t1th(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 t2Th = 14;
  bool has_t2th() const;
  void clear_t2th();
  static const int kT2ThFieldNumber = 14;
  ::PROTOBUF_NAMESPACE_ID::uint32 t2th() const;
  void set_t2th(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 t3Th = 15;
  bool has_t3th() const;
  void clear_t3th();
  static const int kT3ThFieldNumber = 15;
  ::PROTOBUF_NAMESPACE_ID::uint32 t3th() const;
  void set_t3th(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 t4Th = 16;
  bool has_t4th() const;
  void clear_t4th();
  static const int kT4ThFieldNumber = 16;
  ::PROTOBUF_NAMESPACE_ID::uint32 t4th() const;
  void set_t4th(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 passwd = 17;
  bool has_passwd() const;
  void clear_passwd();
  static const int kPasswdFieldNumber = 17;
  ::PROTOBUF_NAMESPACE_ID::uint32 passwd() const;
  void set_passwd(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 aVal = 18;
  bool has_aval() const;
  void clear_aval();
  static const int kAValFieldNumber = 18;
  ::PROTOBUF_NAMESPACE_ID::uint32 aval() const;
  void set_aval(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 bVal = 19;
  bool has_bval() const;
  void clear_bval();
  static const int kBValFieldNumber = 19;
  ::PROTOBUF_NAMESPACE_ID::uint32 bval() const;
  void set_bval(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 cVal = 20;
  bool has_cval() const;
  void clear_cval();
  static const int kCValFieldNumber = 20;
  ::PROTOBUF_NAMESPACE_ID::uint32 cval() const;
  void set_cval(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 valStatus = 21;
  bool has_valstatus() const;
  void clear_valstatus();
  static const int kValStatusFieldNumber = 21;
  ::PROTOBUF_NAMESPACE_ID::uint32 valstatus() const;
  void set_valstatus(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 aCurr = 22;
  bool has_acurr() const;
  void clear_acurr();
  static const int kACurrFieldNumber = 22;
  ::PROTOBUF_NAMESPACE_ID::uint32 acurr() const;
  void set_acurr(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 bCurr = 23;
  bool has_bcurr() const;
  void clear_bcurr();
  static const int kBCurrFieldNumber = 23;
  ::PROTOBUF_NAMESPACE_ID::uint32 bcurr() const;
  void set_bcurr(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 cCurr = 24;
  bool has_ccurr() const;
  void clear_ccurr();
  static const int kCCurrFieldNumber = 24;
  ::PROTOBUF_NAMESPACE_ID::uint32 ccurr() const;
  void set_ccurr(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 currStatus = 25;
  bool has_currstatus() const;
  void clear_currstatus();
  static const int kCurrStatusFieldNumber = 25;
  ::PROTOBUF_NAMESPACE_ID::uint32 currstatus() const;
  void set_currstatus(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 totalYg = 26;
  bool has_totalyg() const;
  void clear_totalyg();
  static const int kTotalYgFieldNumber = 26;
  ::PROTOBUF_NAMESPACE_ID::uint32 totalyg() const;
  void set_totalyg(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 totalWg = 27;
  bool has_totalwg() const;
  void clear_totalwg();
  static const int kTotalWgFieldNumber = 27;
  ::PROTOBUF_NAMESPACE_ID::uint32 totalwg() const;
  void set_totalwg(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 totalSz = 28;
  bool has_totalsz() const;
  void clear_totalsz();
  static const int kTotalSzFieldNumber = 28;
  ::PROTOBUF_NAMESPACE_ID::uint32 totalsz() const;
  void set_totalsz(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 totalFactor = 29;
  bool has_totalfactor() const;
  void clear_totalfactor();
  static const int kTotalFactorFieldNumber = 29;
  ::PROTOBUF_NAMESPACE_ID::uint32 totalfactor() const;
  void set_totalfactor(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 valHighSet = 30;
  bool has_valhighset() const;
  void clear_valhighset();
  static const int kValHighSetFieldNumber = 30;
  ::PROTOBUF_NAMESPACE_ID::uint32 valhighset() const;
  void set_valhighset(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 valLowSet = 31;
  bool has_vallowset() const;
  void clear_vallowset();
  static const int kValLowSetFieldNumber = 31;
  ::PROTOBUF_NAMESPACE_ID::uint32 vallowset() const;
  void set_vallowset(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 currHighSet = 32;
  bool has_currhighset() const;
  void clear_currhighset();
  static const int kCurrHighSetFieldNumber = 32;
  ::PROTOBUF_NAMESPACE_ID::uint32 currhighset() const;
  void set_currhighset(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 energyKwh = 33;
  bool has_energykwh() const;
  void clear_energykwh();
  static const int kEnergyKwhFieldNumber = 33;
  ::PROTOBUF_NAMESPACE_ID::uint32 energykwh() const;
  void set_energykwh(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 cmd = 35;
  bool has_cmd() const;
  void clear_cmd();
  static const int kCmdFieldNumber = 35;
  ::PROTOBUF_NAMESPACE_ID::uint32 cmd() const;
  void set_cmd(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 devError = 36;
  bool has_deverror() const;
  void clear_deverror();
  static const int kDevErrorFieldNumber = 36;
  ::PROTOBUF_NAMESPACE_ID::uint32 deverror() const;
  void set_deverror(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 ct = 37;
  bool has_ct() const;
  void clear_ct();
  static const int kCtFieldNumber = 37;
  ::PROTOBUF_NAMESPACE_ID::uint32 ct() const;
  void set_ct(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 outputSw = 38;
  bool has_outputsw() const;
  void clear_outputsw();
  static const int kOutputSwFieldNumber = 38;
  ::PROTOBUF_NAMESPACE_ID::uint32 outputsw() const;
  void set_outputsw(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 selfCheck = 39;
  bool has_selfcheck() const;
  void clear_selfcheck();
  static const int kSelfCheckFieldNumber = 39;
  ::PROTOBUF_NAMESPACE_ID::uint32 selfcheck() const;
  void set_selfcheck(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 valHighType = 40;
  bool has_valhightype() const;
  void clear_valhightype();
  static const int kValHighTypeFieldNumber = 40;
  ::PROTOBUF_NAMESPACE_ID::uint32 valhightype() const;
  void set_valhightype(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 valLowType = 41;
  bool has_vallowtype() const;
  void clear_vallowtype();
  static const int kValLowTypeFieldNumber = 41;
  ::PROTOBUF_NAMESPACE_ID::uint32 vallowtype() const;
  void set_vallowtype(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 currHighType = 42;
  bool has_currhightype() const;
  void clear_currhightype();
  static const int kCurrHighTypeFieldNumber = 42;
  ::PROTOBUF_NAMESPACE_ID::uint32 currhightype() const;
  void set_currhightype(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 ict = 43;
  bool has_ict() const;
  void clear_ict();
  static const int kIctFieldNumber = 43;
  ::PROTOBUF_NAMESPACE_ID::uint32 ict() const;
  void set_ict(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 un = 44;
  bool has_un() const;
  void clear_un();
  static const int kUnFieldNumber = 44;
  ::PROTOBUF_NAMESPACE_ID::uint32 un() const;
  void set_un(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 in = 45;
  bool has_in() const;
  void clear_in();
  static const int kInFieldNumber = 45;
  ::PROTOBUF_NAMESPACE_ID::uint32 in() const;
  void set_in(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 pt = 46;
  bool has_pt() const;
  void clear_pt();
  static const int kPtFieldNumber = 46;
  ::PROTOBUF_NAMESPACE_ID::uint32 pt() const;
  void set_pt(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 lineMode = 47;
  bool has_linemode() const;
  void clear_linemode();
  static const int kLineModeFieldNumber = 47;
  ::PROTOBUF_NAMESPACE_ID::uint32 linemode() const;
  void set_linemode(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 lineOrder = 48;
  bool has_lineorder() const;
  void clear_lineorder();
  static const int kLineOrderFieldNumber = 48;
  ::PROTOBUF_NAMESPACE_ID::uint32 lineorder() const;
  void set_lineorder(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 volFreq = 49;
  bool has_volfreq() const;
  void clear_volfreq();
  static const int kVolFreqFieldNumber = 49;
  ::PROTOBUF_NAMESPACE_ID::uint32 volfreq() const;
  void set_volfreq(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 leakageDelay = 50;
  bool has_leakagedelay() const;
  void clear_leakagedelay();
  static const int kLeakageDelayFieldNumber = 50;
  ::PROTOBUF_NAMESPACE_ID::uint32 leakagedelay() const;
  void set_leakagedelay(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 T1Delay = 51;
  bool has_t1delay() const;
  void clear_t1delay();
  static const int kT1DelayFieldNumber = 51;
  ::PROTOBUF_NAMESPACE_ID::uint32 t1delay() const;
  void set_t1delay(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 T2Delay = 52;
  bool has_t2delay() const;
  void clear_t2delay();
  static const int kT2DelayFieldNumber = 52;
  ::PROTOBUF_NAMESPACE_ID::uint32 t2delay() const;
  void set_t2delay(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 T3Delay = 53;
  bool has_t3delay() const;
  void clear_t3delay();
  static const int kT3DelayFieldNumber = 53;
  ::PROTOBUF_NAMESPACE_ID::uint32 t3delay() const;
  void set_t3delay(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 T4Delay = 54;
  bool has_t4delay() const;
  void clear_t4delay();
  static const int kT4DelayFieldNumber = 54;
  ::PROTOBUF_NAMESPACE_ID::uint32 t4delay() const;
  void set_t4delay(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 volHDelay = 55;
  bool has_volhdelay() const;
  void clear_volhdelay();
  static const int kVolHDelayFieldNumber = 55;
  ::PROTOBUF_NAMESPACE_ID::uint32 volhdelay() const;
  void set_volhdelay(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 volLDelay = 56;
  bool has_volldelay() const;
  void clear_volldelay();
  static const int kVolLDelayFieldNumber = 56;
  ::PROTOBUF_NAMESPACE_ID::uint32 volldelay() const;
  void set_volldelay(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 currDelay = 57;
  bool has_currdelay() const;
  void clear_currdelay();
  static const int kCurrDelayFieldNumber = 57;
  ::PROTOBUF_NAMESPACE_ID::uint32 currdelay() const;
  void set_currdelay(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:AcrelData)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<2> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 channeltype_;
  ::PROTOBUF_NAMESPACE_ID::uint32 shortcircuit_;
  ::PROTOBUF_NAMESPACE_ID::uint32 opencircuit_;
  ::PROTOBUF_NAMESPACE_ID::uint32 chstatus_;
  ::PROTOBUF_NAMESPACE_ID::int32 leakageval_;
  ::PROTOBUF_NAMESPACE_ID::int32 t1val_;
  ::PROTOBUF_NAMESPACE_ID::int32 t2val_;
  ::PROTOBUF_NAMESPACE_ID::int32 t3val_;
  ::PROTOBUF_NAMESPACE_ID::int32 t4val_;
  ::PROTOBUF_NAMESPACE_ID::uint32 connectsw_;
  ::PROTOBUF_NAMESPACE_ID::uint32 chenable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 leakageth_;
  ::PROTOBUF_NAMESPACE_ID::uint32 t1th_;
  ::PROTOBUF_NAMESPACE_ID::uint32 t2th_;
  ::PROTOBUF_NAMESPACE_ID::uint32 t3th_;
  ::PROTOBUF_NAMESPACE_ID::uint32 t4th_;
  ::PROTOBUF_NAMESPACE_ID::uint32 passwd_;
  ::PROTOBUF_NAMESPACE_ID::uint32 aval_;
  ::PROTOBUF_NAMESPACE_ID::uint32 bval_;
  ::PROTOBUF_NAMESPACE_ID::uint32 cval_;
  ::PROTOBUF_NAMESPACE_ID::uint32 valstatus_;
  ::PROTOBUF_NAMESPACE_ID::uint32 acurr_;
  ::PROTOBUF_NAMESPACE_ID::uint32 bcurr_;
  ::PROTOBUF_NAMESPACE_ID::uint32 ccurr_;
  ::PROTOBUF_NAMESPACE_ID::uint32 currstatus_;
  ::PROTOBUF_NAMESPACE_ID::uint32 totalyg_;
  ::PROTOBUF_NAMESPACE_ID::uint32 totalwg_;
  ::PROTOBUF_NAMESPACE_ID::uint32 totalsz_;
  ::PROTOBUF_NAMESPACE_ID::uint32 totalfactor_;
  ::PROTOBUF_NAMESPACE_ID::uint32 valhighset_;
  ::PROTOBUF_NAMESPACE_ID::uint32 vallowset_;
  ::PROTOBUF_NAMESPACE_ID::uint32 currhighset_;
  ::PROTOBUF_NAMESPACE_ID::uint32 energykwh_;
  ::PROTOBUF_NAMESPACE_ID::uint32 cmd_;
  ::PROTOBUF_NAMESPACE_ID::uint32 deverror_;
  ::PROTOBUF_NAMESPACE_ID::uint32 ct_;
  ::PROTOBUF_NAMESPACE_ID::uint32 outputsw_;
  ::PROTOBUF_NAMESPACE_ID::uint32 selfcheck_;
  ::PROTOBUF_NAMESPACE_ID::uint32 valhightype_;
  ::PROTOBUF_NAMESPACE_ID::uint32 vallowtype_;
  ::PROTOBUF_NAMESPACE_ID::uint32 currhightype_;
  ::PROTOBUF_NAMESPACE_ID::uint32 ict_;
  ::PROTOBUF_NAMESPACE_ID::uint32 un_;
  ::PROTOBUF_NAMESPACE_ID::uint32 in_;
  ::PROTOBUF_NAMESPACE_ID::uint32 pt_;
  ::PROTOBUF_NAMESPACE_ID::uint32 linemode_;
  ::PROTOBUF_NAMESPACE_ID::uint32 lineorder_;
  ::PROTOBUF_NAMESPACE_ID::uint32 volfreq_;
  ::PROTOBUF_NAMESPACE_ID::uint32 leakagedelay_;
  ::PROTOBUF_NAMESPACE_ID::uint32 t1delay_;
  ::PROTOBUF_NAMESPACE_ID::uint32 t2delay_;
  ::PROTOBUF_NAMESPACE_ID::uint32 t3delay_;
  ::PROTOBUF_NAMESPACE_ID::uint32 t4delay_;
  ::PROTOBUF_NAMESPACE_ID::uint32 volhdelay_;
  ::PROTOBUF_NAMESPACE_ID::uint32 volldelay_;
  ::PROTOBUF_NAMESPACE_ID::uint32 currdelay_;
  friend struct ::TableStruct_MsgNode_5f1v1_5fm22_2eproto;
};
// -------------------------------------------------------------------

class Baymax :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Baymax) */ {
 public:
  Baymax();
  virtual ~Baymax();

  Baymax(const Baymax& from);
  Baymax(Baymax&& from) noexcept
    : Baymax() {
    *this = ::std::move(from);
  }

  inline Baymax& operator=(const Baymax& from) {
    CopyFrom(from);
    return *this;
  }
  inline Baymax& operator=(Baymax&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Baymax& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Baymax* internal_default_instance() {
    return reinterpret_cast<const Baymax*>(
               &_Baymax_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(Baymax* other);
  friend void swap(Baymax& a, Baymax& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Baymax* New() const final {
    return CreateMaybeMessage<Baymax>(nullptr);
  }

  Baymax* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Baymax>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Baymax& from);
  void MergeFrom(const Baymax& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Baymax* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Baymax";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_MsgNode_5f1v1_5fm22_2eproto);
    return ::descriptor_table_MsgNode_5f1v1_5fm22_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 gasDevClass = 1;
  bool has_gasdevclass() const;
  void clear_gasdevclass();
  static const int kGasDevClassFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 gasdevclass() const;
  void set_gasdevclass(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 gasDensity = 2;
  bool has_gasdensity() const;
  void clear_gasdensity();
  static const int kGasDensityFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::uint32 gasdensity() const;
  void set_gasdensity(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 gasDensityL1 = 3;
  bool has_gasdensityl1() const;
  void clear_gasdensityl1();
  static const int kGasDensityL1FieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::uint32 gasdensityl1() const;
  void set_gasdensityl1(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 gasDensityL2 = 4;
  bool has_gasdensityl2() const;
  void clear_gasdensityl2();
  static const int kGasDensityL2FieldNumber = 4;
  ::PROTOBUF_NAMESPACE_ID::uint32 gasdensityl2() const;
  void set_gasdensityl2(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 gasDensityL3 = 5;
  bool has_gasdensityl3() const;
  void clear_gasdensityl3();
  static const int kGasDensityL3FieldNumber = 5;
  ::PROTOBUF_NAMESPACE_ID::uint32 gasdensityl3() const;
  void set_gasdensityl3(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 gasDisassembly = 6;
  bool has_gasdisassembly() const;
  void clear_gasdisassembly();
  static const int kGasDisassemblyFieldNumber = 6;
  ::PROTOBUF_NAMESPACE_ID::uint32 gasdisassembly() const;
  void set_gasdisassembly(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 gasLosePwr = 7;
  bool has_gaslosepwr() const;
  void clear_gaslosepwr();
  static const int kGasLosePwrFieldNumber = 7;
  ::PROTOBUF_NAMESPACE_ID::uint32 gaslosepwr() const;
  void set_gaslosepwr(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 gasEMValve = 8;
  bool has_gasemvalve() const;
  void clear_gasemvalve();
  static const int kGasEMValveFieldNumber = 8;
  ::PROTOBUF_NAMESPACE_ID::uint32 gasemvalve() const;
  void set_gasemvalve(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 gasDeviceStatus = 9;
  bool has_gasdevicestatus() const;
  void clear_gasdevicestatus();
  static const int kGasDeviceStatusFieldNumber = 9;
  ::PROTOBUF_NAMESPACE_ID::uint32 gasdevicestatus() const;
  void set_gasdevicestatus(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 gasDeviceOpState = 10;
  bool has_gasdeviceopstate() const;
  void clear_gasdeviceopstate();
  static const int kGasDeviceOpStateFieldNumber = 10;
  ::PROTOBUF_NAMESPACE_ID::uint32 gasdeviceopstate() const;
  void set_gasdeviceopstate(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 gasDeviceComsDown = 11;
  bool has_gasdevicecomsdown() const;
  void clear_gasdevicecomsdown();
  static const int kGasDeviceComsDownFieldNumber = 11;
  ::PROTOBUF_NAMESPACE_ID::uint32 gasdevicecomsdown() const;
  void set_gasdevicecomsdown(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 gasDeviceCMD = 12;
  bool has_gasdevicecmd() const;
  void clear_gasdevicecmd();
  static const int kGasDeviceCMDFieldNumber = 12;
  ::PROTOBUF_NAMESPACE_ID::uint32 gasdevicecmd() const;
  void set_gasdevicecmd(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 gasDeviceSilentMode = 13;
  bool has_gasdevicesilentmode() const;
  void clear_gasdevicesilentmode();
  static const int kGasDeviceSilentModeFieldNumber = 13;
  ::PROTOBUF_NAMESPACE_ID::uint32 gasdevicesilentmode() const;
  void set_gasdevicesilentmode(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:Baymax)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 gasdevclass_;
  ::PROTOBUF_NAMESPACE_ID::uint32 gasdensity_;
  ::PROTOBUF_NAMESPACE_ID::uint32 gasdensityl1_;
  ::PROTOBUF_NAMESPACE_ID::uint32 gasdensityl2_;
  ::PROTOBUF_NAMESPACE_ID::uint32 gasdensityl3_;
  ::PROTOBUF_NAMESPACE_ID::uint32 gasdisassembly_;
  ::PROTOBUF_NAMESPACE_ID::uint32 gaslosepwr_;
  ::PROTOBUF_NAMESPACE_ID::uint32 gasemvalve_;
  ::PROTOBUF_NAMESPACE_ID::uint32 gasdevicestatus_;
  ::PROTOBUF_NAMESPACE_ID::uint32 gasdeviceopstate_;
  ::PROTOBUF_NAMESPACE_ID::uint32 gasdevicecomsdown_;
  ::PROTOBUF_NAMESPACE_ID::uint32 gasdevicecmd_;
  ::PROTOBUF_NAMESPACE_ID::uint32 gasdevicesilentmode_;
  friend struct ::TableStruct_MsgNode_5f1v1_5fm22_2eproto;
};
// -------------------------------------------------------------------

class MsgNode :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MsgNode) */ {
 public:
  MsgNode();
  virtual ~MsgNode();

  MsgNode(const MsgNode& from);
  MsgNode(MsgNode&& from) noexcept
    : MsgNode() {
    *this = ::std::move(from);
  }

  inline MsgNode& operator=(const MsgNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgNode& operator=(MsgNode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MsgNode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MsgNode* internal_default_instance() {
    return reinterpret_cast<const MsgNode*>(
               &_MsgNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(MsgNode* other);
  friend void swap(MsgNode& a, MsgNode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgNode* New() const final {
    return CreateMaybeMessage<MsgNode>(nullptr);
  }

  MsgNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MsgNode>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MsgNode& from);
  void MergeFrom(const MsgNode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgNode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MsgNode";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_MsgNode_5f1v1_5fm22_2eproto);
    return ::descriptor_table_MsgNode_5f1v1_5fm22_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SensorData sensors = 39;
  int sensors_size() const;
  void clear_sensors();
  static const int kSensorsFieldNumber = 39;
  ::SensorData* mutable_sensors(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorData >*
      mutable_sensors();
  const ::SensorData& sensors(int index) const;
  ::SensorData* add_sensors();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorData >&
      sensors() const;

  // repeated .MantunData mtunData = 43;
  int mtundata_size() const;
  void clear_mtundata();
  static const int kMtunDataFieldNumber = 43;
  ::MantunData* mutable_mtundata(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MantunData >*
      mutable_mtundata();
  const ::MantunData& mtundata(int index) const;
  ::MantunData* add_mtundata();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MantunData >&
      mtundata() const;

  // optional .LpwanParam lpwanParam = 4;
  bool has_lpwanparam() const;
  void clear_lpwanparam();
  static const int kLpwanParamFieldNumber = 4;
  const ::LpwanParam& lpwanparam() const;
  ::LpwanParam* release_lpwanparam();
  ::LpwanParam* mutable_lpwanparam();
  void set_allocated_lpwanparam(::LpwanParam* lpwanparam);

  // optional .BleParam bleParam = 5;
  bool has_bleparam() const;
  void clear_bleparam();
  static const int kBleParamFieldNumber = 5;
  const ::BleParam& bleparam() const;
  ::BleParam* release_bleparam();
  ::BleParam* mutable_bleparam();
  void set_allocated_bleparam(::BleParam* bleparam);

  // optional .AppParam appParam = 6;
  bool has_appparam() const;
  void clear_appparam();
  static const int kAppParamFieldNumber = 6;
  const ::AppParam& appparam() const;
  ::AppParam* release_appparam();
  ::AppParam* mutable_appparam();
  void set_allocated_appparam(::AppParam* appparam);

  // optional .GpsData gps = 8;
  bool has_gps() const;
  void clear_gps();
  static const int kGpsFieldNumber = 8;
  const ::GpsData& gps() const;
  ::GpsData* release_gps();
  ::GpsData* mutable_gps();
  void set_allocated_gps(::GpsData* gps);

  // optional .AxisData acceleration = 9;
  bool has_acceleration() const;
  void clear_acceleration();
  static const int kAccelerationFieldNumber = 9;
  const ::AxisData& acceleration() const;
  ::AxisData* release_acceleration();
  ::AxisData* mutable_acceleration();
  void set_allocated_acceleration(::AxisData* acceleration);

  // optional .AxisData magnetism = 10;
  bool has_magnetism() const;
  void clear_magnetism();
  static const int kMagnetismFieldNumber = 10;
  const ::AxisData& magnetism() const;
  ::AxisData* release_magnetism();
  ::AxisData* mutable_magnetism();
  void set_allocated_magnetism(::AxisData* magnetism);

  // optional .AxisData gyroscope = 11;
  bool has_gyroscope() const;
  void clear_gyroscope();
  static const int kGyroscopeFieldNumber = 11;
  const ::AxisData& gyroscope() const;
  ::AxisData* release_gyroscope();
  ::AxisData* mutable_gyroscope();
  void set_allocated_gyroscope(::AxisData* gyroscope);

  // optional .SensorData temperature = 12;
  bool has_temperature() const;
  void clear_temperature();
  static const int kTemperatureFieldNumber = 12;
  const ::SensorData& temperature() const;
  ::SensorData* release_temperature();
  ::SensorData* mutable_temperature();
  void set_allocated_temperature(::SensorData* temperature);

  // optional .SensorData humidity = 13;
  bool has_humidity() const;
  void clear_humidity();
  static const int kHumidityFieldNumber = 13;
  const ::SensorData& humidity() const;
  ::SensorData* release_humidity();
  ::SensorData* mutable_humidity();
  void set_allocated_humidity(::SensorData* humidity);

  // optional .SensorData light = 14;
  bool has_light() const;
  void clear_light();
  static const int kLightFieldNumber = 14;
  const ::SensorData& light() const;
  ::SensorData* release_light();
  ::SensorData* mutable_light();
  void set_allocated_light(::SensorData* light);

  // optional .SensorData leak = 15;
  bool has_leak() const;
  void clear_leak();
  static const int kLeakFieldNumber = 15;
  const ::SensorData& leak() const;
  ::SensorData* release_leak();
  ::SensorData* mutable_leak();
  void set_allocated_leak(::SensorData* leak);

  // optional .SensorData co = 16;
  bool has_co() const;
  void clear_co();
  static const int kCoFieldNumber = 16;
  const ::SensorData& co() const;
  ::SensorData* release_co();
  ::SensorData* mutable_co();
  void set_allocated_co(::SensorData* co);

  // optional .SensorData co2 = 17;
  bool has_co2() const;
  void clear_co2();
  static const int kCo2FieldNumber = 17;
  const ::SensorData& co2() const;
  ::SensorData* release_co2();
  ::SensorData* mutable_co2();
  void set_allocated_co2(::SensorData* co2);

  // optional .SensorData so2 = 18;
  bool has_so2() const;
  void clear_so2();
  static const int kSo2FieldNumber = 18;
  const ::SensorData& so2() const;
  ::SensorData* release_so2();
  ::SensorData* mutable_so2();
  void set_allocated_so2(::SensorData* so2);

  // optional .SensorData no2 = 19;
  bool has_no2() const;
  void clear_no2();
  static const int kNo2FieldNumber = 19;
  const ::SensorData& no2() const;
  ::SensorData* release_no2();
  ::SensorData* mutable_no2();
  void set_allocated_no2(::SensorData* no2);

  // optional .SensorData ch4 = 20;
  bool has_ch4() const;
  void clear_ch4();
  static const int kCh4FieldNumber = 20;
  const ::SensorData& ch4() const;
  ::SensorData* release_ch4();
  ::SensorData* mutable_ch4();
  void set_allocated_ch4(::SensorData* ch4);

  // optional .SensorData ch2o = 21;
  bool has_ch2o() const;
  void clear_ch2o();
  static const int kCh2OFieldNumber = 21;
  const ::SensorData& ch2o() const;
  ::SensorData* release_ch2o();
  ::SensorData* mutable_ch2o();
  void set_allocated_ch2o(::SensorData* ch2o);

  // optional .SensorData lpg = 22;
  bool has_lpg() const;
  void clear_lpg();
  static const int kLpgFieldNumber = 22;
  const ::SensorData& lpg() const;
  ::SensorData* release_lpg();
  ::SensorData* mutable_lpg();
  void set_allocated_lpg(::SensorData* lpg);

  // optional .SensorData o3 = 23;
  bool has_o3() const;
  void clear_o3();
  static const int kO3FieldNumber = 23;
  const ::SensorData& o3() const;
  ::SensorData* release_o3();
  ::SensorData* mutable_o3();
  void set_allocated_o3(::SensorData* o3);

  // optional .SensorData pm1 = 24;
  bool has_pm1() const;
  void clear_pm1();
  static const int kPm1FieldNumber = 24;
  const ::SensorData& pm1() const;
  ::SensorData* release_pm1();
  ::SensorData* mutable_pm1();
  void set_allocated_pm1(::SensorData* pm1);

  // optional .SensorData pm2_5 = 25;
  bool has_pm2_5() const;
  void clear_pm2_5();
  static const int kPm25FieldNumber = 25;
  const ::SensorData& pm2_5() const;
  ::SensorData* release_pm2_5();
  ::SensorData* mutable_pm2_5();
  void set_allocated_pm2_5(::SensorData* pm2_5);

  // optional .SensorData pm10 = 26;
  bool has_pm10() const;
  void clear_pm10();
  static const int kPm10FieldNumber = 26;
  const ::SensorData& pm10() const;
  ::SensorData* release_pm10();
  ::SensorData* mutable_pm10();
  void set_allocated_pm10(::SensorData* pm10);

  // optional .SensorData angle = 27;
  bool has_angle() const;
  void clear_angle();
  static const int kAngleFieldNumber = 27;
  const ::SensorData& angle() const;
  ::SensorData* release_angle();
  ::SensorData* mutable_angle();
  void set_allocated_angle(::SensorData* angle);

  // optional .SensorData cover = 28;
  bool has_cover() const;
  void clear_cover();
  static const int kCoverFieldNumber = 28;
  const ::SensorData& cover() const;
  ::SensorData* release_cover();
  ::SensorData* mutable_cover();
  void set_allocated_cover(::SensorData* cover);

  // optional .SensorData level = 29;
  bool has_level() const;
  void clear_level();
  static const int kLevelFieldNumber = 29;
  const ::SensorData& level() const;
  ::SensorData* release_level();
  ::SensorData* mutable_level();
  void set_allocated_level(::SensorData* level);

  // optional .SensorData smoke = 30;
  bool has_smoke() const;
  void clear_smoke();
  static const int kSmokeFieldNumber = 30;
  const ::SensorData& smoke() const;
  ::SensorData* release_smoke();
  ::SensorData* mutable_smoke();
  void set_allocated_smoke(::SensorData* smoke);

  // optional .SensorData pitch = 31;
  bool has_pitch() const;
  void clear_pitch();
  static const int kPitchFieldNumber = 31;
  const ::SensorData& pitch() const;
  ::SensorData* release_pitch();
  ::SensorData* mutable_pitch();
  void set_allocated_pitch(::SensorData* pitch);

  // optional .SensorData roll = 32;
  bool has_roll() const;
  void clear_roll();
  static const int kRollFieldNumber = 32;
  const ::SensorData& roll() const;
  ::SensorData* release_roll();
  ::SensorData* mutable_roll();
  void set_allocated_roll(::SensorData* roll);

  // optional .SensorData yaw = 33;
  bool has_yaw() const;
  void clear_yaw();
  static const int kYawFieldNumber = 33;
  const ::SensorData& yaw() const;
  ::SensorData* release_yaw();
  ::SensorData* mutable_yaw();
  void set_allocated_yaw(::SensorData* yaw);

  // optional .SensorDataInt flame = 34;
  bool has_flame() const;
  void clear_flame();
  static const int kFlameFieldNumber = 34;
  const ::SensorDataInt& flame() const;
  ::SensorDataInt* release_flame();
  ::SensorDataInt* mutable_flame();
  void set_allocated_flame(::SensorDataInt* flame);

  // optional .SensorData artificialGas = 35;
  bool has_artificialgas() const;
  void clear_artificialgas();
  static const int kArtificialGasFieldNumber = 35;
  const ::SensorData& artificialgas() const;
  ::SensorData* release_artificialgas();
  ::SensorData* mutable_artificialgas();
  void set_allocated_artificialgas(::SensorData* artificialgas);

  // optional .MultiSensorDataInt multiTemp = 36;
  bool has_multitemp() const;
  void clear_multitemp();
  static const int kMultiTempFieldNumber = 36;
  const ::MultiSensorDataInt& multitemp() const;
  ::MultiSensorDataInt* release_multitemp();
  ::MultiSensorDataInt* mutable_multitemp();
  void set_allocated_multitemp(::MultiSensorDataInt* multitemp);

  // optional .SensorData waterPressure = 37;
  bool has_waterpressure() const;
  void clear_waterpressure();
  static const int kWaterPressureFieldNumber = 37;
  const ::SensorData& waterpressure() const;
  ::SensorData* release_waterpressure();
  ::SensorData* mutable_waterpressure();
  void set_allocated_waterpressure(::SensorData* waterpressure);

  // optional .iBeacon ibeacon = 38;
  bool has_ibeacon() const;
  void clear_ibeacon();
  static const int kIbeaconFieldNumber = 38;
  const ::iBeacon& ibeacon() const;
  ::iBeacon* release_ibeacon();
  ::iBeacon* mutable_ibeacon();
  void set_allocated_ibeacon(::iBeacon* ibeacon);

  // optional .ExtSmoke extSmoke = 41;
  bool has_extsmoke() const;
  void clear_extsmoke();
  static const int kExtSmokeFieldNumber = 41;
  const ::ExtSmoke& extsmoke() const;
  ::ExtSmoke* release_extsmoke();
  ::ExtSmoke* mutable_extsmoke();
  void set_allocated_extsmoke(::ExtSmoke* extsmoke);

  // optional .ElecFireData fireData = 42;
  bool has_firedata() const;
  void clear_firedata();
  static const int kFireDataFieldNumber = 42;
  const ::ElecFireData& firedata() const;
  ::ElecFireData* release_firedata();
  ::ElecFireData* mutable_firedata();
  void set_allocated_firedata(::ElecFireData* firedata);

  // optional .AcrelData acrelData = 44;
  bool has_acreldata() const;
  void clear_acreldata();
  static const int kAcrelDataFieldNumber = 44;
  const ::AcrelData& acreldata() const;
  ::AcrelData* release_acreldata();
  ::AcrelData* mutable_acreldata();
  void set_allocated_acreldata(::AcrelData* acreldata);

  // optional .Cayman caymanData = 45;
  bool has_caymandata() const;
  void clear_caymandata();
  static const int kCaymanDataFieldNumber = 45;
  const ::Cayman& caymandata() const;
  ::Cayman* release_caymandata();
  ::Cayman* mutable_caymandata();
  void set_allocated_caymandata(::Cayman* caymandata);

  // optional .Baymax baymaxData = 46;
  bool has_baymaxdata() const;
  void clear_baymaxdata();
  static const int kBaymaxDataFieldNumber = 46;
  const ::Baymax& baymaxdata() const;
  ::Baymax* release_baymaxdata();
  ::Baymax* mutable_baymaxdata();
  void set_allocated_baymaxdata(::Baymax* baymaxdata);

  // optional uint32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 cmd = 2;
  bool has_cmd() const;
  void clear_cmd();
  static const int kCmdFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::uint32 cmd() const;
  void set_cmd(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 cmdRet = 3;
  bool has_cmdret() const;
  void clear_cmdret();
  static const int kCmdRetFieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::uint32 cmdret() const;
  void set_cmdret(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional sint32 battery = 7;
  bool has_battery() const;
  void clear_battery();
  static const int kBatteryFieldNumber = 7;
  ::PROTOBUF_NAMESPACE_ID::int32 battery() const;
  void set_battery(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional bool installed = 40;
  bool has_installed() const;
  void clear_installed();
  static const int kInstalledFieldNumber = 40;
  bool installed() const;
  void set_installed(bool value);

  // @@protoc_insertion_point(class_scope:MsgNode)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<2> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorData > sensors_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MantunData > mtundata_;
  ::LpwanParam* lpwanparam_;
  ::BleParam* bleparam_;
  ::AppParam* appparam_;
  ::GpsData* gps_;
  ::AxisData* acceleration_;
  ::AxisData* magnetism_;
  ::AxisData* gyroscope_;
  ::SensorData* temperature_;
  ::SensorData* humidity_;
  ::SensorData* light_;
  ::SensorData* leak_;
  ::SensorData* co_;
  ::SensorData* co2_;
  ::SensorData* so2_;
  ::SensorData* no2_;
  ::SensorData* ch4_;
  ::SensorData* ch2o_;
  ::SensorData* lpg_;
  ::SensorData* o3_;
  ::SensorData* pm1_;
  ::SensorData* pm2_5_;
  ::SensorData* pm10_;
  ::SensorData* angle_;
  ::SensorData* cover_;
  ::SensorData* level_;
  ::SensorData* smoke_;
  ::SensorData* pitch_;
  ::SensorData* roll_;
  ::SensorData* yaw_;
  ::SensorDataInt* flame_;
  ::SensorData* artificialgas_;
  ::MultiSensorDataInt* multitemp_;
  ::SensorData* waterpressure_;
  ::iBeacon* ibeacon_;
  ::ExtSmoke* extsmoke_;
  ::ElecFireData* firedata_;
  ::AcrelData* acreldata_;
  ::Cayman* caymandata_;
  ::Baymax* baymaxdata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 cmd_;
  ::PROTOBUF_NAMESPACE_ID::uint32 cmdret_;
  ::PROTOBUF_NAMESPACE_ID::int32 battery_;
  bool installed_;
  friend struct ::TableStruct_MsgNode_5f1v1_5fm22_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Channel

// required uint32 frequency = 1;
inline bool Channel::has_frequency() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Channel::clear_frequency() {
  frequency_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Channel::frequency() const {
  // @@protoc_insertion_point(field_get:Channel.frequency)
  return frequency_;
}
inline void Channel::set_frequency(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  frequency_ = value;
  // @@protoc_insertion_point(field_set:Channel.frequency)
}

// optional uint32 rx1Frequency = 2;
inline bool Channel::has_rx1frequency() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Channel::clear_rx1frequency() {
  rx1frequency_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Channel::rx1frequency() const {
  // @@protoc_insertion_point(field_get:Channel.rx1Frequency)
  return rx1frequency_;
}
inline void Channel::set_rx1frequency(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  rx1frequency_ = value;
  // @@protoc_insertion_point(field_set:Channel.rx1Frequency)
}

// -------------------------------------------------------------------

// LpwanParam

// optional bytes devEui = 1;
inline bool LpwanParam::has_deveui() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LpwanParam::clear_deveui() {
  deveui_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LpwanParam::deveui() const {
  // @@protoc_insertion_point(field_get:LpwanParam.devEui)
  return deveui_.GetNoArena();
}
inline void LpwanParam::set_deveui(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  deveui_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:LpwanParam.devEui)
}
inline void LpwanParam::set_deveui(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  deveui_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:LpwanParam.devEui)
}
inline void LpwanParam::set_deveui(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  deveui_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:LpwanParam.devEui)
}
inline void LpwanParam::set_deveui(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  deveui_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:LpwanParam.devEui)
}
inline std::string* LpwanParam::mutable_deveui() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:LpwanParam.devEui)
  return deveui_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LpwanParam::release_deveui() {
  // @@protoc_insertion_point(field_release:LpwanParam.devEui)
  if (!has_deveui()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return deveui_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LpwanParam::set_allocated_deveui(std::string* deveui) {
  if (deveui != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  deveui_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), deveui);
  // @@protoc_insertion_point(field_set_allocated:LpwanParam.devEui)
}

// optional bytes appEui = 2;
inline bool LpwanParam::has_appeui() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LpwanParam::clear_appeui() {
  appeui_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LpwanParam::appeui() const {
  // @@protoc_insertion_point(field_get:LpwanParam.appEui)
  return appeui_.GetNoArena();
}
inline void LpwanParam::set_appeui(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  appeui_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:LpwanParam.appEui)
}
inline void LpwanParam::set_appeui(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  appeui_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:LpwanParam.appEui)
}
inline void LpwanParam::set_appeui(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  appeui_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:LpwanParam.appEui)
}
inline void LpwanParam::set_appeui(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  appeui_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:LpwanParam.appEui)
}
inline std::string* LpwanParam::mutable_appeui() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:LpwanParam.appEui)
  return appeui_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LpwanParam::release_appeui() {
  // @@protoc_insertion_point(field_release:LpwanParam.appEui)
  if (!has_appeui()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return appeui_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LpwanParam::set_allocated_appeui(std::string* appeui) {
  if (appeui != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  appeui_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), appeui);
  // @@protoc_insertion_point(field_set_allocated:LpwanParam.appEui)
}

// optional bytes appKey = 3;
inline bool LpwanParam::has_appkey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LpwanParam::clear_appkey() {
  appkey_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& LpwanParam::appkey() const {
  // @@protoc_insertion_point(field_get:LpwanParam.appKey)
  return appkey_.GetNoArena();
}
inline void LpwanParam::set_appkey(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  appkey_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:LpwanParam.appKey)
}
inline void LpwanParam::set_appkey(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  appkey_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:LpwanParam.appKey)
}
inline void LpwanParam::set_appkey(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  appkey_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:LpwanParam.appKey)
}
inline void LpwanParam::set_appkey(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  appkey_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:LpwanParam.appKey)
}
inline std::string* LpwanParam::mutable_appkey() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:LpwanParam.appKey)
  return appkey_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LpwanParam::release_appkey() {
  // @@protoc_insertion_point(field_release:LpwanParam.appKey)
  if (!has_appkey()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return appkey_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LpwanParam::set_allocated_appkey(std::string* appkey) {
  if (appkey != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  appkey_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), appkey);
  // @@protoc_insertion_point(field_set_allocated:LpwanParam.appKey)
}

// optional bytes appSkey = 4;
inline bool LpwanParam::has_appskey() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LpwanParam::clear_appskey() {
  appskey_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& LpwanParam::appskey() const {
  // @@protoc_insertion_point(field_get:LpwanParam.appSkey)
  return appskey_.GetNoArena();
}
inline void LpwanParam::set_appskey(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  appskey_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:LpwanParam.appSkey)
}
inline void LpwanParam::set_appskey(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  appskey_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:LpwanParam.appSkey)
}
inline void LpwanParam::set_appskey(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  appskey_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:LpwanParam.appSkey)
}
inline void LpwanParam::set_appskey(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  appskey_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:LpwanParam.appSkey)
}
inline std::string* LpwanParam::mutable_appskey() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:LpwanParam.appSkey)
  return appskey_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LpwanParam::release_appskey() {
  // @@protoc_insertion_point(field_release:LpwanParam.appSkey)
  if (!has_appskey()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return appskey_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LpwanParam::set_allocated_appskey(std::string* appskey) {
  if (appskey != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  appskey_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), appskey);
  // @@protoc_insertion_point(field_set_allocated:LpwanParam.appSkey)
}

// optional bytes nwkSkey = 5;
inline bool LpwanParam::has_nwkskey() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LpwanParam::clear_nwkskey() {
  nwkskey_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& LpwanParam::nwkskey() const {
  // @@protoc_insertion_point(field_get:LpwanParam.nwkSkey)
  return nwkskey_.GetNoArena();
}
inline void LpwanParam::set_nwkskey(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  nwkskey_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:LpwanParam.nwkSkey)
}
inline void LpwanParam::set_nwkskey(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  nwkskey_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:LpwanParam.nwkSkey)
}
inline void LpwanParam::set_nwkskey(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  nwkskey_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:LpwanParam.nwkSkey)
}
inline void LpwanParam::set_nwkskey(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000010u;
  nwkskey_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:LpwanParam.nwkSkey)
}
inline std::string* LpwanParam::mutable_nwkskey() {
  _has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_mutable:LpwanParam.nwkSkey)
  return nwkskey_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LpwanParam::release_nwkskey() {
  // @@protoc_insertion_point(field_release:LpwanParam.nwkSkey)
  if (!has_nwkskey()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return nwkskey_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LpwanParam::set_allocated_nwkskey(std::string* nwkskey) {
  if (nwkskey != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  nwkskey_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nwkskey);
  // @@protoc_insertion_point(field_set_allocated:LpwanParam.nwkSkey)
}

// optional uint32 devAddr = 6;
inline bool LpwanParam::has_devaddr() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LpwanParam::clear_devaddr() {
  devaddr_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LpwanParam::devaddr() const {
  // @@protoc_insertion_point(field_get:LpwanParam.devAddr)
  return devaddr_;
}
inline void LpwanParam::set_devaddr(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  devaddr_ = value;
  // @@protoc_insertion_point(field_set:LpwanParam.devAddr)
}

// optional uint32 datarate = 7;
inline bool LpwanParam::has_datarate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LpwanParam::clear_datarate() {
  datarate_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LpwanParam::datarate() const {
  // @@protoc_insertion_point(field_get:LpwanParam.datarate)
  return datarate_;
}
inline void LpwanParam::set_datarate(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  datarate_ = value;
  // @@protoc_insertion_point(field_set:LpwanParam.datarate)
}

// optional sint32 txPower = 8;
inline bool LpwanParam::has_txpower() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LpwanParam::clear_txpower() {
  txpower_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LpwanParam::txpower() const {
  // @@protoc_insertion_point(field_get:LpwanParam.txPower)
  return txpower_;
}
inline void LpwanParam::set_txpower(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000080u;
  txpower_ = value;
  // @@protoc_insertion_point(field_set:LpwanParam.txPower)
}

// optional uint32 adr = 9;
inline bool LpwanParam::has_adr() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LpwanParam::clear_adr() {
  adr_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LpwanParam::adr() const {
  // @@protoc_insertion_point(field_get:LpwanParam.adr)
  return adr_;
}
inline void LpwanParam::set_adr(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000100u;
  adr_ = value;
  // @@protoc_insertion_point(field_set:LpwanParam.adr)
}

// optional .Activtion activition = 10;
inline bool LpwanParam::has_activition() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LpwanParam::clear_activition() {
  activition_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::Activtion LpwanParam::activition() const {
  // @@protoc_insertion_point(field_get:LpwanParam.activition)
  return static_cast< ::Activtion >(activition_);
}
inline void LpwanParam::set_activition(::Activtion value) {
  assert(::Activtion_IsValid(value));
  _has_bits_[0] |= 0x00000200u;
  activition_ = value;
  // @@protoc_insertion_point(field_set:LpwanParam.activition)
}

// optional .ClassType classType = 11;
inline bool LpwanParam::has_classtype() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void LpwanParam::clear_classtype() {
  classtype_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::ClassType LpwanParam::classtype() const {
  // @@protoc_insertion_point(field_get:LpwanParam.classType)
  return static_cast< ::ClassType >(classtype_);
}
inline void LpwanParam::set_classtype(::ClassType value) {
  assert(::ClassType_IsValid(value));
  _has_bits_[0] |= 0x00000400u;
  classtype_ = value;
  // @@protoc_insertion_point(field_set:LpwanParam.classType)
}

// optional uint32 delay = 12;
inline bool LpwanParam::has_delay() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void LpwanParam::clear_delay() {
  delay_ = 0u;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LpwanParam::delay() const {
  // @@protoc_insertion_point(field_get:LpwanParam.delay)
  return delay_;
}
inline void LpwanParam::set_delay(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000800u;
  delay_ = value;
  // @@protoc_insertion_point(field_set:LpwanParam.delay)
}

// repeated uint32 channelMask = 13;
inline int LpwanParam::channelmask_size() const {
  return channelmask_.size();
}
inline void LpwanParam::clear_channelmask() {
  channelmask_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LpwanParam::channelmask(int index) const {
  // @@protoc_insertion_point(field_get:LpwanParam.channelMask)
  return channelmask_.Get(index);
}
inline void LpwanParam::set_channelmask(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  channelmask_.Set(index, value);
  // @@protoc_insertion_point(field_set:LpwanParam.channelMask)
}
inline void LpwanParam::add_channelmask(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  channelmask_.Add(value);
  // @@protoc_insertion_point(field_add:LpwanParam.channelMask)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
LpwanParam::channelmask() const {
  // @@protoc_insertion_point(field_list:LpwanParam.channelMask)
  return channelmask_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
LpwanParam::mutable_channelmask() {
  // @@protoc_insertion_point(field_mutable_list:LpwanParam.channelMask)
  return &channelmask_;
}

// optional uint32 maxEIRP = 14;
inline bool LpwanParam::has_maxeirp() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void LpwanParam::clear_maxeirp() {
  maxeirp_ = 0u;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LpwanParam::maxeirp() const {
  // @@protoc_insertion_point(field_get:LpwanParam.maxEIRP)
  return maxeirp_;
}
inline void LpwanParam::set_maxeirp(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00001000u;
  maxeirp_ = value;
  // @@protoc_insertion_point(field_set:LpwanParam.maxEIRP)
}

// optional uint32 sglStatus = 15;
inline bool LpwanParam::has_sglstatus() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void LpwanParam::clear_sglstatus() {
  sglstatus_ = 0u;
  _has_bits_[0] &= ~0x00002000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LpwanParam::sglstatus() const {
  // @@protoc_insertion_point(field_get:LpwanParam.sglStatus)
  return sglstatus_;
}
inline void LpwanParam::set_sglstatus(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00002000u;
  sglstatus_ = value;
  // @@protoc_insertion_point(field_set:LpwanParam.sglStatus)
}

// optional uint32 sglFrequency = 16;
inline bool LpwanParam::has_sglfrequency() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void LpwanParam::clear_sglfrequency() {
  sglfrequency_ = 0u;
  _has_bits_[0] &= ~0x00004000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LpwanParam::sglfrequency() const {
  // @@protoc_insertion_point(field_get:LpwanParam.sglFrequency)
  return sglfrequency_;
}
inline void LpwanParam::set_sglfrequency(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00004000u;
  sglfrequency_ = value;
  // @@protoc_insertion_point(field_set:LpwanParam.sglFrequency)
}

// optional uint32 sglDatarate = 17;
inline bool LpwanParam::has_sgldatarate() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void LpwanParam::clear_sgldatarate() {
  sgldatarate_ = 0u;
  _has_bits_[0] &= ~0x00008000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LpwanParam::sgldatarate() const {
  // @@protoc_insertion_point(field_get:LpwanParam.sglDatarate)
  return sgldatarate_;
}
inline void LpwanParam::set_sgldatarate(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00008000u;
  sgldatarate_ = value;
  // @@protoc_insertion_point(field_set:LpwanParam.sglDatarate)
}

// optional uint32 lbtStatus = 18;
inline bool LpwanParam::has_lbtstatus() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void LpwanParam::clear_lbtstatus() {
  lbtstatus_ = 0u;
  _has_bits_[0] &= ~0x00010000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LpwanParam::lbtstatus() const {
  // @@protoc_insertion_point(field_get:LpwanParam.lbtStatus)
  return lbtstatus_;
}
inline void LpwanParam::set_lbtstatus(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00010000u;
  lbtstatus_ = value;
  // @@protoc_insertion_point(field_set:LpwanParam.lbtStatus)
}

// optional sint32 lbtThreshold = 19;
inline bool LpwanParam::has_lbtthreshold() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void LpwanParam::clear_lbtthreshold() {
  lbtthreshold_ = 0;
  _has_bits_[0] &= ~0x00020000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LpwanParam::lbtthreshold() const {
  // @@protoc_insertion_point(field_get:LpwanParam.lbtThreshold)
  return lbtthreshold_;
}
inline void LpwanParam::set_lbtthreshold(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00020000u;
  lbtthreshold_ = value;
  // @@protoc_insertion_point(field_set:LpwanParam.lbtThreshold)
}

// repeated .Channel channels = 20;
inline int LpwanParam::channels_size() const {
  return channels_.size();
}
inline void LpwanParam::clear_channels() {
  channels_.Clear();
}
inline ::Channel* LpwanParam::mutable_channels(int index) {
  // @@protoc_insertion_point(field_mutable:LpwanParam.channels)
  return channels_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Channel >*
LpwanParam::mutable_channels() {
  // @@protoc_insertion_point(field_mutable_list:LpwanParam.channels)
  return &channels_;
}
inline const ::Channel& LpwanParam::channels(int index) const {
  // @@protoc_insertion_point(field_get:LpwanParam.channels)
  return channels_.Get(index);
}
inline ::Channel* LpwanParam::add_channels() {
  // @@protoc_insertion_point(field_add:LpwanParam.channels)
  return channels_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Channel >&
LpwanParam::channels() const {
  // @@protoc_insertion_point(field_list:LpwanParam.channels)
  return channels_;
}

// -------------------------------------------------------------------

// BleParam

// optional float bleInterval = 1;
inline bool BleParam::has_bleinterval() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BleParam::clear_bleinterval() {
  bleinterval_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float BleParam::bleinterval() const {
  // @@protoc_insertion_point(field_get:BleParam.bleInterval)
  return bleinterval_;
}
inline void BleParam::set_bleinterval(float value) {
  _has_bits_[0] |= 0x00000001u;
  bleinterval_ = value;
  // @@protoc_insertion_point(field_set:BleParam.bleInterval)
}

// optional sint32 bleTxp = 2;
inline bool BleParam::has_bletxp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BleParam::clear_bletxp() {
  bletxp_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BleParam::bletxp() const {
  // @@protoc_insertion_point(field_get:BleParam.bleTxp)
  return bletxp_;
}
inline void BleParam::set_bletxp(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  bletxp_ = value;
  // @@protoc_insertion_point(field_set:BleParam.bleTxp)
}

// optional uint32 bleOnTime = 3;
inline bool BleParam::has_bleontime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BleParam::clear_bleontime() {
  bleontime_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 BleParam::bleontime() const {
  // @@protoc_insertion_point(field_get:BleParam.bleOnTime)
  return bleontime_;
}
inline void BleParam::set_bleontime(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  bleontime_ = value;
  // @@protoc_insertion_point(field_set:BleParam.bleOnTime)
}

// optional uint32 bleOffTime = 4;
inline bool BleParam::has_bleofftime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BleParam::clear_bleofftime() {
  bleofftime_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 BleParam::bleofftime() const {
  // @@protoc_insertion_point(field_get:BleParam.bleOffTime)
  return bleofftime_;
}
inline void BleParam::set_bleofftime(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  bleofftime_ = value;
  // @@protoc_insertion_point(field_set:BleParam.bleOffTime)
}

// optional uint32 bleOnOff = 5;
inline bool BleParam::has_bleonoff() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BleParam::clear_bleonoff() {
  bleonoff_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 BleParam::bleonoff() const {
  // @@protoc_insertion_point(field_get:BleParam.bleOnOff)
  return bleonoff_;
}
inline void BleParam::set_bleonoff(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  bleonoff_ = value;
  // @@protoc_insertion_point(field_set:BleParam.bleOnOff)
}

// -------------------------------------------------------------------

// SensorData

// optional .SensorType type = 9;
inline bool SensorData::has_type() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SensorData::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::SensorType SensorData::type() const {
  // @@protoc_insertion_point(field_get:SensorData.type)
  return static_cast< ::SensorType >(type_);
}
inline void SensorData::set_type(::SensorType value) {
  assert(::SensorType_IsValid(value));
  _has_bits_[0] |= 0x00000100u;
  type_ = value;
  // @@protoc_insertion_point(field_set:SensorData.type)
}

// optional float data = 1;
inline bool SensorData::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SensorData::clear_data() {
  data_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float SensorData::data() const {
  // @@protoc_insertion_point(field_get:SensorData.data)
  return data_;
}
inline void SensorData::set_data(float value) {
  _has_bits_[0] |= 0x00000001u;
  data_ = value;
  // @@protoc_insertion_point(field_set:SensorData.data)
}

// optional float alarmHigh = 2;
inline bool SensorData::has_alarmhigh() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SensorData::clear_alarmhigh() {
  alarmhigh_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float SensorData::alarmhigh() const {
  // @@protoc_insertion_point(field_get:SensorData.alarmHigh)
  return alarmhigh_;
}
inline void SensorData::set_alarmhigh(float value) {
  _has_bits_[0] |= 0x00000002u;
  alarmhigh_ = value;
  // @@protoc_insertion_point(field_set:SensorData.alarmHigh)
}

// optional float alarmLow = 3;
inline bool SensorData::has_alarmlow() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SensorData::clear_alarmlow() {
  alarmlow_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float SensorData::alarmlow() const {
  // @@protoc_insertion_point(field_get:SensorData.alarmLow)
  return alarmlow_;
}
inline void SensorData::set_alarmlow(float value) {
  _has_bits_[0] |= 0x00000004u;
  alarmlow_ = value;
  // @@protoc_insertion_point(field_set:SensorData.alarmLow)
}

// optional uint32 calibration = 4;
inline bool SensorData::has_calibration() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SensorData::clear_calibration() {
  calibration_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SensorData::calibration() const {
  // @@protoc_insertion_point(field_get:SensorData.calibration)
  return calibration_;
}
inline void SensorData::set_calibration(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  calibration_ = value;
  // @@protoc_insertion_point(field_set:SensorData.calibration)
}

// optional .SensorError error = 5;
inline bool SensorData::has_error() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SensorData::clear_error() {
  error_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::SensorError SensorData::error() const {
  // @@protoc_insertion_point(field_get:SensorData.error)
  return static_cast< ::SensorError >(error_);
}
inline void SensorData::set_error(::SensorError value) {
  assert(::SensorError_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  error_ = value;
  // @@protoc_insertion_point(field_set:SensorData.error)
}

// optional uint32 status = 6;
inline bool SensorData::has_status() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SensorData::clear_status() {
  status_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SensorData::status() const {
  // @@protoc_insertion_point(field_get:SensorData.status)
  return status_;
}
inline void SensorData::set_status(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  status_ = value;
  // @@protoc_insertion_point(field_set:SensorData.status)
}

// optional float alarmStepHigh = 7;
inline bool SensorData::has_alarmstephigh() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SensorData::clear_alarmstephigh() {
  alarmstephigh_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline float SensorData::alarmstephigh() const {
  // @@protoc_insertion_point(field_get:SensorData.alarmStepHigh)
  return alarmstephigh_;
}
inline void SensorData::set_alarmstephigh(float value) {
  _has_bits_[0] |= 0x00000040u;
  alarmstephigh_ = value;
  // @@protoc_insertion_point(field_set:SensorData.alarmStepHigh)
}

// optional float alarmStepLow = 8;
inline bool SensorData::has_alarmsteplow() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SensorData::clear_alarmsteplow() {
  alarmsteplow_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline float SensorData::alarmsteplow() const {
  // @@protoc_insertion_point(field_get:SensorData.alarmStepLow)
  return alarmsteplow_;
}
inline void SensorData::set_alarmsteplow(float value) {
  _has_bits_[0] |= 0x00000080u;
  alarmsteplow_ = value;
  // @@protoc_insertion_point(field_set:SensorData.alarmStepLow)
}

// -------------------------------------------------------------------

// SensorDataInt

// optional .SensorType type = 1;
inline bool SensorDataInt::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SensorDataInt::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::SensorType SensorDataInt::type() const {
  // @@protoc_insertion_point(field_get:SensorDataInt.type)
  return static_cast< ::SensorType >(type_);
}
inline void SensorDataInt::set_type(::SensorType value) {
  assert(::SensorType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  type_ = value;
  // @@protoc_insertion_point(field_set:SensorDataInt.type)
}

// optional sint32 data = 2;
inline bool SensorDataInt::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SensorDataInt::clear_data() {
  data_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorDataInt::data() const {
  // @@protoc_insertion_point(field_get:SensorDataInt.data)
  return data_;
}
inline void SensorDataInt::set_data(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  data_ = value;
  // @@protoc_insertion_point(field_set:SensorDataInt.data)
}

// optional sint32 alarmHigh = 3;
inline bool SensorDataInt::has_alarmhigh() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SensorDataInt::clear_alarmhigh() {
  alarmhigh_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorDataInt::alarmhigh() const {
  // @@protoc_insertion_point(field_get:SensorDataInt.alarmHigh)
  return alarmhigh_;
}
inline void SensorDataInt::set_alarmhigh(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  alarmhigh_ = value;
  // @@protoc_insertion_point(field_set:SensorDataInt.alarmHigh)
}

// optional sint32 alarmLow = 4;
inline bool SensorDataInt::has_alarmlow() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SensorDataInt::clear_alarmlow() {
  alarmlow_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorDataInt::alarmlow() const {
  // @@protoc_insertion_point(field_get:SensorDataInt.alarmLow)
  return alarmlow_;
}
inline void SensorDataInt::set_alarmlow(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  alarmlow_ = value;
  // @@protoc_insertion_point(field_set:SensorDataInt.alarmLow)
}

// optional sint32 calibration = 5;
inline bool SensorDataInt::has_calibration() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SensorDataInt::clear_calibration() {
  calibration_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorDataInt::calibration() const {
  // @@protoc_insertion_point(field_get:SensorDataInt.calibration)
  return calibration_;
}
inline void SensorDataInt::set_calibration(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  calibration_ = value;
  // @@protoc_insertion_point(field_set:SensorDataInt.calibration)
}

// optional .SensorError error = 6;
inline bool SensorDataInt::has_error() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SensorDataInt::clear_error() {
  error_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::SensorError SensorDataInt::error() const {
  // @@protoc_insertion_point(field_get:SensorDataInt.error)
  return static_cast< ::SensorError >(error_);
}
inline void SensorDataInt::set_error(::SensorError value) {
  assert(::SensorError_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  error_ = value;
  // @@protoc_insertion_point(field_set:SensorDataInt.error)
}

// optional uint32 status = 7;
inline bool SensorDataInt::has_status() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SensorDataInt::clear_status() {
  status_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SensorDataInt::status() const {
  // @@protoc_insertion_point(field_get:SensorDataInt.status)
  return status_;
}
inline void SensorDataInt::set_status(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  status_ = value;
  // @@protoc_insertion_point(field_set:SensorDataInt.status)
}

// optional sint32 alarmStepHigh = 8;
inline bool SensorDataInt::has_alarmstephigh() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SensorDataInt::clear_alarmstephigh() {
  alarmstephigh_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorDataInt::alarmstephigh() const {
  // @@protoc_insertion_point(field_get:SensorDataInt.alarmStepHigh)
  return alarmstephigh_;
}
inline void SensorDataInt::set_alarmstephigh(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000080u;
  alarmstephigh_ = value;
  // @@protoc_insertion_point(field_set:SensorDataInt.alarmStepHigh)
}

// optional sint32 alarmStepLow = 9;
inline bool SensorDataInt::has_alarmsteplow() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SensorDataInt::clear_alarmsteplow() {
  alarmsteplow_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorDataInt::alarmsteplow() const {
  // @@protoc_insertion_point(field_get:SensorDataInt.alarmStepLow)
  return alarmsteplow_;
}
inline void SensorDataInt::set_alarmsteplow(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000100u;
  alarmsteplow_ = value;
  // @@protoc_insertion_point(field_set:SensorDataInt.alarmStepLow)
}

// -------------------------------------------------------------------

// SensorDataFloat

// optional .SensorType type = 1;
inline bool SensorDataFloat::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SensorDataFloat::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::SensorType SensorDataFloat::type() const {
  // @@protoc_insertion_point(field_get:SensorDataFloat.type)
  return static_cast< ::SensorType >(type_);
}
inline void SensorDataFloat::set_type(::SensorType value) {
  assert(::SensorType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  type_ = value;
  // @@protoc_insertion_point(field_set:SensorDataFloat.type)
}

// optional float data = 2;
inline bool SensorDataFloat::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SensorDataFloat::clear_data() {
  data_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float SensorDataFloat::data() const {
  // @@protoc_insertion_point(field_get:SensorDataFloat.data)
  return data_;
}
inline void SensorDataFloat::set_data(float value) {
  _has_bits_[0] |= 0x00000002u;
  data_ = value;
  // @@protoc_insertion_point(field_set:SensorDataFloat.data)
}

// optional float alarmHigh = 3;
inline bool SensorDataFloat::has_alarmhigh() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SensorDataFloat::clear_alarmhigh() {
  alarmhigh_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float SensorDataFloat::alarmhigh() const {
  // @@protoc_insertion_point(field_get:SensorDataFloat.alarmHigh)
  return alarmhigh_;
}
inline void SensorDataFloat::set_alarmhigh(float value) {
  _has_bits_[0] |= 0x00000004u;
  alarmhigh_ = value;
  // @@protoc_insertion_point(field_set:SensorDataFloat.alarmHigh)
}

// optional float alarmLow = 4;
inline bool SensorDataFloat::has_alarmlow() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SensorDataFloat::clear_alarmlow() {
  alarmlow_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float SensorDataFloat::alarmlow() const {
  // @@protoc_insertion_point(field_get:SensorDataFloat.alarmLow)
  return alarmlow_;
}
inline void SensorDataFloat::set_alarmlow(float value) {
  _has_bits_[0] |= 0x00000008u;
  alarmlow_ = value;
  // @@protoc_insertion_point(field_set:SensorDataFloat.alarmLow)
}

// optional sint32 calibration = 5;
inline bool SensorDataFloat::has_calibration() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SensorDataFloat::clear_calibration() {
  calibration_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorDataFloat::calibration() const {
  // @@protoc_insertion_point(field_get:SensorDataFloat.calibration)
  return calibration_;
}
inline void SensorDataFloat::set_calibration(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  calibration_ = value;
  // @@protoc_insertion_point(field_set:SensorDataFloat.calibration)
}

// optional .SensorError error = 6;
inline bool SensorDataFloat::has_error() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SensorDataFloat::clear_error() {
  error_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::SensorError SensorDataFloat::error() const {
  // @@protoc_insertion_point(field_get:SensorDataFloat.error)
  return static_cast< ::SensorError >(error_);
}
inline void SensorDataFloat::set_error(::SensorError value) {
  assert(::SensorError_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  error_ = value;
  // @@protoc_insertion_point(field_set:SensorDataFloat.error)
}

// optional uint32 status = 7;
inline bool SensorDataFloat::has_status() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SensorDataFloat::clear_status() {
  status_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SensorDataFloat::status() const {
  // @@protoc_insertion_point(field_get:SensorDataFloat.status)
  return status_;
}
inline void SensorDataFloat::set_status(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  status_ = value;
  // @@protoc_insertion_point(field_set:SensorDataFloat.status)
}

// optional float alarmStepHigh = 8;
inline bool SensorDataFloat::has_alarmstephigh() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SensorDataFloat::clear_alarmstephigh() {
  alarmstephigh_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline float SensorDataFloat::alarmstephigh() const {
  // @@protoc_insertion_point(field_get:SensorDataFloat.alarmStepHigh)
  return alarmstephigh_;
}
inline void SensorDataFloat::set_alarmstephigh(float value) {
  _has_bits_[0] |= 0x00000080u;
  alarmstephigh_ = value;
  // @@protoc_insertion_point(field_set:SensorDataFloat.alarmStepHigh)
}

// optional float alarmStepLow = 9;
inline bool SensorDataFloat::has_alarmsteplow() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SensorDataFloat::clear_alarmsteplow() {
  alarmsteplow_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline float SensorDataFloat::alarmsteplow() const {
  // @@protoc_insertion_point(field_get:SensorDataFloat.alarmStepLow)
  return alarmsteplow_;
}
inline void SensorDataFloat::set_alarmsteplow(float value) {
  _has_bits_[0] |= 0x00000100u;
  alarmsteplow_ = value;
  // @@protoc_insertion_point(field_set:SensorDataFloat.alarmStepLow)
}

// -------------------------------------------------------------------

// MultiSensorData

// repeated float data = 1;
inline int MultiSensorData::data_size() const {
  return data_.size();
}
inline void MultiSensorData::clear_data() {
  data_.Clear();
}
inline float MultiSensorData::data(int index) const {
  // @@protoc_insertion_point(field_get:MultiSensorData.data)
  return data_.Get(index);
}
inline void MultiSensorData::set_data(int index, float value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:MultiSensorData.data)
}
inline void MultiSensorData::add_data(float value) {
  data_.Add(value);
  // @@protoc_insertion_point(field_add:MultiSensorData.data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
MultiSensorData::data() const {
  // @@protoc_insertion_point(field_list:MultiSensorData.data)
  return data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
MultiSensorData::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:MultiSensorData.data)
  return &data_;
}

// optional float alarmHigh = 2;
inline bool MultiSensorData::has_alarmhigh() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MultiSensorData::clear_alarmhigh() {
  alarmhigh_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float MultiSensorData::alarmhigh() const {
  // @@protoc_insertion_point(field_get:MultiSensorData.alarmHigh)
  return alarmhigh_;
}
inline void MultiSensorData::set_alarmhigh(float value) {
  _has_bits_[0] |= 0x00000001u;
  alarmhigh_ = value;
  // @@protoc_insertion_point(field_set:MultiSensorData.alarmHigh)
}

// optional float alarmLow = 3;
inline bool MultiSensorData::has_alarmlow() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MultiSensorData::clear_alarmlow() {
  alarmlow_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float MultiSensorData::alarmlow() const {
  // @@protoc_insertion_point(field_get:MultiSensorData.alarmLow)
  return alarmlow_;
}
inline void MultiSensorData::set_alarmlow(float value) {
  _has_bits_[0] |= 0x00000002u;
  alarmlow_ = value;
  // @@protoc_insertion_point(field_set:MultiSensorData.alarmLow)
}

// optional uint32 calibration = 4;
inline bool MultiSensorData::has_calibration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MultiSensorData::clear_calibration() {
  calibration_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MultiSensorData::calibration() const {
  // @@protoc_insertion_point(field_get:MultiSensorData.calibration)
  return calibration_;
}
inline void MultiSensorData::set_calibration(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  calibration_ = value;
  // @@protoc_insertion_point(field_set:MultiSensorData.calibration)
}

// optional .SensorError error = 5;
inline bool MultiSensorData::has_error() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MultiSensorData::clear_error() {
  error_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::SensorError MultiSensorData::error() const {
  // @@protoc_insertion_point(field_get:MultiSensorData.error)
  return static_cast< ::SensorError >(error_);
}
inline void MultiSensorData::set_error(::SensorError value) {
  assert(::SensorError_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  error_ = value;
  // @@protoc_insertion_point(field_set:MultiSensorData.error)
}

// optional uint32 status = 6;
inline bool MultiSensorData::has_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MultiSensorData::clear_status() {
  status_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MultiSensorData::status() const {
  // @@protoc_insertion_point(field_get:MultiSensorData.status)
  return status_;
}
inline void MultiSensorData::set_status(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  status_ = value;
  // @@protoc_insertion_point(field_set:MultiSensorData.status)
}

// optional float alarmStepHigh = 7;
inline bool MultiSensorData::has_alarmstephigh() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MultiSensorData::clear_alarmstephigh() {
  alarmstephigh_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline float MultiSensorData::alarmstephigh() const {
  // @@protoc_insertion_point(field_get:MultiSensorData.alarmStepHigh)
  return alarmstephigh_;
}
inline void MultiSensorData::set_alarmstephigh(float value) {
  _has_bits_[0] |= 0x00000020u;
  alarmstephigh_ = value;
  // @@protoc_insertion_point(field_set:MultiSensorData.alarmStepHigh)
}

// optional float alarmStepLow = 8;
inline bool MultiSensorData::has_alarmsteplow() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MultiSensorData::clear_alarmsteplow() {
  alarmsteplow_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline float MultiSensorData::alarmsteplow() const {
  // @@protoc_insertion_point(field_get:MultiSensorData.alarmStepLow)
  return alarmsteplow_;
}
inline void MultiSensorData::set_alarmsteplow(float value) {
  _has_bits_[0] |= 0x00000040u;
  alarmsteplow_ = value;
  // @@protoc_insertion_point(field_set:MultiSensorData.alarmStepLow)
}

// -------------------------------------------------------------------

// MultiSensorDataInt

// repeated sint32 data = 1;
inline int MultiSensorDataInt::data_size() const {
  return data_.size();
}
inline void MultiSensorDataInt::clear_data() {
  data_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MultiSensorDataInt::data(int index) const {
  // @@protoc_insertion_point(field_get:MultiSensorDataInt.data)
  return data_.Get(index);
}
inline void MultiSensorDataInt::set_data(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:MultiSensorDataInt.data)
}
inline void MultiSensorDataInt::add_data(::PROTOBUF_NAMESPACE_ID::int32 value) {
  data_.Add(value);
  // @@protoc_insertion_point(field_add:MultiSensorDataInt.data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
MultiSensorDataInt::data() const {
  // @@protoc_insertion_point(field_list:MultiSensorDataInt.data)
  return data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
MultiSensorDataInt::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:MultiSensorDataInt.data)
  return &data_;
}

// optional sint32 alarmHigh = 2;
inline bool MultiSensorDataInt::has_alarmhigh() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MultiSensorDataInt::clear_alarmhigh() {
  alarmhigh_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MultiSensorDataInt::alarmhigh() const {
  // @@protoc_insertion_point(field_get:MultiSensorDataInt.alarmHigh)
  return alarmhigh_;
}
inline void MultiSensorDataInt::set_alarmhigh(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  alarmhigh_ = value;
  // @@protoc_insertion_point(field_set:MultiSensorDataInt.alarmHigh)
}

// optional sint32 alarmLow = 3;
inline bool MultiSensorDataInt::has_alarmlow() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MultiSensorDataInt::clear_alarmlow() {
  alarmlow_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MultiSensorDataInt::alarmlow() const {
  // @@protoc_insertion_point(field_get:MultiSensorDataInt.alarmLow)
  return alarmlow_;
}
inline void MultiSensorDataInt::set_alarmlow(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  alarmlow_ = value;
  // @@protoc_insertion_point(field_set:MultiSensorDataInt.alarmLow)
}

// optional uint32 calibration = 4;
inline bool MultiSensorDataInt::has_calibration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MultiSensorDataInt::clear_calibration() {
  calibration_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MultiSensorDataInt::calibration() const {
  // @@protoc_insertion_point(field_get:MultiSensorDataInt.calibration)
  return calibration_;
}
inline void MultiSensorDataInt::set_calibration(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  calibration_ = value;
  // @@protoc_insertion_point(field_set:MultiSensorDataInt.calibration)
}

// optional .SensorError error = 5;
inline bool MultiSensorDataInt::has_error() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MultiSensorDataInt::clear_error() {
  error_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::SensorError MultiSensorDataInt::error() const {
  // @@protoc_insertion_point(field_get:MultiSensorDataInt.error)
  return static_cast< ::SensorError >(error_);
}
inline void MultiSensorDataInt::set_error(::SensorError value) {
  assert(::SensorError_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  error_ = value;
  // @@protoc_insertion_point(field_set:MultiSensorDataInt.error)
}

// optional uint32 status = 6;
inline bool MultiSensorDataInt::has_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MultiSensorDataInt::clear_status() {
  status_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MultiSensorDataInt::status() const {
  // @@protoc_insertion_point(field_get:MultiSensorDataInt.status)
  return status_;
}
inline void MultiSensorDataInt::set_status(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  status_ = value;
  // @@protoc_insertion_point(field_set:MultiSensorDataInt.status)
}

// optional sint32 alarmStepHigh = 7;
inline bool MultiSensorDataInt::has_alarmstephigh() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MultiSensorDataInt::clear_alarmstephigh() {
  alarmstephigh_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MultiSensorDataInt::alarmstephigh() const {
  // @@protoc_insertion_point(field_get:MultiSensorDataInt.alarmStepHigh)
  return alarmstephigh_;
}
inline void MultiSensorDataInt::set_alarmstephigh(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  alarmstephigh_ = value;
  // @@protoc_insertion_point(field_set:MultiSensorDataInt.alarmStepHigh)
}

// optional sint32 alarmStepLow = 8;
inline bool MultiSensorDataInt::has_alarmsteplow() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MultiSensorDataInt::clear_alarmsteplow() {
  alarmsteplow_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MultiSensorDataInt::alarmsteplow() const {
  // @@protoc_insertion_point(field_get:MultiSensorDataInt.alarmStepLow)
  return alarmsteplow_;
}
inline void MultiSensorDataInt::set_alarmsteplow(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  alarmsteplow_ = value;
  // @@protoc_insertion_point(field_set:MultiSensorDataInt.alarmStepLow)
}

// -------------------------------------------------------------------

// GpsData

// optional double latitude = 1;
inline bool GpsData::has_latitude() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GpsData::clear_latitude() {
  latitude_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double GpsData::latitude() const {
  // @@protoc_insertion_point(field_get:GpsData.latitude)
  return latitude_;
}
inline void GpsData::set_latitude(double value) {
  _has_bits_[0] |= 0x00000001u;
  latitude_ = value;
  // @@protoc_insertion_point(field_set:GpsData.latitude)
}

// optional double longitude = 2;
inline bool GpsData::has_longitude() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GpsData::clear_longitude() {
  longitude_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double GpsData::longitude() const {
  // @@protoc_insertion_point(field_get:GpsData.longitude)
  return longitude_;
}
inline void GpsData::set_longitude(double value) {
  _has_bits_[0] |= 0x00000002u;
  longitude_ = value;
  // @@protoc_insertion_point(field_set:GpsData.longitude)
}

// optional double altitude = 3;
inline bool GpsData::has_altitude() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GpsData::clear_altitude() {
  altitude_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double GpsData::altitude() const {
  // @@protoc_insertion_point(field_get:GpsData.altitude)
  return altitude_;
}
inline void GpsData::set_altitude(double value) {
  _has_bits_[0] |= 0x00000004u;
  altitude_ = value;
  // @@protoc_insertion_point(field_set:GpsData.altitude)
}

// -------------------------------------------------------------------

// AxisData

// optional float x = 1;
inline bool AxisData::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AxisData::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float AxisData::x() const {
  // @@protoc_insertion_point(field_get:AxisData.x)
  return x_;
}
inline void AxisData::set_x(float value) {
  _has_bits_[0] |= 0x00000001u;
  x_ = value;
  // @@protoc_insertion_point(field_set:AxisData.x)
}

// optional float y = 2;
inline bool AxisData::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AxisData::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float AxisData::y() const {
  // @@protoc_insertion_point(field_get:AxisData.y)
  return y_;
}
inline void AxisData::set_y(float value) {
  _has_bits_[0] |= 0x00000002u;
  y_ = value;
  // @@protoc_insertion_point(field_set:AxisData.y)
}

// optional float z = 3;
inline bool AxisData::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AxisData::clear_z() {
  z_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float AxisData::z() const {
  // @@protoc_insertion_point(field_get:AxisData.z)
  return z_;
}
inline void AxisData::set_z(float value) {
  _has_bits_[0] |= 0x00000004u;
  z_ = value;
  // @@protoc_insertion_point(field_set:AxisData.z)
}

// -------------------------------------------------------------------

// iBeacon

// optional bytes uuid = 1;
inline bool iBeacon::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void iBeacon::clear_uuid() {
  uuid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& iBeacon::uuid() const {
  // @@protoc_insertion_point(field_get:iBeacon.uuid)
  return uuid_.GetNoArena();
}
inline void iBeacon::set_uuid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  uuid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:iBeacon.uuid)
}
inline void iBeacon::set_uuid(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  uuid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:iBeacon.uuid)
}
inline void iBeacon::set_uuid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  uuid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:iBeacon.uuid)
}
inline void iBeacon::set_uuid(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  uuid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:iBeacon.uuid)
}
inline std::string* iBeacon::mutable_uuid() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:iBeacon.uuid)
  return uuid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* iBeacon::release_uuid() {
  // @@protoc_insertion_point(field_release:iBeacon.uuid)
  if (!has_uuid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return uuid_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void iBeacon::set_allocated_uuid(std::string* uuid) {
  if (uuid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  uuid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uuid);
  // @@protoc_insertion_point(field_set_allocated:iBeacon.uuid)
}

// optional uint32 major = 2;
inline bool iBeacon::has_major() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void iBeacon::clear_major() {
  major_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 iBeacon::major() const {
  // @@protoc_insertion_point(field_get:iBeacon.major)
  return major_;
}
inline void iBeacon::set_major(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  major_ = value;
  // @@protoc_insertion_point(field_set:iBeacon.major)
}

// optional uint32 minor = 3;
inline bool iBeacon::has_minor() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void iBeacon::clear_minor() {
  minor_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 iBeacon::minor() const {
  // @@protoc_insertion_point(field_get:iBeacon.minor)
  return minor_;
}
inline void iBeacon::set_minor(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  minor_ = value;
  // @@protoc_insertion_point(field_set:iBeacon.minor)
}

// optional sint32 mrssi = 4;
inline bool iBeacon::has_mrssi() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void iBeacon::clear_mrssi() {
  mrssi_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 iBeacon::mrssi() const {
  // @@protoc_insertion_point(field_get:iBeacon.mrssi)
  return mrssi_;
}
inline void iBeacon::set_mrssi(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  mrssi_ = value;
  // @@protoc_insertion_point(field_set:iBeacon.mrssi)
}

// -------------------------------------------------------------------

// ExtSmoke

// optional uint32 bgSignal = 1;
inline bool ExtSmoke::has_bgsignal() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExtSmoke::clear_bgsignal() {
  bgsignal_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ExtSmoke::bgsignal() const {
  // @@protoc_insertion_point(field_get:ExtSmoke.bgSignal)
  return bgsignal_;
}
inline void ExtSmoke::set_bgsignal(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  bgsignal_ = value;
  // @@protoc_insertion_point(field_set:ExtSmoke.bgSignal)
}

// optional uint32 bgSignalThreshold = 2;
inline bool ExtSmoke::has_bgsignalthreshold() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExtSmoke::clear_bgsignalthreshold() {
  bgsignalthreshold_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ExtSmoke::bgsignalthreshold() const {
  // @@protoc_insertion_point(field_get:ExtSmoke.bgSignalThreshold)
  return bgsignalthreshold_;
}
inline void ExtSmoke::set_bgsignalthreshold(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  bgsignalthreshold_ = value;
  // @@protoc_insertion_point(field_set:ExtSmoke.bgSignalThreshold)
}

// optional uint32 bgSignalCalibration = 3;
inline bool ExtSmoke::has_bgsignalcalibration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExtSmoke::clear_bgsignalcalibration() {
  bgsignalcalibration_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ExtSmoke::bgsignalcalibration() const {
  // @@protoc_insertion_point(field_get:ExtSmoke.bgSignalCalibration)
  return bgsignalcalibration_;
}
inline void ExtSmoke::set_bgsignalcalibration(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  bgsignalcalibration_ = value;
  // @@protoc_insertion_point(field_set:ExtSmoke.bgSignalCalibration)
}

// -------------------------------------------------------------------

// AppParam

// optional .AppCmd cmd = 1;
inline bool AppParam::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AppParam::clear_cmd() {
  cmd_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::AppCmd AppParam::cmd() const {
  // @@protoc_insertion_point(field_get:AppParam.cmd)
  return static_cast< ::AppCmd >(cmd_);
}
inline void AppParam::set_cmd(::AppCmd value) {
  assert(::AppCmd_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  cmd_ = value;
  // @@protoc_insertion_point(field_set:AppParam.cmd)
}

// optional uint32 uploadInterval = 2;
inline bool AppParam::has_uploadinterval() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AppParam::clear_uploadinterval() {
  uploadinterval_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppParam::uploadinterval() const {
  // @@protoc_insertion_point(field_get:AppParam.uploadInterval)
  return uploadinterval_;
}
inline void AppParam::set_uploadinterval(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  uploadinterval_ = value;
  // @@protoc_insertion_point(field_set:AppParam.uploadInterval)
}

// optional uint32 syncTime = 3;
inline bool AppParam::has_synctime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AppParam::clear_synctime() {
  synctime_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppParam::synctime() const {
  // @@protoc_insertion_point(field_get:AppParam.syncTime)
  return synctime_;
}
inline void AppParam::set_synctime(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  synctime_ = value;
  // @@protoc_insertion_point(field_set:AppParam.syncTime)
}

// optional .NodeState nodeState = 4;
inline bool AppParam::has_nodestate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AppParam::clear_nodestate() {
  nodestate_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::NodeState AppParam::nodestate() const {
  // @@protoc_insertion_point(field_get:AppParam.nodeState)
  return static_cast< ::NodeState >(nodestate_);
}
inline void AppParam::set_nodestate(::NodeState value) {
  assert(::NodeState_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  nodestate_ = value;
  // @@protoc_insertion_point(field_set:AppParam.nodeState)
}

// optional .NodeAlarm nodeAlarm = 5;
inline bool AppParam::has_nodealarm() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AppParam::clear_nodealarm() {
  nodealarm_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::NodeAlarm AppParam::nodealarm() const {
  // @@protoc_insertion_point(field_get:AppParam.nodeAlarm)
  return static_cast< ::NodeAlarm >(nodealarm_);
}
inline void AppParam::set_nodealarm(::NodeAlarm value) {
  assert(::NodeAlarm_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  nodealarm_ = value;
  // @@protoc_insertion_point(field_set:AppParam.nodeAlarm)
}

// optional uint32 nodeAlarmSet = 6;
inline bool AppParam::has_nodealarmset() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AppParam::clear_nodealarmset() {
  nodealarmset_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppParam::nodealarmset() const {
  // @@protoc_insertion_point(field_get:AppParam.nodeAlarmSet)
  return nodealarmset_;
}
inline void AppParam::set_nodealarmset(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  nodealarmset_ = value;
  // @@protoc_insertion_point(field_set:AppParam.nodeAlarmSet)
}

// optional uint32 confirm = 7;
inline bool AppParam::has_confirm() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AppParam::clear_confirm() {
  confirm_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppParam::confirm() const {
  // @@protoc_insertion_point(field_get:AppParam.confirm)
  return confirm_;
}
inline void AppParam::set_confirm(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  confirm_ = value;
  // @@protoc_insertion_point(field_set:AppParam.confirm)
}

// optional .SmokeCtrl smokeCtrl = 8;
inline bool AppParam::has_smokectrl() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AppParam::clear_smokectrl() {
  smokectrl_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::SmokeCtrl AppParam::smokectrl() const {
  // @@protoc_insertion_point(field_get:AppParam.smokeCtrl)
  return static_cast< ::SmokeCtrl >(smokectrl_);
}
inline void AppParam::set_smokectrl(::SmokeCtrl value) {
  assert(::SmokeCtrl_IsValid(value));
  _has_bits_[0] |= 0x00000080u;
  smokectrl_ = value;
  // @@protoc_insertion_point(field_set:AppParam.smokeCtrl)
}

// optional uint32 uploadRepeat = 9;
inline bool AppParam::has_uploadrepeat() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AppParam::clear_uploadrepeat() {
  uploadrepeat_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppParam::uploadrepeat() const {
  // @@protoc_insertion_point(field_get:AppParam.uploadRepeat)
  return uploadrepeat_;
}
inline void AppParam::set_uploadrepeat(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000100u;
  uploadrepeat_ = value;
  // @@protoc_insertion_point(field_set:AppParam.uploadRepeat)
}

// optional uint32 alarmUploadInterval = 10;
inline bool AppParam::has_alarmuploadinterval() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AppParam::clear_alarmuploadinterval() {
  alarmuploadinterval_ = 0u;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppParam::alarmuploadinterval() const {
  // @@protoc_insertion_point(field_get:AppParam.alarmUploadInterval)
  return alarmuploadinterval_;
}
inline void AppParam::set_alarmuploadinterval(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000200u;
  alarmuploadinterval_ = value;
  // @@protoc_insertion_point(field_set:AppParam.alarmUploadInterval)
}

// optional uint32 alarmUploadNb = 11;
inline bool AppParam::has_alarmuploadnb() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AppParam::clear_alarmuploadnb() {
  alarmuploadnb_ = 0u;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppParam::alarmuploadnb() const {
  // @@protoc_insertion_point(field_get:AppParam.alarmUploadNb)
  return alarmuploadnb_;
}
inline void AppParam::set_alarmuploadnb(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000400u;
  alarmuploadnb_ = value;
  // @@protoc_insertion_point(field_set:AppParam.alarmUploadNb)
}

// optional .TrackerCtrl trackerCtrl = 12;
inline bool AppParam::has_trackerctrl() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void AppParam::clear_trackerctrl() {
  trackerctrl_ = 0;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::TrackerCtrl AppParam::trackerctrl() const {
  // @@protoc_insertion_point(field_get:AppParam.trackerCtrl)
  return static_cast< ::TrackerCtrl >(trackerctrl_);
}
inline void AppParam::set_trackerctrl(::TrackerCtrl value) {
  assert(::TrackerCtrl_IsValid(value));
  _has_bits_[0] |= 0x00000800u;
  trackerctrl_ = value;
  // @@protoc_insertion_point(field_set:AppParam.trackerCtrl)
}

// optional uint32 trackerEmergencyTime = 13;
inline bool AppParam::has_trackeremergencytime() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void AppParam::clear_trackeremergencytime() {
  trackeremergencytime_ = 0u;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppParam::trackeremergencytime() const {
  // @@protoc_insertion_point(field_get:AppParam.trackerEmergencyTime)
  return trackeremergencytime_;
}
inline void AppParam::set_trackeremergencytime(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00001000u;
  trackeremergencytime_ = value;
  // @@protoc_insertion_point(field_set:AppParam.trackerEmergencyTime)
}

// optional uint32 demoMode = 14;
inline bool AppParam::has_demomode() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void AppParam::clear_demomode() {
  demomode_ = 0u;
  _has_bits_[0] &= ~0x00002000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AppParam::demomode() const {
  // @@protoc_insertion_point(field_get:AppParam.demoMode)
  return demomode_;
}
inline void AppParam::set_demomode(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00002000u;
  demomode_ = value;
  // @@protoc_insertion_point(field_set:AppParam.demoMode)
}

// -------------------------------------------------------------------

// ElecFireData

// optional sint32 vol_val = 1;
inline bool ElecFireData::has_vol_val() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ElecFireData::clear_vol_val() {
  vol_val_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ElecFireData::vol_val() const {
  // @@protoc_insertion_point(field_get:ElecFireData.vol_val)
  return vol_val_;
}
inline void ElecFireData::set_vol_val(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  vol_val_ = value;
  // @@protoc_insertion_point(field_set:ElecFireData.vol_val)
}

// optional uint32 curr_val = 2;
inline bool ElecFireData::has_curr_val() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ElecFireData::clear_curr_val() {
  curr_val_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ElecFireData::curr_val() const {
  // @@protoc_insertion_point(field_get:ElecFireData.curr_val)
  return curr_val_;
}
inline void ElecFireData::set_curr_val(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  curr_val_ = value;
  // @@protoc_insertion_point(field_set:ElecFireData.curr_val)
}

// optional sint32 leakage_val = 3;
inline bool ElecFireData::has_leakage_val() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ElecFireData::clear_leakage_val() {
  leakage_val_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ElecFireData::leakage_val() const {
  // @@protoc_insertion_point(field_get:ElecFireData.leakage_val)
  return leakage_val_;
}
inline void ElecFireData::set_leakage_val(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  leakage_val_ = value;
  // @@protoc_insertion_point(field_set:ElecFireData.leakage_val)
}

// optional uint32 power_val = 4;
inline bool ElecFireData::has_power_val() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ElecFireData::clear_power_val() {
  power_val_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ElecFireData::power_val() const {
  // @@protoc_insertion_point(field_get:ElecFireData.power_val)
  return power_val_;
}
inline void ElecFireData::set_power_val(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  power_val_ = value;
  // @@protoc_insertion_point(field_set:ElecFireData.power_val)
}

// optional uint32 elec_energy_val = 5;
inline bool ElecFireData::has_elec_energy_val() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ElecFireData::clear_elec_energy_val() {
  elec_energy_val_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ElecFireData::elec_energy_val() const {
  // @@protoc_insertion_point(field_get:ElecFireData.elec_energy_val)
  return elec_energy_val_;
}
inline void ElecFireData::set_elec_energy_val(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  elec_energy_val_ = value;
  // @@protoc_insertion_point(field_set:ElecFireData.elec_energy_val)
}

// optional uint32 temp_val = 6;
inline bool ElecFireData::has_temp_val() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ElecFireData::clear_temp_val() {
  temp_val_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ElecFireData::temp_val() const {
  // @@protoc_insertion_point(field_get:ElecFireData.temp_val)
  return temp_val_;
}
inline void ElecFireData::set_temp_val(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  temp_val_ = value;
  // @@protoc_insertion_point(field_set:ElecFireData.temp_val)
}

// optional uint32 status = 7;
inline bool ElecFireData::has_status() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ElecFireData::clear_status() {
  status_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ElecFireData::status() const {
  // @@protoc_insertion_point(field_get:ElecFireData.status)
  return status_;
}
inline void ElecFireData::set_status(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  status_ = value;
  // @@protoc_insertion_point(field_set:ElecFireData.status)
}

// optional uint32 alarm = 8;
inline bool ElecFireData::has_alarm() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ElecFireData::clear_alarm() {
  alarm_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ElecFireData::alarm() const {
  // @@protoc_insertion_point(field_get:ElecFireData.alarm)
  return alarm_;
}
inline void ElecFireData::set_alarm(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  alarm_ = value;
  // @@protoc_insertion_point(field_set:ElecFireData.alarm)
}

// optional uint32 error = 9;
inline bool ElecFireData::has_error() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ElecFireData::clear_error() {
  error_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ElecFireData::error() const {
  // @@protoc_insertion_point(field_get:ElecFireData.error)
  return error_;
}
inline void ElecFireData::set_error(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000100u;
  error_ = value;
  // @@protoc_insertion_point(field_set:ElecFireData.error)
}

// optional uint32 sensorPwd = 10;
inline bool ElecFireData::has_sensorpwd() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ElecFireData::clear_sensorpwd() {
  sensorpwd_ = 0u;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ElecFireData::sensorpwd() const {
  // @@protoc_insertion_point(field_get:ElecFireData.sensorPwd)
  return sensorpwd_;
}
inline void ElecFireData::set_sensorpwd(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000200u;
  sensorpwd_ = value;
  // @@protoc_insertion_point(field_set:ElecFireData.sensorPwd)
}

// optional uint32 leakageTh = 11;
inline bool ElecFireData::has_leakageth() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ElecFireData::clear_leakageth() {
  leakageth_ = 0u;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ElecFireData::leakageth() const {
  // @@protoc_insertion_point(field_get:ElecFireData.leakageTh)
  return leakageth_;
}
inline void ElecFireData::set_leakageth(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000400u;
  leakageth_ = value;
  // @@protoc_insertion_point(field_set:ElecFireData.leakageTh)
}

// optional uint32 tempTh = 12;
inline bool ElecFireData::has_tempth() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ElecFireData::clear_tempth() {
  tempth_ = 0u;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ElecFireData::tempth() const {
  // @@protoc_insertion_point(field_get:ElecFireData.tempTh)
  return tempth_;
}
inline void ElecFireData::set_tempth(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000800u;
  tempth_ = value;
  // @@protoc_insertion_point(field_set:ElecFireData.tempTh)
}

// optional uint32 currentTh = 13;
inline bool ElecFireData::has_currentth() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ElecFireData::clear_currentth() {
  currentth_ = 0u;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ElecFireData::currentth() const {
  // @@protoc_insertion_point(field_get:ElecFireData.currentTh)
  return currentth_;
}
inline void ElecFireData::set_currentth(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00001000u;
  currentth_ = value;
  // @@protoc_insertion_point(field_set:ElecFireData.currentTh)
}

// optional uint32 loadTh = 14;
inline bool ElecFireData::has_loadth() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ElecFireData::clear_loadth() {
  loadth_ = 0u;
  _has_bits_[0] &= ~0x00002000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ElecFireData::loadth() const {
  // @@protoc_insertion_point(field_get:ElecFireData.loadTh)
  return loadth_;
}
inline void ElecFireData::set_loadth(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00002000u;
  loadth_ = value;
  // @@protoc_insertion_point(field_set:ElecFireData.loadTh)
}

// optional uint32 volHighTh = 15;
inline bool ElecFireData::has_volhighth() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ElecFireData::clear_volhighth() {
  volhighth_ = 0u;
  _has_bits_[0] &= ~0x00004000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ElecFireData::volhighth() const {
  // @@protoc_insertion_point(field_get:ElecFireData.volHighTh)
  return volhighth_;
}
inline void ElecFireData::set_volhighth(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00004000u;
  volhighth_ = value;
  // @@protoc_insertion_point(field_set:ElecFireData.volHighTh)
}

// optional uint32 volLowTh = 16;
inline bool ElecFireData::has_vollowth() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ElecFireData::clear_vollowth() {
  vollowth_ = 0u;
  _has_bits_[0] &= ~0x00008000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ElecFireData::vollowth() const {
  // @@protoc_insertion_point(field_get:ElecFireData.volLowTh)
  return vollowth_;
}
inline void ElecFireData::set_vollowth(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00008000u;
  vollowth_ = value;
  // @@protoc_insertion_point(field_set:ElecFireData.volLowTh)
}

// optional uint32 cmd = 17;
inline bool ElecFireData::has_cmd() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ElecFireData::clear_cmd() {
  cmd_ = 0u;
  _has_bits_[0] &= ~0x00010000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ElecFireData::cmd() const {
  // @@protoc_insertion_point(field_get:ElecFireData.cmd)
  return cmd_;
}
inline void ElecFireData::set_cmd(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00010000u;
  cmd_ = value;
  // @@protoc_insertion_point(field_set:ElecFireData.cmd)
}

// optional uint32 autoSwitch = 18;
inline bool ElecFireData::has_autoswitch() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ElecFireData::clear_autoswitch() {
  autoswitch_ = 0u;
  _has_bits_[0] &= ~0x00020000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ElecFireData::autoswitch() const {
  // @@protoc_insertion_point(field_get:ElecFireData.autoSwitch)
  return autoswitch_;
}
inline void ElecFireData::set_autoswitch(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00020000u;
  autoswitch_ = value;
  // @@protoc_insertion_point(field_set:ElecFireData.autoSwitch)
}

// -------------------------------------------------------------------

// MantunData

// optional uint32 volVal = 1;
inline bool MantunData::has_volval() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MantunData::clear_volval() {
  volval_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MantunData::volval() const {
  // @@protoc_insertion_point(field_get:MantunData.volVal)
  return volval_;
}
inline void MantunData::set_volval(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  volval_ = value;
  // @@protoc_insertion_point(field_set:MantunData.volVal)
}

// optional uint32 leakageVal = 2;
inline bool MantunData::has_leakageval() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MantunData::clear_leakageval() {
  leakageval_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MantunData::leakageval() const {
  // @@protoc_insertion_point(field_get:MantunData.leakageVal)
  return leakageval_;
}
inline void MantunData::set_leakageval(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  leakageval_ = value;
  // @@protoc_insertion_point(field_set:MantunData.leakageVal)
}

// optional uint32 powerVal = 3;
inline bool MantunData::has_powerval() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MantunData::clear_powerval() {
  powerval_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MantunData::powerval() const {
  // @@protoc_insertion_point(field_get:MantunData.powerVal)
  return powerval_;
}
inline void MantunData::set_powerval(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  powerval_ = value;
  // @@protoc_insertion_point(field_set:MantunData.powerVal)
}

// optional uint32 tempVal = 4;
inline bool MantunData::has_tempval() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MantunData::clear_tempval() {
  tempval_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MantunData::tempval() const {
  // @@protoc_insertion_point(field_get:MantunData.tempVal)
  return tempval_;
}
inline void MantunData::set_tempval(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  tempval_ = value;
  // @@protoc_insertion_point(field_set:MantunData.tempVal)
}

// optional uint32 currVal = 5;
inline bool MantunData::has_currval() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MantunData::clear_currval() {
  currval_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MantunData::currval() const {
  // @@protoc_insertion_point(field_get:MantunData.currVal)
  return currval_;
}
inline void MantunData::set_currval(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  currval_ = value;
  // @@protoc_insertion_point(field_set:MantunData.currVal)
}

// optional uint32 status = 6;
inline bool MantunData::has_status() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MantunData::clear_status() {
  status_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MantunData::status() const {
  // @@protoc_insertion_point(field_get:MantunData.status)
  return status_;
}
inline void MantunData::set_status(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  status_ = value;
  // @@protoc_insertion_point(field_set:MantunData.status)
}

// optional uint32 kwhVal = 7;
inline bool MantunData::has_kwhval() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MantunData::clear_kwhval() {
  kwhval_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MantunData::kwhval() const {
  // @@protoc_insertion_point(field_get:MantunData.kwhVal)
  return kwhval_;
}
inline void MantunData::set_kwhval(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  kwhval_ = value;
  // @@protoc_insertion_point(field_set:MantunData.kwhVal)
}

// optional uint32 swOnOff = 8;
inline bool MantunData::has_swonoff() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MantunData::clear_swonoff() {
  swonoff_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MantunData::swonoff() const {
  // @@protoc_insertion_point(field_get:MantunData.swOnOff)
  return swonoff_;
}
inline void MantunData::set_swonoff(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  swonoff_ = value;
  // @@protoc_insertion_point(field_set:MantunData.swOnOff)
}

// optional uint32 volHighTh = 9;
inline bool MantunData::has_volhighth() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MantunData::clear_volhighth() {
  volhighth_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MantunData::volhighth() const {
  // @@protoc_insertion_point(field_get:MantunData.volHighTh)
  return volhighth_;
}
inline void MantunData::set_volhighth(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000100u;
  volhighth_ = value;
  // @@protoc_insertion_point(field_set:MantunData.volHighTh)
}

// optional uint32 volLowTh = 10;
inline bool MantunData::has_vollowth() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MantunData::clear_vollowth() {
  vollowth_ = 0u;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MantunData::vollowth() const {
  // @@protoc_insertion_point(field_get:MantunData.volLowTh)
  return vollowth_;
}
inline void MantunData::set_vollowth(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000200u;
  vollowth_ = value;
  // @@protoc_insertion_point(field_set:MantunData.volLowTh)
}

// optional uint32 leakageTh = 11;
inline bool MantunData::has_leakageth() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MantunData::clear_leakageth() {
  leakageth_ = 0u;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MantunData::leakageth() const {
  // @@protoc_insertion_point(field_get:MantunData.leakageTh)
  return leakageth_;
}
inline void MantunData::set_leakageth(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000400u;
  leakageth_ = value;
  // @@protoc_insertion_point(field_set:MantunData.leakageTh)
}

// optional uint32 tempTh = 12;
inline bool MantunData::has_tempth() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MantunData::clear_tempth() {
  tempth_ = 0u;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MantunData::tempth() const {
  // @@protoc_insertion_point(field_get:MantunData.tempTh)
  return tempth_;
}
inline void MantunData::set_tempth(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000800u;
  tempth_ = value;
  // @@protoc_insertion_point(field_set:MantunData.tempTh)
}

// optional uint32 currentTh = 13;
inline bool MantunData::has_currentth() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MantunData::clear_currentth() {
  currentth_ = 0u;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MantunData::currentth() const {
  // @@protoc_insertion_point(field_get:MantunData.currentTh)
  return currentth_;
}
inline void MantunData::set_currentth(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00001000u;
  currentth_ = value;
  // @@protoc_insertion_point(field_set:MantunData.currentTh)
}

// optional uint32 powerTh = 14;
inline bool MantunData::has_powerth() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MantunData::clear_powerth() {
  powerth_ = 0u;
  _has_bits_[0] &= ~0x00002000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MantunData::powerth() const {
  // @@protoc_insertion_point(field_get:MantunData.powerTh)
  return powerth_;
}
inline void MantunData::set_powerth(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00002000u;
  powerth_ = value;
  // @@protoc_insertion_point(field_set:MantunData.powerTh)
}

// optional uint32 attribute = 15;
inline bool MantunData::has_attribute() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void MantunData::clear_attribute() {
  attribute_ = 0u;
  _has_bits_[0] &= ~0x00004000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MantunData::attribute() const {
  // @@protoc_insertion_point(field_get:MantunData.attribute)
  return attribute_;
}
inline void MantunData::set_attribute(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00004000u;
  attribute_ = value;
  // @@protoc_insertion_point(field_set:MantunData.attribute)
}

// optional uint32 cmd = 16;
inline bool MantunData::has_cmd() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void MantunData::clear_cmd() {
  cmd_ = 0u;
  _has_bits_[0] &= ~0x00008000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MantunData::cmd() const {
  // @@protoc_insertion_point(field_get:MantunData.cmd)
  return cmd_;
}
inline void MantunData::set_cmd(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00008000u;
  cmd_ = value;
  // @@protoc_insertion_point(field_set:MantunData.cmd)
}

// optional uint32 devError = 17;
inline bool MantunData::has_deverror() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void MantunData::clear_deverror() {
  deverror_ = 0u;
  _has_bits_[0] &= ~0x00010000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MantunData::deverror() const {
  // @@protoc_insertion_point(field_get:MantunData.devError)
  return deverror_;
}
inline void MantunData::set_deverror(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00010000u;
  deverror_ = value;
  // @@protoc_insertion_point(field_set:MantunData.devError)
}

// optional uint32 version = 18;
inline bool MantunData::has_version() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void MantunData::clear_version() {
  version_ = 0u;
  _has_bits_[0] &= ~0x00020000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MantunData::version() const {
  // @@protoc_insertion_point(field_get:MantunData.version)
  return version_;
}
inline void MantunData::set_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00020000u;
  version_ = value;
  // @@protoc_insertion_point(field_set:MantunData.version)
}

// optional uint32 id = 19;
inline bool MantunData::has_id() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void MantunData::clear_id() {
  id_ = 0u;
  _has_bits_[0] &= ~0x00040000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MantunData::id() const {
  // @@protoc_insertion_point(field_get:MantunData.id)
  return id_;
}
inline void MantunData::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00040000u;
  id_ = value;
  // @@protoc_insertion_point(field_set:MantunData.id)
}

// -------------------------------------------------------------------

// Cayman

// optional uint32 isSmoke = 1;
inline bool Cayman::has_issmoke() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Cayman::clear_issmoke() {
  issmoke_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Cayman::issmoke() const {
  // @@protoc_insertion_point(field_get:Cayman.isSmoke)
  return issmoke_;
}
inline void Cayman::set_issmoke(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  issmoke_ = value;
  // @@protoc_insertion_point(field_set:Cayman.isSmoke)
}

// optional uint32 isMoved = 2;
inline bool Cayman::has_ismoved() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Cayman::clear_ismoved() {
  ismoved_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Cayman::ismoved() const {
  // @@protoc_insertion_point(field_get:Cayman.isMoved)
  return ismoved_;
}
inline void Cayman::set_ismoved(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  ismoved_ = value;
  // @@protoc_insertion_point(field_set:Cayman.isMoved)
}

// optional sint32 valueOfTem = 3;
inline bool Cayman::has_valueoftem() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Cayman::clear_valueoftem() {
  valueoftem_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Cayman::valueoftem() const {
  // @@protoc_insertion_point(field_get:Cayman.valueOfTem)
  return valueoftem_;
}
inline void Cayman::set_valueoftem(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  valueoftem_ = value;
  // @@protoc_insertion_point(field_set:Cayman.valueOfTem)
}

// optional uint32 valueOfHum = 4;
inline bool Cayman::has_valueofhum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Cayman::clear_valueofhum() {
  valueofhum_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Cayman::valueofhum() const {
  // @@protoc_insertion_point(field_get:Cayman.valueOfHum)
  return valueofhum_;
}
inline void Cayman::set_valueofhum(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  valueofhum_ = value;
  // @@protoc_insertion_point(field_set:Cayman.valueOfHum)
}

// optional uint32 valueOfSmoke = 5;
inline bool Cayman::has_valueofsmoke() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Cayman::clear_valueofsmoke() {
  valueofsmoke_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Cayman::valueofsmoke() const {
  // @@protoc_insertion_point(field_get:Cayman.valueOfSmoke)
  return valueofsmoke_;
}
inline void Cayman::set_valueofsmoke(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  valueofsmoke_ = value;
  // @@protoc_insertion_point(field_set:Cayman.valueOfSmoke)
}

// optional uint32 standarOfSmoke = 6;
inline bool Cayman::has_standarofsmoke() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Cayman::clear_standarofsmoke() {
  standarofsmoke_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Cayman::standarofsmoke() const {
  // @@protoc_insertion_point(field_get:Cayman.standarOfSmoke)
  return standarofsmoke_;
}
inline void Cayman::set_standarofsmoke(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  standarofsmoke_ = value;
  // @@protoc_insertion_point(field_set:Cayman.standarOfSmoke)
}

// optional sint32 alarmOfHighTem = 7;
inline bool Cayman::has_alarmofhightem() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Cayman::clear_alarmofhightem() {
  alarmofhightem_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Cayman::alarmofhightem() const {
  // @@protoc_insertion_point(field_get:Cayman.alarmOfHighTem)
  return alarmofhightem_;
}
inline void Cayman::set_alarmofhightem(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  alarmofhightem_ = value;
  // @@protoc_insertion_point(field_set:Cayman.alarmOfHighTem)
}

// optional sint32 alarmOfLowTem = 8;
inline bool Cayman::has_alarmoflowtem() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Cayman::clear_alarmoflowtem() {
  alarmoflowtem_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Cayman::alarmoflowtem() const {
  // @@protoc_insertion_point(field_get:Cayman.alarmOfLowTem)
  return alarmoflowtem_;
}
inline void Cayman::set_alarmoflowtem(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000080u;
  alarmoflowtem_ = value;
  // @@protoc_insertion_point(field_set:Cayman.alarmOfLowTem)
}

// optional uint32 alarmOfHighHum = 9;
inline bool Cayman::has_alarmofhighhum() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Cayman::clear_alarmofhighhum() {
  alarmofhighhum_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Cayman::alarmofhighhum() const {
  // @@protoc_insertion_point(field_get:Cayman.alarmOfHighHum)
  return alarmofhighhum_;
}
inline void Cayman::set_alarmofhighhum(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000100u;
  alarmofhighhum_ = value;
  // @@protoc_insertion_point(field_set:Cayman.alarmOfHighHum)
}

// optional uint32 alarmOfLowHum = 10;
inline bool Cayman::has_alarmoflowhum() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Cayman::clear_alarmoflowhum() {
  alarmoflowhum_ = 0u;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Cayman::alarmoflowhum() const {
  // @@protoc_insertion_point(field_get:Cayman.alarmOfLowHum)
  return alarmoflowhum_;
}
inline void Cayman::set_alarmoflowhum(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000200u;
  alarmoflowhum_ = value;
  // @@protoc_insertion_point(field_set:Cayman.alarmOfLowHum)
}

// optional uint32 cmd = 11;
inline bool Cayman::has_cmd() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Cayman::clear_cmd() {
  cmd_ = 0u;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Cayman::cmd() const {
  // @@protoc_insertion_point(field_get:Cayman.cmd)
  return cmd_;
}
inline void Cayman::set_cmd(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000400u;
  cmd_ = value;
  // @@protoc_insertion_point(field_set:Cayman.cmd)
}

// optional uint32 valueOfphotor = 12;
inline bool Cayman::has_valueofphotor() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Cayman::clear_valueofphotor() {
  valueofphotor_ = 0u;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Cayman::valueofphotor() const {
  // @@protoc_insertion_point(field_get:Cayman.valueOfphotor)
  return valueofphotor_;
}
inline void Cayman::set_valueofphotor(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000800u;
  valueofphotor_ = value;
  // @@protoc_insertion_point(field_set:Cayman.valueOfphotor)
}

// optional uint32 devceState = 13;
inline bool Cayman::has_devcestate() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Cayman::clear_devcestate() {
  devcestate_ = 0u;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Cayman::devcestate() const {
  // @@protoc_insertion_point(field_get:Cayman.devceState)
  return devcestate_;
}
inline void Cayman::set_devcestate(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00001000u;
  devcestate_ = value;
  // @@protoc_insertion_point(field_set:Cayman.devceState)
}

// optional uint32 bleAdvType = 14;
inline bool Cayman::has_bleadvtype() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Cayman::clear_bleadvtype() {
  bleadvtype_ = 0u;
  _has_bits_[0] &= ~0x00002000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Cayman::bleadvtype() const {
  // @@protoc_insertion_point(field_get:Cayman.bleAdvType)
  return bleadvtype_;
}
inline void Cayman::set_bleadvtype(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00002000u;
  bleadvtype_ = value;
  // @@protoc_insertion_point(field_set:Cayman.bleAdvType)
}

// optional uint32 bleAdvStartTime = 15;
inline bool Cayman::has_bleadvstarttime() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Cayman::clear_bleadvstarttime() {
  bleadvstarttime_ = 0u;
  _has_bits_[0] &= ~0x00004000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Cayman::bleadvstarttime() const {
  // @@protoc_insertion_point(field_get:Cayman.bleAdvStartTime)
  return bleadvstarttime_;
}
inline void Cayman::set_bleadvstarttime(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00004000u;
  bleadvstarttime_ = value;
  // @@protoc_insertion_point(field_set:Cayman.bleAdvStartTime)
}

// optional uint32 bleAdvEndTime = 16;
inline bool Cayman::has_bleadvendtime() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Cayman::clear_bleadvendtime() {
  bleadvendtime_ = 0u;
  _has_bits_[0] &= ~0x00008000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Cayman::bleadvendtime() const {
  // @@protoc_insertion_point(field_get:Cayman.bleAdvEndTime)
  return bleadvendtime_;
}
inline void Cayman::set_bleadvendtime(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00008000u;
  bleadvendtime_ = value;
  // @@protoc_insertion_point(field_set:Cayman.bleAdvEndTime)
}

// optional uint32 valueOfBatb = 17;
inline bool Cayman::has_valueofbatb() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Cayman::clear_valueofbatb() {
  valueofbatb_ = 0u;
  _has_bits_[0] &= ~0x00010000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Cayman::valueofbatb() const {
  // @@protoc_insertion_point(field_get:Cayman.valueOfBatb)
  return valueofbatb_;
}
inline void Cayman::set_valueofbatb(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00010000u;
  valueofbatb_ = value;
  // @@protoc_insertion_point(field_set:Cayman.valueOfBatb)
}

// optional uint32 levelOfAlarm = 18;
inline bool Cayman::has_levelofalarm() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Cayman::clear_levelofalarm() {
  levelofalarm_ = 0u;
  _has_bits_[0] &= ~0x00020000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Cayman::levelofalarm() const {
  // @@protoc_insertion_point(field_get:Cayman.levelOfAlarm)
  return levelofalarm_;
}
inline void Cayman::set_levelofalarm(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00020000u;
  levelofalarm_ = value;
  // @@protoc_insertion_point(field_set:Cayman.levelOfAlarm)
}

// optional uint32 isSelfCheck = 19;
inline bool Cayman::has_isselfcheck() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Cayman::clear_isselfcheck() {
  isselfcheck_ = 0u;
  _has_bits_[0] &= ~0x00040000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Cayman::isselfcheck() const {
  // @@protoc_insertion_point(field_get:Cayman.isSelfCheck)
  return isselfcheck_;
}
inline void Cayman::set_isselfcheck(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00040000u;
  isselfcheck_ = value;
  // @@protoc_insertion_point(field_set:Cayman.isSelfCheck)
}

// -------------------------------------------------------------------

// AcrelData

// optional uint32 channelType = 1;
inline bool AcrelData::has_channeltype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AcrelData::clear_channeltype() {
  channeltype_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AcrelData::channeltype() const {
  // @@protoc_insertion_point(field_get:AcrelData.channelType)
  return channeltype_;
}
inline void AcrelData::set_channeltype(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  channeltype_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.channelType)
}

// optional uint32 shortCircuit = 2;
inline bool AcrelData::has_shortcircuit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AcrelData::clear_shortcircuit() {
  shortcircuit_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AcrelData::shortcircuit() const {
  // @@protoc_insertion_point(field_get:AcrelData.shortCircuit)
  return shortcircuit_;
}
inline void AcrelData::set_shortcircuit(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  shortcircuit_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.shortCircuit)
}

// optional uint32 openCircuit = 3;
inline bool AcrelData::has_opencircuit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AcrelData::clear_opencircuit() {
  opencircuit_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AcrelData::opencircuit() const {
  // @@protoc_insertion_point(field_get:AcrelData.openCircuit)
  return opencircuit_;
}
inline void AcrelData::set_opencircuit(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  opencircuit_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.openCircuit)
}

// optional uint32 chStatus = 4;
inline bool AcrelData::has_chstatus() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AcrelData::clear_chstatus() {
  chstatus_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AcrelData::chstatus() const {
  // @@protoc_insertion_point(field_get:AcrelData.chStatus)
  return chstatus_;
}
inline void AcrelData::set_chstatus(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  chstatus_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.chStatus)
}

// optional sint32 leakageVal = 5;
inline bool AcrelData::has_leakageval() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AcrelData::clear_leakageval() {
  leakageval_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AcrelData::leakageval() const {
  // @@protoc_insertion_point(field_get:AcrelData.leakageVal)
  return leakageval_;
}
inline void AcrelData::set_leakageval(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  leakageval_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.leakageVal)
}

// optional sint32 t1Val = 6;
inline bool AcrelData::has_t1val() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AcrelData::clear_t1val() {
  t1val_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AcrelData::t1val() const {
  // @@protoc_insertion_point(field_get:AcrelData.t1Val)
  return t1val_;
}
inline void AcrelData::set_t1val(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  t1val_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.t1Val)
}

// optional sint32 t2Val = 7;
inline bool AcrelData::has_t2val() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AcrelData::clear_t2val() {
  t2val_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AcrelData::t2val() const {
  // @@protoc_insertion_point(field_get:AcrelData.t2Val)
  return t2val_;
}
inline void AcrelData::set_t2val(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  t2val_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.t2Val)
}

// optional sint32 t3Val = 8;
inline bool AcrelData::has_t3val() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AcrelData::clear_t3val() {
  t3val_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AcrelData::t3val() const {
  // @@protoc_insertion_point(field_get:AcrelData.t3Val)
  return t3val_;
}
inline void AcrelData::set_t3val(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000080u;
  t3val_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.t3Val)
}

// optional sint32 t4Val = 9;
inline bool AcrelData::has_t4val() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AcrelData::clear_t4val() {
  t4val_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AcrelData::t4val() const {
  // @@protoc_insertion_point(field_get:AcrelData.t4Val)
  return t4val_;
}
inline void AcrelData::set_t4val(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000100u;
  t4val_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.t4Val)
}

// optional uint32 connectSw = 10;
inline bool AcrelData::has_connectsw() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AcrelData::clear_connectsw() {
  connectsw_ = 0u;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AcrelData::connectsw() const {
  // @@protoc_insertion_point(field_get:AcrelData.connectSw)
  return connectsw_;
}
inline void AcrelData::set_connectsw(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000200u;
  connectsw_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.connectSw)
}

// optional uint32 chEnable = 11;
inline bool AcrelData::has_chenable() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AcrelData::clear_chenable() {
  chenable_ = 0u;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AcrelData::chenable() const {
  // @@protoc_insertion_point(field_get:AcrelData.chEnable)
  return chenable_;
}
inline void AcrelData::set_chenable(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000400u;
  chenable_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.chEnable)
}

// optional uint32 leakageTh = 12;
inline bool AcrelData::has_leakageth() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void AcrelData::clear_leakageth() {
  leakageth_ = 0u;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AcrelData::leakageth() const {
  // @@protoc_insertion_point(field_get:AcrelData.leakageTh)
  return leakageth_;
}
inline void AcrelData::set_leakageth(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000800u;
  leakageth_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.leakageTh)
}

// optional uint32 t1Th = 13;
inline bool AcrelData::has_t1th() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void AcrelData::clear_t1th() {
  t1th_ = 0u;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AcrelData::t1th() const {
  // @@protoc_insertion_point(field_get:AcrelData.t1Th)
  return t1th_;
}
inline void AcrelData::set_t1th(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00001000u;
  t1th_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.t1Th)
}

// optional uint32 t2Th = 14;
inline bool AcrelData::has_t2th() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void AcrelData::clear_t2th() {
  t2th_ = 0u;
  _has_bits_[0] &= ~0x00002000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AcrelData::t2th() const {
  // @@protoc_insertion_point(field_get:AcrelData.t2Th)
  return t2th_;
}
inline void AcrelData::set_t2th(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00002000u;
  t2th_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.t2Th)
}

// optional uint32 t3Th = 15;
inline bool AcrelData::has_t3th() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void AcrelData::clear_t3th() {
  t3th_ = 0u;
  _has_bits_[0] &= ~0x00004000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AcrelData::t3th() const {
  // @@protoc_insertion_point(field_get:AcrelData.t3Th)
  return t3th_;
}
inline void AcrelData::set_t3th(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00004000u;
  t3th_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.t3Th)
}

// optional uint32 t4Th = 16;
inline bool AcrelData::has_t4th() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void AcrelData::clear_t4th() {
  t4th_ = 0u;
  _has_bits_[0] &= ~0x00008000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AcrelData::t4th() const {
  // @@protoc_insertion_point(field_get:AcrelData.t4Th)
  return t4th_;
}
inline void AcrelData::set_t4th(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00008000u;
  t4th_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.t4Th)
}

// optional uint32 passwd = 17;
inline bool AcrelData::has_passwd() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void AcrelData::clear_passwd() {
  passwd_ = 0u;
  _has_bits_[0] &= ~0x00010000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AcrelData::passwd() const {
  // @@protoc_insertion_point(field_get:AcrelData.passwd)
  return passwd_;
}
inline void AcrelData::set_passwd(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00010000u;
  passwd_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.passwd)
}

// optional uint32 aVal = 18;
inline bool AcrelData::has_aval() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void AcrelData::clear_aval() {
  aval_ = 0u;
  _has_bits_[0] &= ~0x00020000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AcrelData::aval() const {
  // @@protoc_insertion_point(field_get:AcrelData.aVal)
  return aval_;
}
inline void AcrelData::set_aval(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00020000u;
  aval_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.aVal)
}

// optional uint32 bVal = 19;
inline bool AcrelData::has_bval() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void AcrelData::clear_bval() {
  bval_ = 0u;
  _has_bits_[0] &= ~0x00040000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AcrelData::bval() const {
  // @@protoc_insertion_point(field_get:AcrelData.bVal)
  return bval_;
}
inline void AcrelData::set_bval(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00040000u;
  bval_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.bVal)
}

// optional uint32 cVal = 20;
inline bool AcrelData::has_cval() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void AcrelData::clear_cval() {
  cval_ = 0u;
  _has_bits_[0] &= ~0x00080000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AcrelData::cval() const {
  // @@protoc_insertion_point(field_get:AcrelData.cVal)
  return cval_;
}
inline void AcrelData::set_cval(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00080000u;
  cval_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.cVal)
}

// optional uint32 valStatus = 21;
inline bool AcrelData::has_valstatus() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void AcrelData::clear_valstatus() {
  valstatus_ = 0u;
  _has_bits_[0] &= ~0x00100000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AcrelData::valstatus() const {
  // @@protoc_insertion_point(field_get:AcrelData.valStatus)
  return valstatus_;
}
inline void AcrelData::set_valstatus(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00100000u;
  valstatus_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.valStatus)
}

// optional uint32 aCurr = 22;
inline bool AcrelData::has_acurr() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void AcrelData::clear_acurr() {
  acurr_ = 0u;
  _has_bits_[0] &= ~0x00200000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AcrelData::acurr() const {
  // @@protoc_insertion_point(field_get:AcrelData.aCurr)
  return acurr_;
}
inline void AcrelData::set_acurr(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00200000u;
  acurr_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.aCurr)
}

// optional uint32 bCurr = 23;
inline bool AcrelData::has_bcurr() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void AcrelData::clear_bcurr() {
  bcurr_ = 0u;
  _has_bits_[0] &= ~0x00400000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AcrelData::bcurr() const {
  // @@protoc_insertion_point(field_get:AcrelData.bCurr)
  return bcurr_;
}
inline void AcrelData::set_bcurr(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00400000u;
  bcurr_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.bCurr)
}

// optional uint32 cCurr = 24;
inline bool AcrelData::has_ccurr() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void AcrelData::clear_ccurr() {
  ccurr_ = 0u;
  _has_bits_[0] &= ~0x00800000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AcrelData::ccurr() const {
  // @@protoc_insertion_point(field_get:AcrelData.cCurr)
  return ccurr_;
}
inline void AcrelData::set_ccurr(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00800000u;
  ccurr_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.cCurr)
}

// optional uint32 currStatus = 25;
inline bool AcrelData::has_currstatus() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void AcrelData::clear_currstatus() {
  currstatus_ = 0u;
  _has_bits_[0] &= ~0x01000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AcrelData::currstatus() const {
  // @@protoc_insertion_point(field_get:AcrelData.currStatus)
  return currstatus_;
}
inline void AcrelData::set_currstatus(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x01000000u;
  currstatus_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.currStatus)
}

// optional uint32 totalYg = 26;
inline bool AcrelData::has_totalyg() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void AcrelData::clear_totalyg() {
  totalyg_ = 0u;
  _has_bits_[0] &= ~0x02000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AcrelData::totalyg() const {
  // @@protoc_insertion_point(field_get:AcrelData.totalYg)
  return totalyg_;
}
inline void AcrelData::set_totalyg(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x02000000u;
  totalyg_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.totalYg)
}

// optional uint32 totalWg = 27;
inline bool AcrelData::has_totalwg() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void AcrelData::clear_totalwg() {
  totalwg_ = 0u;
  _has_bits_[0] &= ~0x04000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AcrelData::totalwg() const {
  // @@protoc_insertion_point(field_get:AcrelData.totalWg)
  return totalwg_;
}
inline void AcrelData::set_totalwg(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x04000000u;
  totalwg_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.totalWg)
}

// optional uint32 totalSz = 28;
inline bool AcrelData::has_totalsz() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void AcrelData::clear_totalsz() {
  totalsz_ = 0u;
  _has_bits_[0] &= ~0x08000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AcrelData::totalsz() const {
  // @@protoc_insertion_point(field_get:AcrelData.totalSz)
  return totalsz_;
}
inline void AcrelData::set_totalsz(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x08000000u;
  totalsz_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.totalSz)
}

// optional uint32 totalFactor = 29;
inline bool AcrelData::has_totalfactor() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void AcrelData::clear_totalfactor() {
  totalfactor_ = 0u;
  _has_bits_[0] &= ~0x10000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AcrelData::totalfactor() const {
  // @@protoc_insertion_point(field_get:AcrelData.totalFactor)
  return totalfactor_;
}
inline void AcrelData::set_totalfactor(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x10000000u;
  totalfactor_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.totalFactor)
}

// optional uint32 valHighSet = 30;
inline bool AcrelData::has_valhighset() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void AcrelData::clear_valhighset() {
  valhighset_ = 0u;
  _has_bits_[0] &= ~0x20000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AcrelData::valhighset() const {
  // @@protoc_insertion_point(field_get:AcrelData.valHighSet)
  return valhighset_;
}
inline void AcrelData::set_valhighset(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x20000000u;
  valhighset_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.valHighSet)
}

// optional uint32 valLowSet = 31;
inline bool AcrelData::has_vallowset() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void AcrelData::clear_vallowset() {
  vallowset_ = 0u;
  _has_bits_[0] &= ~0x40000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AcrelData::vallowset() const {
  // @@protoc_insertion_point(field_get:AcrelData.valLowSet)
  return vallowset_;
}
inline void AcrelData::set_vallowset(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x40000000u;
  vallowset_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.valLowSet)
}

// optional uint32 currHighSet = 32;
inline bool AcrelData::has_currhighset() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void AcrelData::clear_currhighset() {
  currhighset_ = 0u;
  _has_bits_[0] &= ~0x80000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AcrelData::currhighset() const {
  // @@protoc_insertion_point(field_get:AcrelData.currHighSet)
  return currhighset_;
}
inline void AcrelData::set_currhighset(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x80000000u;
  currhighset_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.currHighSet)
}

// optional uint32 energyKwh = 33;
inline bool AcrelData::has_energykwh() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void AcrelData::clear_energykwh() {
  energykwh_ = 0u;
  _has_bits_[1] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AcrelData::energykwh() const {
  // @@protoc_insertion_point(field_get:AcrelData.energyKwh)
  return energykwh_;
}
inline void AcrelData::set_energykwh(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[1] |= 0x00000001u;
  energykwh_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.energyKwh)
}

// optional uint32 cmd = 35;
inline bool AcrelData::has_cmd() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void AcrelData::clear_cmd() {
  cmd_ = 0u;
  _has_bits_[1] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AcrelData::cmd() const {
  // @@protoc_insertion_point(field_get:AcrelData.cmd)
  return cmd_;
}
inline void AcrelData::set_cmd(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[1] |= 0x00000002u;
  cmd_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.cmd)
}

// optional uint32 devError = 36;
inline bool AcrelData::has_deverror() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void AcrelData::clear_deverror() {
  deverror_ = 0u;
  _has_bits_[1] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AcrelData::deverror() const {
  // @@protoc_insertion_point(field_get:AcrelData.devError)
  return deverror_;
}
inline void AcrelData::set_deverror(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[1] |= 0x00000004u;
  deverror_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.devError)
}

// optional uint32 ct = 37;
inline bool AcrelData::has_ct() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void AcrelData::clear_ct() {
  ct_ = 0u;
  _has_bits_[1] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AcrelData::ct() const {
  // @@protoc_insertion_point(field_get:AcrelData.ct)
  return ct_;
}
inline void AcrelData::set_ct(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[1] |= 0x00000008u;
  ct_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.ct)
}

// optional uint32 outputSw = 38;
inline bool AcrelData::has_outputsw() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void AcrelData::clear_outputsw() {
  outputsw_ = 0u;
  _has_bits_[1] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AcrelData::outputsw() const {
  // @@protoc_insertion_point(field_get:AcrelData.outputSw)
  return outputsw_;
}
inline void AcrelData::set_outputsw(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[1] |= 0x00000010u;
  outputsw_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.outputSw)
}

// optional uint32 selfCheck = 39;
inline bool AcrelData::has_selfcheck() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void AcrelData::clear_selfcheck() {
  selfcheck_ = 0u;
  _has_bits_[1] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AcrelData::selfcheck() const {
  // @@protoc_insertion_point(field_get:AcrelData.selfCheck)
  return selfcheck_;
}
inline void AcrelData::set_selfcheck(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[1] |= 0x00000020u;
  selfcheck_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.selfCheck)
}

// optional uint32 valHighType = 40;
inline bool AcrelData::has_valhightype() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void AcrelData::clear_valhightype() {
  valhightype_ = 0u;
  _has_bits_[1] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AcrelData::valhightype() const {
  // @@protoc_insertion_point(field_get:AcrelData.valHighType)
  return valhightype_;
}
inline void AcrelData::set_valhightype(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[1] |= 0x00000040u;
  valhightype_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.valHighType)
}

// optional uint32 valLowType = 41;
inline bool AcrelData::has_vallowtype() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void AcrelData::clear_vallowtype() {
  vallowtype_ = 0u;
  _has_bits_[1] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AcrelData::vallowtype() const {
  // @@protoc_insertion_point(field_get:AcrelData.valLowType)
  return vallowtype_;
}
inline void AcrelData::set_vallowtype(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[1] |= 0x00000080u;
  vallowtype_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.valLowType)
}

// optional uint32 currHighType = 42;
inline bool AcrelData::has_currhightype() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void AcrelData::clear_currhightype() {
  currhightype_ = 0u;
  _has_bits_[1] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AcrelData::currhightype() const {
  // @@protoc_insertion_point(field_get:AcrelData.currHighType)
  return currhightype_;
}
inline void AcrelData::set_currhightype(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[1] |= 0x00000100u;
  currhightype_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.currHighType)
}

// optional uint32 ict = 43;
inline bool AcrelData::has_ict() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void AcrelData::clear_ict() {
  ict_ = 0u;
  _has_bits_[1] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AcrelData::ict() const {
  // @@protoc_insertion_point(field_get:AcrelData.ict)
  return ict_;
}
inline void AcrelData::set_ict(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[1] |= 0x00000200u;
  ict_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.ict)
}

// optional uint32 un = 44;
inline bool AcrelData::has_un() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void AcrelData::clear_un() {
  un_ = 0u;
  _has_bits_[1] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AcrelData::un() const {
  // @@protoc_insertion_point(field_get:AcrelData.un)
  return un_;
}
inline void AcrelData::set_un(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[1] |= 0x00000400u;
  un_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.un)
}

// optional uint32 in = 45;
inline bool AcrelData::has_in() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void AcrelData::clear_in() {
  in_ = 0u;
  _has_bits_[1] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AcrelData::in() const {
  // @@protoc_insertion_point(field_get:AcrelData.in)
  return in_;
}
inline void AcrelData::set_in(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[1] |= 0x00000800u;
  in_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.in)
}

// optional uint32 pt = 46;
inline bool AcrelData::has_pt() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void AcrelData::clear_pt() {
  pt_ = 0u;
  _has_bits_[1] &= ~0x00001000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AcrelData::pt() const {
  // @@protoc_insertion_point(field_get:AcrelData.pt)
  return pt_;
}
inline void AcrelData::set_pt(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[1] |= 0x00001000u;
  pt_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.pt)
}

// optional uint32 lineMode = 47;
inline bool AcrelData::has_linemode() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void AcrelData::clear_linemode() {
  linemode_ = 0u;
  _has_bits_[1] &= ~0x00002000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AcrelData::linemode() const {
  // @@protoc_insertion_point(field_get:AcrelData.lineMode)
  return linemode_;
}
inline void AcrelData::set_linemode(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[1] |= 0x00002000u;
  linemode_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.lineMode)
}

// optional uint32 lineOrder = 48;
inline bool AcrelData::has_lineorder() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void AcrelData::clear_lineorder() {
  lineorder_ = 0u;
  _has_bits_[1] &= ~0x00004000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AcrelData::lineorder() const {
  // @@protoc_insertion_point(field_get:AcrelData.lineOrder)
  return lineorder_;
}
inline void AcrelData::set_lineorder(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[1] |= 0x00004000u;
  lineorder_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.lineOrder)
}

// optional uint32 volFreq = 49;
inline bool AcrelData::has_volfreq() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void AcrelData::clear_volfreq() {
  volfreq_ = 0u;
  _has_bits_[1] &= ~0x00008000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AcrelData::volfreq() const {
  // @@protoc_insertion_point(field_get:AcrelData.volFreq)
  return volfreq_;
}
inline void AcrelData::set_volfreq(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[1] |= 0x00008000u;
  volfreq_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.volFreq)
}

// optional uint32 leakageDelay = 50;
inline bool AcrelData::has_leakagedelay() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void AcrelData::clear_leakagedelay() {
  leakagedelay_ = 0u;
  _has_bits_[1] &= ~0x00010000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AcrelData::leakagedelay() const {
  // @@protoc_insertion_point(field_get:AcrelData.leakageDelay)
  return leakagedelay_;
}
inline void AcrelData::set_leakagedelay(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[1] |= 0x00010000u;
  leakagedelay_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.leakageDelay)
}

// optional uint32 T1Delay = 51;
inline bool AcrelData::has_t1delay() const {
  return (_has_bits_[1] & 0x00020000u) != 0;
}
inline void AcrelData::clear_t1delay() {
  t1delay_ = 0u;
  _has_bits_[1] &= ~0x00020000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AcrelData::t1delay() const {
  // @@protoc_insertion_point(field_get:AcrelData.T1Delay)
  return t1delay_;
}
inline void AcrelData::set_t1delay(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[1] |= 0x00020000u;
  t1delay_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.T1Delay)
}

// optional uint32 T2Delay = 52;
inline bool AcrelData::has_t2delay() const {
  return (_has_bits_[1] & 0x00040000u) != 0;
}
inline void AcrelData::clear_t2delay() {
  t2delay_ = 0u;
  _has_bits_[1] &= ~0x00040000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AcrelData::t2delay() const {
  // @@protoc_insertion_point(field_get:AcrelData.T2Delay)
  return t2delay_;
}
inline void AcrelData::set_t2delay(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[1] |= 0x00040000u;
  t2delay_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.T2Delay)
}

// optional uint32 T3Delay = 53;
inline bool AcrelData::has_t3delay() const {
  return (_has_bits_[1] & 0x00080000u) != 0;
}
inline void AcrelData::clear_t3delay() {
  t3delay_ = 0u;
  _has_bits_[1] &= ~0x00080000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AcrelData::t3delay() const {
  // @@protoc_insertion_point(field_get:AcrelData.T3Delay)
  return t3delay_;
}
inline void AcrelData::set_t3delay(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[1] |= 0x00080000u;
  t3delay_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.T3Delay)
}

// optional uint32 T4Delay = 54;
inline bool AcrelData::has_t4delay() const {
  return (_has_bits_[1] & 0x00100000u) != 0;
}
inline void AcrelData::clear_t4delay() {
  t4delay_ = 0u;
  _has_bits_[1] &= ~0x00100000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AcrelData::t4delay() const {
  // @@protoc_insertion_point(field_get:AcrelData.T4Delay)
  return t4delay_;
}
inline void AcrelData::set_t4delay(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[1] |= 0x00100000u;
  t4delay_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.T4Delay)
}

// optional uint32 volHDelay = 55;
inline bool AcrelData::has_volhdelay() const {
  return (_has_bits_[1] & 0x00200000u) != 0;
}
inline void AcrelData::clear_volhdelay() {
  volhdelay_ = 0u;
  _has_bits_[1] &= ~0x00200000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AcrelData::volhdelay() const {
  // @@protoc_insertion_point(field_get:AcrelData.volHDelay)
  return volhdelay_;
}
inline void AcrelData::set_volhdelay(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[1] |= 0x00200000u;
  volhdelay_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.volHDelay)
}

// optional uint32 volLDelay = 56;
inline bool AcrelData::has_volldelay() const {
  return (_has_bits_[1] & 0x00400000u) != 0;
}
inline void AcrelData::clear_volldelay() {
  volldelay_ = 0u;
  _has_bits_[1] &= ~0x00400000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AcrelData::volldelay() const {
  // @@protoc_insertion_point(field_get:AcrelData.volLDelay)
  return volldelay_;
}
inline void AcrelData::set_volldelay(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[1] |= 0x00400000u;
  volldelay_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.volLDelay)
}

// optional uint32 currDelay = 57;
inline bool AcrelData::has_currdelay() const {
  return (_has_bits_[1] & 0x00800000u) != 0;
}
inline void AcrelData::clear_currdelay() {
  currdelay_ = 0u;
  _has_bits_[1] &= ~0x00800000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AcrelData::currdelay() const {
  // @@protoc_insertion_point(field_get:AcrelData.currDelay)
  return currdelay_;
}
inline void AcrelData::set_currdelay(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[1] |= 0x00800000u;
  currdelay_ = value;
  // @@protoc_insertion_point(field_set:AcrelData.currDelay)
}

// -------------------------------------------------------------------

// Baymax

// optional uint32 gasDevClass = 1;
inline bool Baymax::has_gasdevclass() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Baymax::clear_gasdevclass() {
  gasdevclass_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Baymax::gasdevclass() const {
  // @@protoc_insertion_point(field_get:Baymax.gasDevClass)
  return gasdevclass_;
}
inline void Baymax::set_gasdevclass(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  gasdevclass_ = value;
  // @@protoc_insertion_point(field_set:Baymax.gasDevClass)
}

// optional uint32 gasDensity = 2;
inline bool Baymax::has_gasdensity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Baymax::clear_gasdensity() {
  gasdensity_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Baymax::gasdensity() const {
  // @@protoc_insertion_point(field_get:Baymax.gasDensity)
  return gasdensity_;
}
inline void Baymax::set_gasdensity(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  gasdensity_ = value;
  // @@protoc_insertion_point(field_set:Baymax.gasDensity)
}

// optional uint32 gasDensityL1 = 3;
inline bool Baymax::has_gasdensityl1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Baymax::clear_gasdensityl1() {
  gasdensityl1_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Baymax::gasdensityl1() const {
  // @@protoc_insertion_point(field_get:Baymax.gasDensityL1)
  return gasdensityl1_;
}
inline void Baymax::set_gasdensityl1(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  gasdensityl1_ = value;
  // @@protoc_insertion_point(field_set:Baymax.gasDensityL1)
}

// optional uint32 gasDensityL2 = 4;
inline bool Baymax::has_gasdensityl2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Baymax::clear_gasdensityl2() {
  gasdensityl2_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Baymax::gasdensityl2() const {
  // @@protoc_insertion_point(field_get:Baymax.gasDensityL2)
  return gasdensityl2_;
}
inline void Baymax::set_gasdensityl2(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  gasdensityl2_ = value;
  // @@protoc_insertion_point(field_set:Baymax.gasDensityL2)
}

// optional uint32 gasDensityL3 = 5;
inline bool Baymax::has_gasdensityl3() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Baymax::clear_gasdensityl3() {
  gasdensityl3_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Baymax::gasdensityl3() const {
  // @@protoc_insertion_point(field_get:Baymax.gasDensityL3)
  return gasdensityl3_;
}
inline void Baymax::set_gasdensityl3(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  gasdensityl3_ = value;
  // @@protoc_insertion_point(field_set:Baymax.gasDensityL3)
}

// optional uint32 gasDisassembly = 6;
inline bool Baymax::has_gasdisassembly() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Baymax::clear_gasdisassembly() {
  gasdisassembly_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Baymax::gasdisassembly() const {
  // @@protoc_insertion_point(field_get:Baymax.gasDisassembly)
  return gasdisassembly_;
}
inline void Baymax::set_gasdisassembly(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  gasdisassembly_ = value;
  // @@protoc_insertion_point(field_set:Baymax.gasDisassembly)
}

// optional uint32 gasLosePwr = 7;
inline bool Baymax::has_gaslosepwr() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Baymax::clear_gaslosepwr() {
  gaslosepwr_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Baymax::gaslosepwr() const {
  // @@protoc_insertion_point(field_get:Baymax.gasLosePwr)
  return gaslosepwr_;
}
inline void Baymax::set_gaslosepwr(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  gaslosepwr_ = value;
  // @@protoc_insertion_point(field_set:Baymax.gasLosePwr)
}

// optional uint32 gasEMValve = 8;
inline bool Baymax::has_gasemvalve() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Baymax::clear_gasemvalve() {
  gasemvalve_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Baymax::gasemvalve() const {
  // @@protoc_insertion_point(field_get:Baymax.gasEMValve)
  return gasemvalve_;
}
inline void Baymax::set_gasemvalve(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  gasemvalve_ = value;
  // @@protoc_insertion_point(field_set:Baymax.gasEMValve)
}

// optional uint32 gasDeviceStatus = 9;
inline bool Baymax::has_gasdevicestatus() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Baymax::clear_gasdevicestatus() {
  gasdevicestatus_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Baymax::gasdevicestatus() const {
  // @@protoc_insertion_point(field_get:Baymax.gasDeviceStatus)
  return gasdevicestatus_;
}
inline void Baymax::set_gasdevicestatus(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000100u;
  gasdevicestatus_ = value;
  // @@protoc_insertion_point(field_set:Baymax.gasDeviceStatus)
}

// optional uint32 gasDeviceOpState = 10;
inline bool Baymax::has_gasdeviceopstate() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Baymax::clear_gasdeviceopstate() {
  gasdeviceopstate_ = 0u;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Baymax::gasdeviceopstate() const {
  // @@protoc_insertion_point(field_get:Baymax.gasDeviceOpState)
  return gasdeviceopstate_;
}
inline void Baymax::set_gasdeviceopstate(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000200u;
  gasdeviceopstate_ = value;
  // @@protoc_insertion_point(field_set:Baymax.gasDeviceOpState)
}

// optional uint32 gasDeviceComsDown = 11;
inline bool Baymax::has_gasdevicecomsdown() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Baymax::clear_gasdevicecomsdown() {
  gasdevicecomsdown_ = 0u;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Baymax::gasdevicecomsdown() const {
  // @@protoc_insertion_point(field_get:Baymax.gasDeviceComsDown)
  return gasdevicecomsdown_;
}
inline void Baymax::set_gasdevicecomsdown(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000400u;
  gasdevicecomsdown_ = value;
  // @@protoc_insertion_point(field_set:Baymax.gasDeviceComsDown)
}

// optional uint32 gasDeviceCMD = 12;
inline bool Baymax::has_gasdevicecmd() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Baymax::clear_gasdevicecmd() {
  gasdevicecmd_ = 0u;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Baymax::gasdevicecmd() const {
  // @@protoc_insertion_point(field_get:Baymax.gasDeviceCMD)
  return gasdevicecmd_;
}
inline void Baymax::set_gasdevicecmd(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000800u;
  gasdevicecmd_ = value;
  // @@protoc_insertion_point(field_set:Baymax.gasDeviceCMD)
}

// optional uint32 gasDeviceSilentMode = 13;
inline bool Baymax::has_gasdevicesilentmode() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Baymax::clear_gasdevicesilentmode() {
  gasdevicesilentmode_ = 0u;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Baymax::gasdevicesilentmode() const {
  // @@protoc_insertion_point(field_get:Baymax.gasDeviceSilentMode)
  return gasdevicesilentmode_;
}
inline void Baymax::set_gasdevicesilentmode(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00001000u;
  gasdevicesilentmode_ = value;
  // @@protoc_insertion_point(field_set:Baymax.gasDeviceSilentMode)
}

// -------------------------------------------------------------------

// MsgNode

// optional uint32 id = 1;
inline bool MsgNode::has_id() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void MsgNode::clear_id() {
  id_ = 0u;
  _has_bits_[1] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MsgNode::id() const {
  // @@protoc_insertion_point(field_get:MsgNode.id)
  return id_;
}
inline void MsgNode::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[1] |= 0x00000080u;
  id_ = value;
  // @@protoc_insertion_point(field_set:MsgNode.id)
}

// optional uint32 cmd = 2;
inline bool MsgNode::has_cmd() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void MsgNode::clear_cmd() {
  cmd_ = 0u;
  _has_bits_[1] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MsgNode::cmd() const {
  // @@protoc_insertion_point(field_get:MsgNode.cmd)
  return cmd_;
}
inline void MsgNode::set_cmd(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[1] |= 0x00000100u;
  cmd_ = value;
  // @@protoc_insertion_point(field_set:MsgNode.cmd)
}

// optional uint32 cmdRet = 3;
inline bool MsgNode::has_cmdret() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void MsgNode::clear_cmdret() {
  cmdret_ = 0u;
  _has_bits_[1] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MsgNode::cmdret() const {
  // @@protoc_insertion_point(field_get:MsgNode.cmdRet)
  return cmdret_;
}
inline void MsgNode::set_cmdret(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[1] |= 0x00000200u;
  cmdret_ = value;
  // @@protoc_insertion_point(field_set:MsgNode.cmdRet)
}

// optional .LpwanParam lpwanParam = 4;
inline bool MsgNode::has_lpwanparam() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgNode::clear_lpwanparam() {
  if (lpwanparam_ != nullptr) lpwanparam_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::LpwanParam& MsgNode::lpwanparam() const {
  const ::LpwanParam* p = lpwanparam_;
  // @@protoc_insertion_point(field_get:MsgNode.lpwanParam)
  return p != nullptr ? *p : *reinterpret_cast<const ::LpwanParam*>(
      &::_LpwanParam_default_instance_);
}
inline ::LpwanParam* MsgNode::release_lpwanparam() {
  // @@protoc_insertion_point(field_release:MsgNode.lpwanParam)
  _has_bits_[0] &= ~0x00000001u;
  ::LpwanParam* temp = lpwanparam_;
  lpwanparam_ = nullptr;
  return temp;
}
inline ::LpwanParam* MsgNode::mutable_lpwanparam() {
  _has_bits_[0] |= 0x00000001u;
  if (lpwanparam_ == nullptr) {
    auto* p = CreateMaybeMessage<::LpwanParam>(GetArenaNoVirtual());
    lpwanparam_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MsgNode.lpwanParam)
  return lpwanparam_;
}
inline void MsgNode::set_allocated_lpwanparam(::LpwanParam* lpwanparam) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete lpwanparam_;
  }
  if (lpwanparam) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      lpwanparam = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lpwanparam, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  lpwanparam_ = lpwanparam;
  // @@protoc_insertion_point(field_set_allocated:MsgNode.lpwanParam)
}

// optional .BleParam bleParam = 5;
inline bool MsgNode::has_bleparam() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgNode::clear_bleparam() {
  if (bleparam_ != nullptr) bleparam_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::BleParam& MsgNode::bleparam() const {
  const ::BleParam* p = bleparam_;
  // @@protoc_insertion_point(field_get:MsgNode.bleParam)
  return p != nullptr ? *p : *reinterpret_cast<const ::BleParam*>(
      &::_BleParam_default_instance_);
}
inline ::BleParam* MsgNode::release_bleparam() {
  // @@protoc_insertion_point(field_release:MsgNode.bleParam)
  _has_bits_[0] &= ~0x00000002u;
  ::BleParam* temp = bleparam_;
  bleparam_ = nullptr;
  return temp;
}
inline ::BleParam* MsgNode::mutable_bleparam() {
  _has_bits_[0] |= 0x00000002u;
  if (bleparam_ == nullptr) {
    auto* p = CreateMaybeMessage<::BleParam>(GetArenaNoVirtual());
    bleparam_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MsgNode.bleParam)
  return bleparam_;
}
inline void MsgNode::set_allocated_bleparam(::BleParam* bleparam) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete bleparam_;
  }
  if (bleparam) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      bleparam = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bleparam, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  bleparam_ = bleparam;
  // @@protoc_insertion_point(field_set_allocated:MsgNode.bleParam)
}

// optional .AppParam appParam = 6;
inline bool MsgNode::has_appparam() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgNode::clear_appparam() {
  if (appparam_ != nullptr) appparam_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::AppParam& MsgNode::appparam() const {
  const ::AppParam* p = appparam_;
  // @@protoc_insertion_point(field_get:MsgNode.appParam)
  return p != nullptr ? *p : *reinterpret_cast<const ::AppParam*>(
      &::_AppParam_default_instance_);
}
inline ::AppParam* MsgNode::release_appparam() {
  // @@protoc_insertion_point(field_release:MsgNode.appParam)
  _has_bits_[0] &= ~0x00000004u;
  ::AppParam* temp = appparam_;
  appparam_ = nullptr;
  return temp;
}
inline ::AppParam* MsgNode::mutable_appparam() {
  _has_bits_[0] |= 0x00000004u;
  if (appparam_ == nullptr) {
    auto* p = CreateMaybeMessage<::AppParam>(GetArenaNoVirtual());
    appparam_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MsgNode.appParam)
  return appparam_;
}
inline void MsgNode::set_allocated_appparam(::AppParam* appparam) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete appparam_;
  }
  if (appparam) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      appparam = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, appparam, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  appparam_ = appparam;
  // @@protoc_insertion_point(field_set_allocated:MsgNode.appParam)
}

// optional sint32 battery = 7;
inline bool MsgNode::has_battery() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void MsgNode::clear_battery() {
  battery_ = 0;
  _has_bits_[1] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MsgNode::battery() const {
  // @@protoc_insertion_point(field_get:MsgNode.battery)
  return battery_;
}
inline void MsgNode::set_battery(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[1] |= 0x00000400u;
  battery_ = value;
  // @@protoc_insertion_point(field_set:MsgNode.battery)
}

// optional .GpsData gps = 8;
inline bool MsgNode::has_gps() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgNode::clear_gps() {
  if (gps_ != nullptr) gps_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::GpsData& MsgNode::gps() const {
  const ::GpsData* p = gps_;
  // @@protoc_insertion_point(field_get:MsgNode.gps)
  return p != nullptr ? *p : *reinterpret_cast<const ::GpsData*>(
      &::_GpsData_default_instance_);
}
inline ::GpsData* MsgNode::release_gps() {
  // @@protoc_insertion_point(field_release:MsgNode.gps)
  _has_bits_[0] &= ~0x00000008u;
  ::GpsData* temp = gps_;
  gps_ = nullptr;
  return temp;
}
inline ::GpsData* MsgNode::mutable_gps() {
  _has_bits_[0] |= 0x00000008u;
  if (gps_ == nullptr) {
    auto* p = CreateMaybeMessage<::GpsData>(GetArenaNoVirtual());
    gps_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MsgNode.gps)
  return gps_;
}
inline void MsgNode::set_allocated_gps(::GpsData* gps) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete gps_;
  }
  if (gps) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      gps = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gps, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  gps_ = gps;
  // @@protoc_insertion_point(field_set_allocated:MsgNode.gps)
}

// optional .AxisData acceleration = 9;
inline bool MsgNode::has_acceleration() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MsgNode::clear_acceleration() {
  if (acceleration_ != nullptr) acceleration_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::AxisData& MsgNode::acceleration() const {
  const ::AxisData* p = acceleration_;
  // @@protoc_insertion_point(field_get:MsgNode.acceleration)
  return p != nullptr ? *p : *reinterpret_cast<const ::AxisData*>(
      &::_AxisData_default_instance_);
}
inline ::AxisData* MsgNode::release_acceleration() {
  // @@protoc_insertion_point(field_release:MsgNode.acceleration)
  _has_bits_[0] &= ~0x00000010u;
  ::AxisData* temp = acceleration_;
  acceleration_ = nullptr;
  return temp;
}
inline ::AxisData* MsgNode::mutable_acceleration() {
  _has_bits_[0] |= 0x00000010u;
  if (acceleration_ == nullptr) {
    auto* p = CreateMaybeMessage<::AxisData>(GetArenaNoVirtual());
    acceleration_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MsgNode.acceleration)
  return acceleration_;
}
inline void MsgNode::set_allocated_acceleration(::AxisData* acceleration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete acceleration_;
  }
  if (acceleration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      acceleration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, acceleration, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  acceleration_ = acceleration;
  // @@protoc_insertion_point(field_set_allocated:MsgNode.acceleration)
}

// optional .AxisData magnetism = 10;
inline bool MsgNode::has_magnetism() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MsgNode::clear_magnetism() {
  if (magnetism_ != nullptr) magnetism_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::AxisData& MsgNode::magnetism() const {
  const ::AxisData* p = magnetism_;
  // @@protoc_insertion_point(field_get:MsgNode.magnetism)
  return p != nullptr ? *p : *reinterpret_cast<const ::AxisData*>(
      &::_AxisData_default_instance_);
}
inline ::AxisData* MsgNode::release_magnetism() {
  // @@protoc_insertion_point(field_release:MsgNode.magnetism)
  _has_bits_[0] &= ~0x00000020u;
  ::AxisData* temp = magnetism_;
  magnetism_ = nullptr;
  return temp;
}
inline ::AxisData* MsgNode::mutable_magnetism() {
  _has_bits_[0] |= 0x00000020u;
  if (magnetism_ == nullptr) {
    auto* p = CreateMaybeMessage<::AxisData>(GetArenaNoVirtual());
    magnetism_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MsgNode.magnetism)
  return magnetism_;
}
inline void MsgNode::set_allocated_magnetism(::AxisData* magnetism) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete magnetism_;
  }
  if (magnetism) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      magnetism = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, magnetism, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  magnetism_ = magnetism;
  // @@protoc_insertion_point(field_set_allocated:MsgNode.magnetism)
}

// optional .AxisData gyroscope = 11;
inline bool MsgNode::has_gyroscope() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MsgNode::clear_gyroscope() {
  if (gyroscope_ != nullptr) gyroscope_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::AxisData& MsgNode::gyroscope() const {
  const ::AxisData* p = gyroscope_;
  // @@protoc_insertion_point(field_get:MsgNode.gyroscope)
  return p != nullptr ? *p : *reinterpret_cast<const ::AxisData*>(
      &::_AxisData_default_instance_);
}
inline ::AxisData* MsgNode::release_gyroscope() {
  // @@protoc_insertion_point(field_release:MsgNode.gyroscope)
  _has_bits_[0] &= ~0x00000040u;
  ::AxisData* temp = gyroscope_;
  gyroscope_ = nullptr;
  return temp;
}
inline ::AxisData* MsgNode::mutable_gyroscope() {
  _has_bits_[0] |= 0x00000040u;
  if (gyroscope_ == nullptr) {
    auto* p = CreateMaybeMessage<::AxisData>(GetArenaNoVirtual());
    gyroscope_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MsgNode.gyroscope)
  return gyroscope_;
}
inline void MsgNode::set_allocated_gyroscope(::AxisData* gyroscope) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete gyroscope_;
  }
  if (gyroscope) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      gyroscope = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gyroscope, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  gyroscope_ = gyroscope;
  // @@protoc_insertion_point(field_set_allocated:MsgNode.gyroscope)
}

// optional .SensorData temperature = 12;
inline bool MsgNode::has_temperature() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MsgNode::clear_temperature() {
  if (temperature_ != nullptr) temperature_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::SensorData& MsgNode::temperature() const {
  const ::SensorData* p = temperature_;
  // @@protoc_insertion_point(field_get:MsgNode.temperature)
  return p != nullptr ? *p : *reinterpret_cast<const ::SensorData*>(
      &::_SensorData_default_instance_);
}
inline ::SensorData* MsgNode::release_temperature() {
  // @@protoc_insertion_point(field_release:MsgNode.temperature)
  _has_bits_[0] &= ~0x00000080u;
  ::SensorData* temp = temperature_;
  temperature_ = nullptr;
  return temp;
}
inline ::SensorData* MsgNode::mutable_temperature() {
  _has_bits_[0] |= 0x00000080u;
  if (temperature_ == nullptr) {
    auto* p = CreateMaybeMessage<::SensorData>(GetArenaNoVirtual());
    temperature_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MsgNode.temperature)
  return temperature_;
}
inline void MsgNode::set_allocated_temperature(::SensorData* temperature) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete temperature_;
  }
  if (temperature) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      temperature = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, temperature, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  temperature_ = temperature;
  // @@protoc_insertion_point(field_set_allocated:MsgNode.temperature)
}

// optional .SensorData humidity = 13;
inline bool MsgNode::has_humidity() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MsgNode::clear_humidity() {
  if (humidity_ != nullptr) humidity_->Clear();
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::SensorData& MsgNode::humidity() const {
  const ::SensorData* p = humidity_;
  // @@protoc_insertion_point(field_get:MsgNode.humidity)
  return p != nullptr ? *p : *reinterpret_cast<const ::SensorData*>(
      &::_SensorData_default_instance_);
}
inline ::SensorData* MsgNode::release_humidity() {
  // @@protoc_insertion_point(field_release:MsgNode.humidity)
  _has_bits_[0] &= ~0x00000100u;
  ::SensorData* temp = humidity_;
  humidity_ = nullptr;
  return temp;
}
inline ::SensorData* MsgNode::mutable_humidity() {
  _has_bits_[0] |= 0x00000100u;
  if (humidity_ == nullptr) {
    auto* p = CreateMaybeMessage<::SensorData>(GetArenaNoVirtual());
    humidity_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MsgNode.humidity)
  return humidity_;
}
inline void MsgNode::set_allocated_humidity(::SensorData* humidity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete humidity_;
  }
  if (humidity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      humidity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, humidity, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  humidity_ = humidity;
  // @@protoc_insertion_point(field_set_allocated:MsgNode.humidity)
}

// optional .SensorData light = 14;
inline bool MsgNode::has_light() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MsgNode::clear_light() {
  if (light_ != nullptr) light_->Clear();
  _has_bits_[0] &= ~0x00000200u;
}
inline const ::SensorData& MsgNode::light() const {
  const ::SensorData* p = light_;
  // @@protoc_insertion_point(field_get:MsgNode.light)
  return p != nullptr ? *p : *reinterpret_cast<const ::SensorData*>(
      &::_SensorData_default_instance_);
}
inline ::SensorData* MsgNode::release_light() {
  // @@protoc_insertion_point(field_release:MsgNode.light)
  _has_bits_[0] &= ~0x00000200u;
  ::SensorData* temp = light_;
  light_ = nullptr;
  return temp;
}
inline ::SensorData* MsgNode::mutable_light() {
  _has_bits_[0] |= 0x00000200u;
  if (light_ == nullptr) {
    auto* p = CreateMaybeMessage<::SensorData>(GetArenaNoVirtual());
    light_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MsgNode.light)
  return light_;
}
inline void MsgNode::set_allocated_light(::SensorData* light) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete light_;
  }
  if (light) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      light = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, light, submessage_arena);
    }
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  light_ = light;
  // @@protoc_insertion_point(field_set_allocated:MsgNode.light)
}

// optional .SensorData leak = 15;
inline bool MsgNode::has_leak() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MsgNode::clear_leak() {
  if (leak_ != nullptr) leak_->Clear();
  _has_bits_[0] &= ~0x00000400u;
}
inline const ::SensorData& MsgNode::leak() const {
  const ::SensorData* p = leak_;
  // @@protoc_insertion_point(field_get:MsgNode.leak)
  return p != nullptr ? *p : *reinterpret_cast<const ::SensorData*>(
      &::_SensorData_default_instance_);
}
inline ::SensorData* MsgNode::release_leak() {
  // @@protoc_insertion_point(field_release:MsgNode.leak)
  _has_bits_[0] &= ~0x00000400u;
  ::SensorData* temp = leak_;
  leak_ = nullptr;
  return temp;
}
inline ::SensorData* MsgNode::mutable_leak() {
  _has_bits_[0] |= 0x00000400u;
  if (leak_ == nullptr) {
    auto* p = CreateMaybeMessage<::SensorData>(GetArenaNoVirtual());
    leak_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MsgNode.leak)
  return leak_;
}
inline void MsgNode::set_allocated_leak(::SensorData* leak) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete leak_;
  }
  if (leak) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      leak = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, leak, submessage_arena);
    }
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  leak_ = leak;
  // @@protoc_insertion_point(field_set_allocated:MsgNode.leak)
}

// optional .SensorData co = 16;
inline bool MsgNode::has_co() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MsgNode::clear_co() {
  if (co_ != nullptr) co_->Clear();
  _has_bits_[0] &= ~0x00000800u;
}
inline const ::SensorData& MsgNode::co() const {
  const ::SensorData* p = co_;
  // @@protoc_insertion_point(field_get:MsgNode.co)
  return p != nullptr ? *p : *reinterpret_cast<const ::SensorData*>(
      &::_SensorData_default_instance_);
}
inline ::SensorData* MsgNode::release_co() {
  // @@protoc_insertion_point(field_release:MsgNode.co)
  _has_bits_[0] &= ~0x00000800u;
  ::SensorData* temp = co_;
  co_ = nullptr;
  return temp;
}
inline ::SensorData* MsgNode::mutable_co() {
  _has_bits_[0] |= 0x00000800u;
  if (co_ == nullptr) {
    auto* p = CreateMaybeMessage<::SensorData>(GetArenaNoVirtual());
    co_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MsgNode.co)
  return co_;
}
inline void MsgNode::set_allocated_co(::SensorData* co) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete co_;
  }
  if (co) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      co = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, co, submessage_arena);
    }
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  co_ = co;
  // @@protoc_insertion_point(field_set_allocated:MsgNode.co)
}

// optional .SensorData co2 = 17;
inline bool MsgNode::has_co2() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MsgNode::clear_co2() {
  if (co2_ != nullptr) co2_->Clear();
  _has_bits_[0] &= ~0x00001000u;
}
inline const ::SensorData& MsgNode::co2() const {
  const ::SensorData* p = co2_;
  // @@protoc_insertion_point(field_get:MsgNode.co2)
  return p != nullptr ? *p : *reinterpret_cast<const ::SensorData*>(
      &::_SensorData_default_instance_);
}
inline ::SensorData* MsgNode::release_co2() {
  // @@protoc_insertion_point(field_release:MsgNode.co2)
  _has_bits_[0] &= ~0x00001000u;
  ::SensorData* temp = co2_;
  co2_ = nullptr;
  return temp;
}
inline ::SensorData* MsgNode::mutable_co2() {
  _has_bits_[0] |= 0x00001000u;
  if (co2_ == nullptr) {
    auto* p = CreateMaybeMessage<::SensorData>(GetArenaNoVirtual());
    co2_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MsgNode.co2)
  return co2_;
}
inline void MsgNode::set_allocated_co2(::SensorData* co2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete co2_;
  }
  if (co2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      co2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, co2, submessage_arena);
    }
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  co2_ = co2;
  // @@protoc_insertion_point(field_set_allocated:MsgNode.co2)
}

// optional .SensorData so2 = 18;
inline bool MsgNode::has_so2() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MsgNode::clear_so2() {
  if (so2_ != nullptr) so2_->Clear();
  _has_bits_[0] &= ~0x00002000u;
}
inline const ::SensorData& MsgNode::so2() const {
  const ::SensorData* p = so2_;
  // @@protoc_insertion_point(field_get:MsgNode.so2)
  return p != nullptr ? *p : *reinterpret_cast<const ::SensorData*>(
      &::_SensorData_default_instance_);
}
inline ::SensorData* MsgNode::release_so2() {
  // @@protoc_insertion_point(field_release:MsgNode.so2)
  _has_bits_[0] &= ~0x00002000u;
  ::SensorData* temp = so2_;
  so2_ = nullptr;
  return temp;
}
inline ::SensorData* MsgNode::mutable_so2() {
  _has_bits_[0] |= 0x00002000u;
  if (so2_ == nullptr) {
    auto* p = CreateMaybeMessage<::SensorData>(GetArenaNoVirtual());
    so2_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MsgNode.so2)
  return so2_;
}
inline void MsgNode::set_allocated_so2(::SensorData* so2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete so2_;
  }
  if (so2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      so2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, so2, submessage_arena);
    }
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  so2_ = so2;
  // @@protoc_insertion_point(field_set_allocated:MsgNode.so2)
}

// optional .SensorData no2 = 19;
inline bool MsgNode::has_no2() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void MsgNode::clear_no2() {
  if (no2_ != nullptr) no2_->Clear();
  _has_bits_[0] &= ~0x00004000u;
}
inline const ::SensorData& MsgNode::no2() const {
  const ::SensorData* p = no2_;
  // @@protoc_insertion_point(field_get:MsgNode.no2)
  return p != nullptr ? *p : *reinterpret_cast<const ::SensorData*>(
      &::_SensorData_default_instance_);
}
inline ::SensorData* MsgNode::release_no2() {
  // @@protoc_insertion_point(field_release:MsgNode.no2)
  _has_bits_[0] &= ~0x00004000u;
  ::SensorData* temp = no2_;
  no2_ = nullptr;
  return temp;
}
inline ::SensorData* MsgNode::mutable_no2() {
  _has_bits_[0] |= 0x00004000u;
  if (no2_ == nullptr) {
    auto* p = CreateMaybeMessage<::SensorData>(GetArenaNoVirtual());
    no2_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MsgNode.no2)
  return no2_;
}
inline void MsgNode::set_allocated_no2(::SensorData* no2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete no2_;
  }
  if (no2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      no2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, no2, submessage_arena);
    }
    _has_bits_[0] |= 0x00004000u;
  } else {
    _has_bits_[0] &= ~0x00004000u;
  }
  no2_ = no2;
  // @@protoc_insertion_point(field_set_allocated:MsgNode.no2)
}

// optional .SensorData ch4 = 20;
inline bool MsgNode::has_ch4() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void MsgNode::clear_ch4() {
  if (ch4_ != nullptr) ch4_->Clear();
  _has_bits_[0] &= ~0x00008000u;
}
inline const ::SensorData& MsgNode::ch4() const {
  const ::SensorData* p = ch4_;
  // @@protoc_insertion_point(field_get:MsgNode.ch4)
  return p != nullptr ? *p : *reinterpret_cast<const ::SensorData*>(
      &::_SensorData_default_instance_);
}
inline ::SensorData* MsgNode::release_ch4() {
  // @@protoc_insertion_point(field_release:MsgNode.ch4)
  _has_bits_[0] &= ~0x00008000u;
  ::SensorData* temp = ch4_;
  ch4_ = nullptr;
  return temp;
}
inline ::SensorData* MsgNode::mutable_ch4() {
  _has_bits_[0] |= 0x00008000u;
  if (ch4_ == nullptr) {
    auto* p = CreateMaybeMessage<::SensorData>(GetArenaNoVirtual());
    ch4_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MsgNode.ch4)
  return ch4_;
}
inline void MsgNode::set_allocated_ch4(::SensorData* ch4) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete ch4_;
  }
  if (ch4) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ch4 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ch4, submessage_arena);
    }
    _has_bits_[0] |= 0x00008000u;
  } else {
    _has_bits_[0] &= ~0x00008000u;
  }
  ch4_ = ch4;
  // @@protoc_insertion_point(field_set_allocated:MsgNode.ch4)
}

// optional .SensorData ch2o = 21;
inline bool MsgNode::has_ch2o() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void MsgNode::clear_ch2o() {
  if (ch2o_ != nullptr) ch2o_->Clear();
  _has_bits_[0] &= ~0x00010000u;
}
inline const ::SensorData& MsgNode::ch2o() const {
  const ::SensorData* p = ch2o_;
  // @@protoc_insertion_point(field_get:MsgNode.ch2o)
  return p != nullptr ? *p : *reinterpret_cast<const ::SensorData*>(
      &::_SensorData_default_instance_);
}
inline ::SensorData* MsgNode::release_ch2o() {
  // @@protoc_insertion_point(field_release:MsgNode.ch2o)
  _has_bits_[0] &= ~0x00010000u;
  ::SensorData* temp = ch2o_;
  ch2o_ = nullptr;
  return temp;
}
inline ::SensorData* MsgNode::mutable_ch2o() {
  _has_bits_[0] |= 0x00010000u;
  if (ch2o_ == nullptr) {
    auto* p = CreateMaybeMessage<::SensorData>(GetArenaNoVirtual());
    ch2o_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MsgNode.ch2o)
  return ch2o_;
}
inline void MsgNode::set_allocated_ch2o(::SensorData* ch2o) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete ch2o_;
  }
  if (ch2o) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ch2o = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ch2o, submessage_arena);
    }
    _has_bits_[0] |= 0x00010000u;
  } else {
    _has_bits_[0] &= ~0x00010000u;
  }
  ch2o_ = ch2o;
  // @@protoc_insertion_point(field_set_allocated:MsgNode.ch2o)
}

// optional .SensorData lpg = 22;
inline bool MsgNode::has_lpg() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void MsgNode::clear_lpg() {
  if (lpg_ != nullptr) lpg_->Clear();
  _has_bits_[0] &= ~0x00020000u;
}
inline const ::SensorData& MsgNode::lpg() const {
  const ::SensorData* p = lpg_;
  // @@protoc_insertion_point(field_get:MsgNode.lpg)
  return p != nullptr ? *p : *reinterpret_cast<const ::SensorData*>(
      &::_SensorData_default_instance_);
}
inline ::SensorData* MsgNode::release_lpg() {
  // @@protoc_insertion_point(field_release:MsgNode.lpg)
  _has_bits_[0] &= ~0x00020000u;
  ::SensorData* temp = lpg_;
  lpg_ = nullptr;
  return temp;
}
inline ::SensorData* MsgNode::mutable_lpg() {
  _has_bits_[0] |= 0x00020000u;
  if (lpg_ == nullptr) {
    auto* p = CreateMaybeMessage<::SensorData>(GetArenaNoVirtual());
    lpg_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MsgNode.lpg)
  return lpg_;
}
inline void MsgNode::set_allocated_lpg(::SensorData* lpg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete lpg_;
  }
  if (lpg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      lpg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lpg, submessage_arena);
    }
    _has_bits_[0] |= 0x00020000u;
  } else {
    _has_bits_[0] &= ~0x00020000u;
  }
  lpg_ = lpg;
  // @@protoc_insertion_point(field_set_allocated:MsgNode.lpg)
}

// optional .SensorData o3 = 23;
inline bool MsgNode::has_o3() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void MsgNode::clear_o3() {
  if (o3_ != nullptr) o3_->Clear();
  _has_bits_[0] &= ~0x00040000u;
}
inline const ::SensorData& MsgNode::o3() const {
  const ::SensorData* p = o3_;
  // @@protoc_insertion_point(field_get:MsgNode.o3)
  return p != nullptr ? *p : *reinterpret_cast<const ::SensorData*>(
      &::_SensorData_default_instance_);
}
inline ::SensorData* MsgNode::release_o3() {
  // @@protoc_insertion_point(field_release:MsgNode.o3)
  _has_bits_[0] &= ~0x00040000u;
  ::SensorData* temp = o3_;
  o3_ = nullptr;
  return temp;
}
inline ::SensorData* MsgNode::mutable_o3() {
  _has_bits_[0] |= 0x00040000u;
  if (o3_ == nullptr) {
    auto* p = CreateMaybeMessage<::SensorData>(GetArenaNoVirtual());
    o3_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MsgNode.o3)
  return o3_;
}
inline void MsgNode::set_allocated_o3(::SensorData* o3) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete o3_;
  }
  if (o3) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      o3 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, o3, submessage_arena);
    }
    _has_bits_[0] |= 0x00040000u;
  } else {
    _has_bits_[0] &= ~0x00040000u;
  }
  o3_ = o3;
  // @@protoc_insertion_point(field_set_allocated:MsgNode.o3)
}

// optional .SensorData pm1 = 24;
inline bool MsgNode::has_pm1() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void MsgNode::clear_pm1() {
  if (pm1_ != nullptr) pm1_->Clear();
  _has_bits_[0] &= ~0x00080000u;
}
inline const ::SensorData& MsgNode::pm1() const {
  const ::SensorData* p = pm1_;
  // @@protoc_insertion_point(field_get:MsgNode.pm1)
  return p != nullptr ? *p : *reinterpret_cast<const ::SensorData*>(
      &::_SensorData_default_instance_);
}
inline ::SensorData* MsgNode::release_pm1() {
  // @@protoc_insertion_point(field_release:MsgNode.pm1)
  _has_bits_[0] &= ~0x00080000u;
  ::SensorData* temp = pm1_;
  pm1_ = nullptr;
  return temp;
}
inline ::SensorData* MsgNode::mutable_pm1() {
  _has_bits_[0] |= 0x00080000u;
  if (pm1_ == nullptr) {
    auto* p = CreateMaybeMessage<::SensorData>(GetArenaNoVirtual());
    pm1_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MsgNode.pm1)
  return pm1_;
}
inline void MsgNode::set_allocated_pm1(::SensorData* pm1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete pm1_;
  }
  if (pm1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      pm1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pm1, submessage_arena);
    }
    _has_bits_[0] |= 0x00080000u;
  } else {
    _has_bits_[0] &= ~0x00080000u;
  }
  pm1_ = pm1;
  // @@protoc_insertion_point(field_set_allocated:MsgNode.pm1)
}

// optional .SensorData pm2_5 = 25;
inline bool MsgNode::has_pm2_5() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void MsgNode::clear_pm2_5() {
  if (pm2_5_ != nullptr) pm2_5_->Clear();
  _has_bits_[0] &= ~0x00100000u;
}
inline const ::SensorData& MsgNode::pm2_5() const {
  const ::SensorData* p = pm2_5_;
  // @@protoc_insertion_point(field_get:MsgNode.pm2_5)
  return p != nullptr ? *p : *reinterpret_cast<const ::SensorData*>(
      &::_SensorData_default_instance_);
}
inline ::SensorData* MsgNode::release_pm2_5() {
  // @@protoc_insertion_point(field_release:MsgNode.pm2_5)
  _has_bits_[0] &= ~0x00100000u;
  ::SensorData* temp = pm2_5_;
  pm2_5_ = nullptr;
  return temp;
}
inline ::SensorData* MsgNode::mutable_pm2_5() {
  _has_bits_[0] |= 0x00100000u;
  if (pm2_5_ == nullptr) {
    auto* p = CreateMaybeMessage<::SensorData>(GetArenaNoVirtual());
    pm2_5_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MsgNode.pm2_5)
  return pm2_5_;
}
inline void MsgNode::set_allocated_pm2_5(::SensorData* pm2_5) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete pm2_5_;
  }
  if (pm2_5) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      pm2_5 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pm2_5, submessage_arena);
    }
    _has_bits_[0] |= 0x00100000u;
  } else {
    _has_bits_[0] &= ~0x00100000u;
  }
  pm2_5_ = pm2_5;
  // @@protoc_insertion_point(field_set_allocated:MsgNode.pm2_5)
}

// optional .SensorData pm10 = 26;
inline bool MsgNode::has_pm10() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void MsgNode::clear_pm10() {
  if (pm10_ != nullptr) pm10_->Clear();
  _has_bits_[0] &= ~0x00200000u;
}
inline const ::SensorData& MsgNode::pm10() const {
  const ::SensorData* p = pm10_;
  // @@protoc_insertion_point(field_get:MsgNode.pm10)
  return p != nullptr ? *p : *reinterpret_cast<const ::SensorData*>(
      &::_SensorData_default_instance_);
}
inline ::SensorData* MsgNode::release_pm10() {
  // @@protoc_insertion_point(field_release:MsgNode.pm10)
  _has_bits_[0] &= ~0x00200000u;
  ::SensorData* temp = pm10_;
  pm10_ = nullptr;
  return temp;
}
inline ::SensorData* MsgNode::mutable_pm10() {
  _has_bits_[0] |= 0x00200000u;
  if (pm10_ == nullptr) {
    auto* p = CreateMaybeMessage<::SensorData>(GetArenaNoVirtual());
    pm10_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MsgNode.pm10)
  return pm10_;
}
inline void MsgNode::set_allocated_pm10(::SensorData* pm10) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete pm10_;
  }
  if (pm10) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      pm10 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pm10, submessage_arena);
    }
    _has_bits_[0] |= 0x00200000u;
  } else {
    _has_bits_[0] &= ~0x00200000u;
  }
  pm10_ = pm10;
  // @@protoc_insertion_point(field_set_allocated:MsgNode.pm10)
}

// optional .SensorData angle = 27;
inline bool MsgNode::has_angle() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void MsgNode::clear_angle() {
  if (angle_ != nullptr) angle_->Clear();
  _has_bits_[0] &= ~0x00400000u;
}
inline const ::SensorData& MsgNode::angle() const {
  const ::SensorData* p = angle_;
  // @@protoc_insertion_point(field_get:MsgNode.angle)
  return p != nullptr ? *p : *reinterpret_cast<const ::SensorData*>(
      &::_SensorData_default_instance_);
}
inline ::SensorData* MsgNode::release_angle() {
  // @@protoc_insertion_point(field_release:MsgNode.angle)
  _has_bits_[0] &= ~0x00400000u;
  ::SensorData* temp = angle_;
  angle_ = nullptr;
  return temp;
}
inline ::SensorData* MsgNode::mutable_angle() {
  _has_bits_[0] |= 0x00400000u;
  if (angle_ == nullptr) {
    auto* p = CreateMaybeMessage<::SensorData>(GetArenaNoVirtual());
    angle_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MsgNode.angle)
  return angle_;
}
inline void MsgNode::set_allocated_angle(::SensorData* angle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete angle_;
  }
  if (angle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      angle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, angle, submessage_arena);
    }
    _has_bits_[0] |= 0x00400000u;
  } else {
    _has_bits_[0] &= ~0x00400000u;
  }
  angle_ = angle;
  // @@protoc_insertion_point(field_set_allocated:MsgNode.angle)
}

// optional .SensorData cover = 28;
inline bool MsgNode::has_cover() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void MsgNode::clear_cover() {
  if (cover_ != nullptr) cover_->Clear();
  _has_bits_[0] &= ~0x00800000u;
}
inline const ::SensorData& MsgNode::cover() const {
  const ::SensorData* p = cover_;
  // @@protoc_insertion_point(field_get:MsgNode.cover)
  return p != nullptr ? *p : *reinterpret_cast<const ::SensorData*>(
      &::_SensorData_default_instance_);
}
inline ::SensorData* MsgNode::release_cover() {
  // @@protoc_insertion_point(field_release:MsgNode.cover)
  _has_bits_[0] &= ~0x00800000u;
  ::SensorData* temp = cover_;
  cover_ = nullptr;
  return temp;
}
inline ::SensorData* MsgNode::mutable_cover() {
  _has_bits_[0] |= 0x00800000u;
  if (cover_ == nullptr) {
    auto* p = CreateMaybeMessage<::SensorData>(GetArenaNoVirtual());
    cover_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MsgNode.cover)
  return cover_;
}
inline void MsgNode::set_allocated_cover(::SensorData* cover) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete cover_;
  }
  if (cover) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      cover = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cover, submessage_arena);
    }
    _has_bits_[0] |= 0x00800000u;
  } else {
    _has_bits_[0] &= ~0x00800000u;
  }
  cover_ = cover;
  // @@protoc_insertion_point(field_set_allocated:MsgNode.cover)
}

// optional .SensorData level = 29;
inline bool MsgNode::has_level() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void MsgNode::clear_level() {
  if (level_ != nullptr) level_->Clear();
  _has_bits_[0] &= ~0x01000000u;
}
inline const ::SensorData& MsgNode::level() const {
  const ::SensorData* p = level_;
  // @@protoc_insertion_point(field_get:MsgNode.level)
  return p != nullptr ? *p : *reinterpret_cast<const ::SensorData*>(
      &::_SensorData_default_instance_);
}
inline ::SensorData* MsgNode::release_level() {
  // @@protoc_insertion_point(field_release:MsgNode.level)
  _has_bits_[0] &= ~0x01000000u;
  ::SensorData* temp = level_;
  level_ = nullptr;
  return temp;
}
inline ::SensorData* MsgNode::mutable_level() {
  _has_bits_[0] |= 0x01000000u;
  if (level_ == nullptr) {
    auto* p = CreateMaybeMessage<::SensorData>(GetArenaNoVirtual());
    level_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MsgNode.level)
  return level_;
}
inline void MsgNode::set_allocated_level(::SensorData* level) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete level_;
  }
  if (level) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      level = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, level, submessage_arena);
    }
    _has_bits_[0] |= 0x01000000u;
  } else {
    _has_bits_[0] &= ~0x01000000u;
  }
  level_ = level;
  // @@protoc_insertion_point(field_set_allocated:MsgNode.level)
}

// optional .SensorData smoke = 30;
inline bool MsgNode::has_smoke() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void MsgNode::clear_smoke() {
  if (smoke_ != nullptr) smoke_->Clear();
  _has_bits_[0] &= ~0x02000000u;
}
inline const ::SensorData& MsgNode::smoke() const {
  const ::SensorData* p = smoke_;
  // @@protoc_insertion_point(field_get:MsgNode.smoke)
  return p != nullptr ? *p : *reinterpret_cast<const ::SensorData*>(
      &::_SensorData_default_instance_);
}
inline ::SensorData* MsgNode::release_smoke() {
  // @@protoc_insertion_point(field_release:MsgNode.smoke)
  _has_bits_[0] &= ~0x02000000u;
  ::SensorData* temp = smoke_;
  smoke_ = nullptr;
  return temp;
}
inline ::SensorData* MsgNode::mutable_smoke() {
  _has_bits_[0] |= 0x02000000u;
  if (smoke_ == nullptr) {
    auto* p = CreateMaybeMessage<::SensorData>(GetArenaNoVirtual());
    smoke_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MsgNode.smoke)
  return smoke_;
}
inline void MsgNode::set_allocated_smoke(::SensorData* smoke) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete smoke_;
  }
  if (smoke) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      smoke = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, smoke, submessage_arena);
    }
    _has_bits_[0] |= 0x02000000u;
  } else {
    _has_bits_[0] &= ~0x02000000u;
  }
  smoke_ = smoke;
  // @@protoc_insertion_point(field_set_allocated:MsgNode.smoke)
}

// optional .SensorData pitch = 31;
inline bool MsgNode::has_pitch() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void MsgNode::clear_pitch() {
  if (pitch_ != nullptr) pitch_->Clear();
  _has_bits_[0] &= ~0x04000000u;
}
inline const ::SensorData& MsgNode::pitch() const {
  const ::SensorData* p = pitch_;
  // @@protoc_insertion_point(field_get:MsgNode.pitch)
  return p != nullptr ? *p : *reinterpret_cast<const ::SensorData*>(
      &::_SensorData_default_instance_);
}
inline ::SensorData* MsgNode::release_pitch() {
  // @@protoc_insertion_point(field_release:MsgNode.pitch)
  _has_bits_[0] &= ~0x04000000u;
  ::SensorData* temp = pitch_;
  pitch_ = nullptr;
  return temp;
}
inline ::SensorData* MsgNode::mutable_pitch() {
  _has_bits_[0] |= 0x04000000u;
  if (pitch_ == nullptr) {
    auto* p = CreateMaybeMessage<::SensorData>(GetArenaNoVirtual());
    pitch_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MsgNode.pitch)
  return pitch_;
}
inline void MsgNode::set_allocated_pitch(::SensorData* pitch) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete pitch_;
  }
  if (pitch) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      pitch = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pitch, submessage_arena);
    }
    _has_bits_[0] |= 0x04000000u;
  } else {
    _has_bits_[0] &= ~0x04000000u;
  }
  pitch_ = pitch;
  // @@protoc_insertion_point(field_set_allocated:MsgNode.pitch)
}

// optional .SensorData roll = 32;
inline bool MsgNode::has_roll() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void MsgNode::clear_roll() {
  if (roll_ != nullptr) roll_->Clear();
  _has_bits_[0] &= ~0x08000000u;
}
inline const ::SensorData& MsgNode::roll() const {
  const ::SensorData* p = roll_;
  // @@protoc_insertion_point(field_get:MsgNode.roll)
  return p != nullptr ? *p : *reinterpret_cast<const ::SensorData*>(
      &::_SensorData_default_instance_);
}
inline ::SensorData* MsgNode::release_roll() {
  // @@protoc_insertion_point(field_release:MsgNode.roll)
  _has_bits_[0] &= ~0x08000000u;
  ::SensorData* temp = roll_;
  roll_ = nullptr;
  return temp;
}
inline ::SensorData* MsgNode::mutable_roll() {
  _has_bits_[0] |= 0x08000000u;
  if (roll_ == nullptr) {
    auto* p = CreateMaybeMessage<::SensorData>(GetArenaNoVirtual());
    roll_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MsgNode.roll)
  return roll_;
}
inline void MsgNode::set_allocated_roll(::SensorData* roll) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete roll_;
  }
  if (roll) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      roll = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, roll, submessage_arena);
    }
    _has_bits_[0] |= 0x08000000u;
  } else {
    _has_bits_[0] &= ~0x08000000u;
  }
  roll_ = roll;
  // @@protoc_insertion_point(field_set_allocated:MsgNode.roll)
}

// optional .SensorData yaw = 33;
inline bool MsgNode::has_yaw() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void MsgNode::clear_yaw() {
  if (yaw_ != nullptr) yaw_->Clear();
  _has_bits_[0] &= ~0x10000000u;
}
inline const ::SensorData& MsgNode::yaw() const {
  const ::SensorData* p = yaw_;
  // @@protoc_insertion_point(field_get:MsgNode.yaw)
  return p != nullptr ? *p : *reinterpret_cast<const ::SensorData*>(
      &::_SensorData_default_instance_);
}
inline ::SensorData* MsgNode::release_yaw() {
  // @@protoc_insertion_point(field_release:MsgNode.yaw)
  _has_bits_[0] &= ~0x10000000u;
  ::SensorData* temp = yaw_;
  yaw_ = nullptr;
  return temp;
}
inline ::SensorData* MsgNode::mutable_yaw() {
  _has_bits_[0] |= 0x10000000u;
  if (yaw_ == nullptr) {
    auto* p = CreateMaybeMessage<::SensorData>(GetArenaNoVirtual());
    yaw_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MsgNode.yaw)
  return yaw_;
}
inline void MsgNode::set_allocated_yaw(::SensorData* yaw) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete yaw_;
  }
  if (yaw) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      yaw = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, yaw, submessage_arena);
    }
    _has_bits_[0] |= 0x10000000u;
  } else {
    _has_bits_[0] &= ~0x10000000u;
  }
  yaw_ = yaw;
  // @@protoc_insertion_point(field_set_allocated:MsgNode.yaw)
}

// optional .SensorDataInt flame = 34;
inline bool MsgNode::has_flame() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void MsgNode::clear_flame() {
  if (flame_ != nullptr) flame_->Clear();
  _has_bits_[0] &= ~0x20000000u;
}
inline const ::SensorDataInt& MsgNode::flame() const {
  const ::SensorDataInt* p = flame_;
  // @@protoc_insertion_point(field_get:MsgNode.flame)
  return p != nullptr ? *p : *reinterpret_cast<const ::SensorDataInt*>(
      &::_SensorDataInt_default_instance_);
}
inline ::SensorDataInt* MsgNode::release_flame() {
  // @@protoc_insertion_point(field_release:MsgNode.flame)
  _has_bits_[0] &= ~0x20000000u;
  ::SensorDataInt* temp = flame_;
  flame_ = nullptr;
  return temp;
}
inline ::SensorDataInt* MsgNode::mutable_flame() {
  _has_bits_[0] |= 0x20000000u;
  if (flame_ == nullptr) {
    auto* p = CreateMaybeMessage<::SensorDataInt>(GetArenaNoVirtual());
    flame_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MsgNode.flame)
  return flame_;
}
inline void MsgNode::set_allocated_flame(::SensorDataInt* flame) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete flame_;
  }
  if (flame) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      flame = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, flame, submessage_arena);
    }
    _has_bits_[0] |= 0x20000000u;
  } else {
    _has_bits_[0] &= ~0x20000000u;
  }
  flame_ = flame;
  // @@protoc_insertion_point(field_set_allocated:MsgNode.flame)
}

// optional .SensorData artificialGas = 35;
inline bool MsgNode::has_artificialgas() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void MsgNode::clear_artificialgas() {
  if (artificialgas_ != nullptr) artificialgas_->Clear();
  _has_bits_[0] &= ~0x40000000u;
}
inline const ::SensorData& MsgNode::artificialgas() const {
  const ::SensorData* p = artificialgas_;
  // @@protoc_insertion_point(field_get:MsgNode.artificialGas)
  return p != nullptr ? *p : *reinterpret_cast<const ::SensorData*>(
      &::_SensorData_default_instance_);
}
inline ::SensorData* MsgNode::release_artificialgas() {
  // @@protoc_insertion_point(field_release:MsgNode.artificialGas)
  _has_bits_[0] &= ~0x40000000u;
  ::SensorData* temp = artificialgas_;
  artificialgas_ = nullptr;
  return temp;
}
inline ::SensorData* MsgNode::mutable_artificialgas() {
  _has_bits_[0] |= 0x40000000u;
  if (artificialgas_ == nullptr) {
    auto* p = CreateMaybeMessage<::SensorData>(GetArenaNoVirtual());
    artificialgas_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MsgNode.artificialGas)
  return artificialgas_;
}
inline void MsgNode::set_allocated_artificialgas(::SensorData* artificialgas) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete artificialgas_;
  }
  if (artificialgas) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      artificialgas = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, artificialgas, submessage_arena);
    }
    _has_bits_[0] |= 0x40000000u;
  } else {
    _has_bits_[0] &= ~0x40000000u;
  }
  artificialgas_ = artificialgas;
  // @@protoc_insertion_point(field_set_allocated:MsgNode.artificialGas)
}

// optional .MultiSensorDataInt multiTemp = 36;
inline bool MsgNode::has_multitemp() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void MsgNode::clear_multitemp() {
  if (multitemp_ != nullptr) multitemp_->Clear();
  _has_bits_[0] &= ~0x80000000u;
}
inline const ::MultiSensorDataInt& MsgNode::multitemp() const {
  const ::MultiSensorDataInt* p = multitemp_;
  // @@protoc_insertion_point(field_get:MsgNode.multiTemp)
  return p != nullptr ? *p : *reinterpret_cast<const ::MultiSensorDataInt*>(
      &::_MultiSensorDataInt_default_instance_);
}
inline ::MultiSensorDataInt* MsgNode::release_multitemp() {
  // @@protoc_insertion_point(field_release:MsgNode.multiTemp)
  _has_bits_[0] &= ~0x80000000u;
  ::MultiSensorDataInt* temp = multitemp_;
  multitemp_ = nullptr;
  return temp;
}
inline ::MultiSensorDataInt* MsgNode::mutable_multitemp() {
  _has_bits_[0] |= 0x80000000u;
  if (multitemp_ == nullptr) {
    auto* p = CreateMaybeMessage<::MultiSensorDataInt>(GetArenaNoVirtual());
    multitemp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MsgNode.multiTemp)
  return multitemp_;
}
inline void MsgNode::set_allocated_multitemp(::MultiSensorDataInt* multitemp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete multitemp_;
  }
  if (multitemp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      multitemp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, multitemp, submessage_arena);
    }
    _has_bits_[0] |= 0x80000000u;
  } else {
    _has_bits_[0] &= ~0x80000000u;
  }
  multitemp_ = multitemp;
  // @@protoc_insertion_point(field_set_allocated:MsgNode.multiTemp)
}

// optional .SensorData waterPressure = 37;
inline bool MsgNode::has_waterpressure() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void MsgNode::clear_waterpressure() {
  if (waterpressure_ != nullptr) waterpressure_->Clear();
  _has_bits_[1] &= ~0x00000001u;
}
inline const ::SensorData& MsgNode::waterpressure() const {
  const ::SensorData* p = waterpressure_;
  // @@protoc_insertion_point(field_get:MsgNode.waterPressure)
  return p != nullptr ? *p : *reinterpret_cast<const ::SensorData*>(
      &::_SensorData_default_instance_);
}
inline ::SensorData* MsgNode::release_waterpressure() {
  // @@protoc_insertion_point(field_release:MsgNode.waterPressure)
  _has_bits_[1] &= ~0x00000001u;
  ::SensorData* temp = waterpressure_;
  waterpressure_ = nullptr;
  return temp;
}
inline ::SensorData* MsgNode::mutable_waterpressure() {
  _has_bits_[1] |= 0x00000001u;
  if (waterpressure_ == nullptr) {
    auto* p = CreateMaybeMessage<::SensorData>(GetArenaNoVirtual());
    waterpressure_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MsgNode.waterPressure)
  return waterpressure_;
}
inline void MsgNode::set_allocated_waterpressure(::SensorData* waterpressure) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete waterpressure_;
  }
  if (waterpressure) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      waterpressure = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, waterpressure, submessage_arena);
    }
    _has_bits_[1] |= 0x00000001u;
  } else {
    _has_bits_[1] &= ~0x00000001u;
  }
  waterpressure_ = waterpressure;
  // @@protoc_insertion_point(field_set_allocated:MsgNode.waterPressure)
}

// optional .iBeacon ibeacon = 38;
inline bool MsgNode::has_ibeacon() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void MsgNode::clear_ibeacon() {
  if (ibeacon_ != nullptr) ibeacon_->Clear();
  _has_bits_[1] &= ~0x00000002u;
}
inline const ::iBeacon& MsgNode::ibeacon() const {
  const ::iBeacon* p = ibeacon_;
  // @@protoc_insertion_point(field_get:MsgNode.ibeacon)
  return p != nullptr ? *p : *reinterpret_cast<const ::iBeacon*>(
      &::_iBeacon_default_instance_);
}
inline ::iBeacon* MsgNode::release_ibeacon() {
  // @@protoc_insertion_point(field_release:MsgNode.ibeacon)
  _has_bits_[1] &= ~0x00000002u;
  ::iBeacon* temp = ibeacon_;
  ibeacon_ = nullptr;
  return temp;
}
inline ::iBeacon* MsgNode::mutable_ibeacon() {
  _has_bits_[1] |= 0x00000002u;
  if (ibeacon_ == nullptr) {
    auto* p = CreateMaybeMessage<::iBeacon>(GetArenaNoVirtual());
    ibeacon_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MsgNode.ibeacon)
  return ibeacon_;
}
inline void MsgNode::set_allocated_ibeacon(::iBeacon* ibeacon) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete ibeacon_;
  }
  if (ibeacon) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ibeacon = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ibeacon, submessage_arena);
    }
    _has_bits_[1] |= 0x00000002u;
  } else {
    _has_bits_[1] &= ~0x00000002u;
  }
  ibeacon_ = ibeacon;
  // @@protoc_insertion_point(field_set_allocated:MsgNode.ibeacon)
}

// repeated .SensorData sensors = 39;
inline int MsgNode::sensors_size() const {
  return sensors_.size();
}
inline void MsgNode::clear_sensors() {
  sensors_.Clear();
}
inline ::SensorData* MsgNode::mutable_sensors(int index) {
  // @@protoc_insertion_point(field_mutable:MsgNode.sensors)
  return sensors_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorData >*
MsgNode::mutable_sensors() {
  // @@protoc_insertion_point(field_mutable_list:MsgNode.sensors)
  return &sensors_;
}
inline const ::SensorData& MsgNode::sensors(int index) const {
  // @@protoc_insertion_point(field_get:MsgNode.sensors)
  return sensors_.Get(index);
}
inline ::SensorData* MsgNode::add_sensors() {
  // @@protoc_insertion_point(field_add:MsgNode.sensors)
  return sensors_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorData >&
MsgNode::sensors() const {
  // @@protoc_insertion_point(field_list:MsgNode.sensors)
  return sensors_;
}

// optional bool installed = 40;
inline bool MsgNode::has_installed() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void MsgNode::clear_installed() {
  installed_ = false;
  _has_bits_[1] &= ~0x00000800u;
}
inline bool MsgNode::installed() const {
  // @@protoc_insertion_point(field_get:MsgNode.installed)
  return installed_;
}
inline void MsgNode::set_installed(bool value) {
  _has_bits_[1] |= 0x00000800u;
  installed_ = value;
  // @@protoc_insertion_point(field_set:MsgNode.installed)
}

// optional .ExtSmoke extSmoke = 41;
inline bool MsgNode::has_extsmoke() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void MsgNode::clear_extsmoke() {
  if (extsmoke_ != nullptr) extsmoke_->Clear();
  _has_bits_[1] &= ~0x00000004u;
}
inline const ::ExtSmoke& MsgNode::extsmoke() const {
  const ::ExtSmoke* p = extsmoke_;
  // @@protoc_insertion_point(field_get:MsgNode.extSmoke)
  return p != nullptr ? *p : *reinterpret_cast<const ::ExtSmoke*>(
      &::_ExtSmoke_default_instance_);
}
inline ::ExtSmoke* MsgNode::release_extsmoke() {
  // @@protoc_insertion_point(field_release:MsgNode.extSmoke)
  _has_bits_[1] &= ~0x00000004u;
  ::ExtSmoke* temp = extsmoke_;
  extsmoke_ = nullptr;
  return temp;
}
inline ::ExtSmoke* MsgNode::mutable_extsmoke() {
  _has_bits_[1] |= 0x00000004u;
  if (extsmoke_ == nullptr) {
    auto* p = CreateMaybeMessage<::ExtSmoke>(GetArenaNoVirtual());
    extsmoke_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MsgNode.extSmoke)
  return extsmoke_;
}
inline void MsgNode::set_allocated_extsmoke(::ExtSmoke* extsmoke) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete extsmoke_;
  }
  if (extsmoke) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      extsmoke = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, extsmoke, submessage_arena);
    }
    _has_bits_[1] |= 0x00000004u;
  } else {
    _has_bits_[1] &= ~0x00000004u;
  }
  extsmoke_ = extsmoke;
  // @@protoc_insertion_point(field_set_allocated:MsgNode.extSmoke)
}

// optional .ElecFireData fireData = 42;
inline bool MsgNode::has_firedata() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void MsgNode::clear_firedata() {
  if (firedata_ != nullptr) firedata_->Clear();
  _has_bits_[1] &= ~0x00000008u;
}
inline const ::ElecFireData& MsgNode::firedata() const {
  const ::ElecFireData* p = firedata_;
  // @@protoc_insertion_point(field_get:MsgNode.fireData)
  return p != nullptr ? *p : *reinterpret_cast<const ::ElecFireData*>(
      &::_ElecFireData_default_instance_);
}
inline ::ElecFireData* MsgNode::release_firedata() {
  // @@protoc_insertion_point(field_release:MsgNode.fireData)
  _has_bits_[1] &= ~0x00000008u;
  ::ElecFireData* temp = firedata_;
  firedata_ = nullptr;
  return temp;
}
inline ::ElecFireData* MsgNode::mutable_firedata() {
  _has_bits_[1] |= 0x00000008u;
  if (firedata_ == nullptr) {
    auto* p = CreateMaybeMessage<::ElecFireData>(GetArenaNoVirtual());
    firedata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MsgNode.fireData)
  return firedata_;
}
inline void MsgNode::set_allocated_firedata(::ElecFireData* firedata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete firedata_;
  }
  if (firedata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      firedata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, firedata, submessage_arena);
    }
    _has_bits_[1] |= 0x00000008u;
  } else {
    _has_bits_[1] &= ~0x00000008u;
  }
  firedata_ = firedata;
  // @@protoc_insertion_point(field_set_allocated:MsgNode.fireData)
}

// repeated .MantunData mtunData = 43;
inline int MsgNode::mtundata_size() const {
  return mtundata_.size();
}
inline void MsgNode::clear_mtundata() {
  mtundata_.Clear();
}
inline ::MantunData* MsgNode::mutable_mtundata(int index) {
  // @@protoc_insertion_point(field_mutable:MsgNode.mtunData)
  return mtundata_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MantunData >*
MsgNode::mutable_mtundata() {
  // @@protoc_insertion_point(field_mutable_list:MsgNode.mtunData)
  return &mtundata_;
}
inline const ::MantunData& MsgNode::mtundata(int index) const {
  // @@protoc_insertion_point(field_get:MsgNode.mtunData)
  return mtundata_.Get(index);
}
inline ::MantunData* MsgNode::add_mtundata() {
  // @@protoc_insertion_point(field_add:MsgNode.mtunData)
  return mtundata_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MantunData >&
MsgNode::mtundata() const {
  // @@protoc_insertion_point(field_list:MsgNode.mtunData)
  return mtundata_;
}

// optional .AcrelData acrelData = 44;
inline bool MsgNode::has_acreldata() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void MsgNode::clear_acreldata() {
  if (acreldata_ != nullptr) acreldata_->Clear();
  _has_bits_[1] &= ~0x00000010u;
}
inline const ::AcrelData& MsgNode::acreldata() const {
  const ::AcrelData* p = acreldata_;
  // @@protoc_insertion_point(field_get:MsgNode.acrelData)
  return p != nullptr ? *p : *reinterpret_cast<const ::AcrelData*>(
      &::_AcrelData_default_instance_);
}
inline ::AcrelData* MsgNode::release_acreldata() {
  // @@protoc_insertion_point(field_release:MsgNode.acrelData)
  _has_bits_[1] &= ~0x00000010u;
  ::AcrelData* temp = acreldata_;
  acreldata_ = nullptr;
  return temp;
}
inline ::AcrelData* MsgNode::mutable_acreldata() {
  _has_bits_[1] |= 0x00000010u;
  if (acreldata_ == nullptr) {
    auto* p = CreateMaybeMessage<::AcrelData>(GetArenaNoVirtual());
    acreldata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MsgNode.acrelData)
  return acreldata_;
}
inline void MsgNode::set_allocated_acreldata(::AcrelData* acreldata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete acreldata_;
  }
  if (acreldata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      acreldata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, acreldata, submessage_arena);
    }
    _has_bits_[1] |= 0x00000010u;
  } else {
    _has_bits_[1] &= ~0x00000010u;
  }
  acreldata_ = acreldata;
  // @@protoc_insertion_point(field_set_allocated:MsgNode.acrelData)
}

// optional .Cayman caymanData = 45;
inline bool MsgNode::has_caymandata() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void MsgNode::clear_caymandata() {
  if (caymandata_ != nullptr) caymandata_->Clear();
  _has_bits_[1] &= ~0x00000020u;
}
inline const ::Cayman& MsgNode::caymandata() const {
  const ::Cayman* p = caymandata_;
  // @@protoc_insertion_point(field_get:MsgNode.caymanData)
  return p != nullptr ? *p : *reinterpret_cast<const ::Cayman*>(
      &::_Cayman_default_instance_);
}
inline ::Cayman* MsgNode::release_caymandata() {
  // @@protoc_insertion_point(field_release:MsgNode.caymanData)
  _has_bits_[1] &= ~0x00000020u;
  ::Cayman* temp = caymandata_;
  caymandata_ = nullptr;
  return temp;
}
inline ::Cayman* MsgNode::mutable_caymandata() {
  _has_bits_[1] |= 0x00000020u;
  if (caymandata_ == nullptr) {
    auto* p = CreateMaybeMessage<::Cayman>(GetArenaNoVirtual());
    caymandata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MsgNode.caymanData)
  return caymandata_;
}
inline void MsgNode::set_allocated_caymandata(::Cayman* caymandata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete caymandata_;
  }
  if (caymandata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      caymandata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, caymandata, submessage_arena);
    }
    _has_bits_[1] |= 0x00000020u;
  } else {
    _has_bits_[1] &= ~0x00000020u;
  }
  caymandata_ = caymandata;
  // @@protoc_insertion_point(field_set_allocated:MsgNode.caymanData)
}

// optional .Baymax baymaxData = 46;
inline bool MsgNode::has_baymaxdata() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void MsgNode::clear_baymaxdata() {
  if (baymaxdata_ != nullptr) baymaxdata_->Clear();
  _has_bits_[1] &= ~0x00000040u;
}
inline const ::Baymax& MsgNode::baymaxdata() const {
  const ::Baymax* p = baymaxdata_;
  // @@protoc_insertion_point(field_get:MsgNode.baymaxData)
  return p != nullptr ? *p : *reinterpret_cast<const ::Baymax*>(
      &::_Baymax_default_instance_);
}
inline ::Baymax* MsgNode::release_baymaxdata() {
  // @@protoc_insertion_point(field_release:MsgNode.baymaxData)
  _has_bits_[1] &= ~0x00000040u;
  ::Baymax* temp = baymaxdata_;
  baymaxdata_ = nullptr;
  return temp;
}
inline ::Baymax* MsgNode::mutable_baymaxdata() {
  _has_bits_[1] |= 0x00000040u;
  if (baymaxdata_ == nullptr) {
    auto* p = CreateMaybeMessage<::Baymax>(GetArenaNoVirtual());
    baymaxdata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MsgNode.baymaxData)
  return baymaxdata_;
}
inline void MsgNode::set_allocated_baymaxdata(::Baymax* baymaxdata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete baymaxdata_;
  }
  if (baymaxdata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      baymaxdata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, baymaxdata, submessage_arena);
    }
    _has_bits_[1] |= 0x00000040u;
  } else {
    _has_bits_[1] &= ~0x00000040u;
  }
  baymaxdata_ = baymaxdata;
  // @@protoc_insertion_point(field_set_allocated:MsgNode.baymaxData)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::Activtion> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Activtion>() {
  return ::Activtion_descriptor();
}
template <> struct is_proto_enum< ::ClassType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ClassType>() {
  return ::ClassType_descriptor();
}
template <> struct is_proto_enum< ::SensorError> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SensorError>() {
  return ::SensorError_descriptor();
}
template <> struct is_proto_enum< ::SensorType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SensorType>() {
  return ::SensorType_descriptor();
}
template <> struct is_proto_enum< ::SensorStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SensorStatus>() {
  return ::SensorStatus_descriptor();
}
template <> struct is_proto_enum< ::AppCmd> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AppCmd>() {
  return ::AppCmd_descriptor();
}
template <> struct is_proto_enum< ::NodeState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NodeState>() {
  return ::NodeState_descriptor();
}
template <> struct is_proto_enum< ::NodeAlarm> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NodeAlarm>() {
  return ::NodeAlarm_descriptor();
}
template <> struct is_proto_enum< ::SmokeCtrl> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SmokeCtrl>() {
  return ::SmokeCtrl_descriptor();
}
template <> struct is_proto_enum< ::TrackerCtrl> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TrackerCtrl>() {
  return ::TrackerCtrl_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_MsgNode_5f1v1_5fm22_2eproto
