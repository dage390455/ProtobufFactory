// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MsgNode_1v1_m13.proto

#ifndef PROTOBUF_MsgNode_5f1v1_5fm13_2eproto__INCLUDED
#define PROTOBUF_MsgNode_5f1v1_5fm13_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_MsgNode_5f1v1_5fm13_2eproto();
void protobuf_AssignDesc_MsgNode_5f1v1_5fm13_2eproto();
void protobuf_ShutdownFile_MsgNode_5f1v1_5fm13_2eproto();

class LpwanParam;
class BleParam;
class SensorData;
class SensorDataInt;
class SensorDataFloat;
class MultiSensorData;
class MultiSensorDataInt;
class GpsData;
class AxisData;
class iBeacon;
class ExtSmoke;
class AppParam;
class ElecFireData;
class MantunData;
class Cayman;
class AcrelData;
class MsgNode;

enum Activtion {
  ABP = 0,
  OTA = 1
};
bool Activtion_IsValid(int value);
const Activtion Activtion_MIN = ABP;
const Activtion Activtion_MAX = OTA;
const int Activtion_ARRAYSIZE = Activtion_MAX + 1;

const ::google::protobuf::EnumDescriptor* Activtion_descriptor();
inline const ::std::string& Activtion_Name(Activtion value) {
  return ::google::protobuf::internal::NameOfEnum(
    Activtion_descriptor(), value);
}
inline bool Activtion_Parse(
    const ::std::string& name, Activtion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Activtion>(
    Activtion_descriptor(), name, value);
}
enum ClassType {
  CLASS_A = 0,
  CLASS_B = 1,
  CLASS_C = 2
};
bool ClassType_IsValid(int value);
const ClassType ClassType_MIN = CLASS_A;
const ClassType ClassType_MAX = CLASS_C;
const int ClassType_ARRAYSIZE = ClassType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ClassType_descriptor();
inline const ::std::string& ClassType_Name(ClassType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ClassType_descriptor(), value);
}
inline bool ClassType_Parse(
    const ::std::string& name, ClassType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ClassType>(
    ClassType_descriptor(), name, value);
}
enum SensorError {
  SENSOR_ERR_NONE = 0,
  SENSOR_ERR_NO_DATA = 1,
  SENSOR_ERR_CRC = 2,
  SENSOR_ERR_DATA = 3,
  SENSOR_ERR_FAULT = 4,
  SENSOR_ERR_ALARM = 5,
  SENSOR_ERR_ALARM_HIGH = 6,
  SENSOR_ERR_ALARM_LOW = 7,
  SENSOR_ERR_UNKNOWN = 127
};
bool SensorError_IsValid(int value);
const SensorError SensorError_MIN = SENSOR_ERR_NONE;
const SensorError SensorError_MAX = SENSOR_ERR_UNKNOWN;
const int SensorError_ARRAYSIZE = SensorError_MAX + 1;

const ::google::protobuf::EnumDescriptor* SensorError_descriptor();
inline const ::std::string& SensorError_Name(SensorError value) {
  return ::google::protobuf::internal::NameOfEnum(
    SensorError_descriptor(), value);
}
inline bool SensorError_Parse(
    const ::std::string& name, SensorError* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SensorError>(
    SensorError_descriptor(), name, value);
}
enum SensorType {
  SENSOR_TYPE_TEMP = 0,
  SENSOR_TYPE_HUMI = 1,
  SENSOR_TYPE_LIGHT = 2,
  SENSOR_TYPE_GPS = 3,
  SENSOR_TYPE_ANGLE = 4,
  SENSOR_TYPE_PM2_5 = 5,
  SENSOR_TYPE_PM10 = 6,
  SENSOR_TYPE_LEAK = 7,
  SENSOR_TYPE_CO = 8,
  SENSOR_TYPE_CO2 = 9,
  SENSOR_TYPE_NO2 = 10,
  SENSOR_TYPE_CH4 = 11,
  SENSOR_TYPE_LPG = 12,
  SENSOR_TYPE_FLAME = 13,
  SENSOR_TYPE_ARTIFICIAL_GAS = 14,
  SENSOR_TYPE_WATER_GAGE = 15,
  SENSOR_TYPE_TRACKER = 16
};
bool SensorType_IsValid(int value);
const SensorType SensorType_MIN = SENSOR_TYPE_TEMP;
const SensorType SensorType_MAX = SENSOR_TYPE_TRACKER;
const int SensorType_ARRAYSIZE = SensorType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SensorType_descriptor();
inline const ::std::string& SensorType_Name(SensorType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SensorType_descriptor(), value);
}
inline bool SensorType_Parse(
    const ::std::string& name, SensorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SensorType>(
    SensorType_descriptor(), name, value);
}
enum SensorStatus {
  SENSORO_STATUS_NONE = 0,
  SENSORO_STATUS_SELF_INSPECTION = 1,
  SENSORO_STATUS_ALARM = 2
};
bool SensorStatus_IsValid(int value);
const SensorStatus SensorStatus_MIN = SENSORO_STATUS_NONE;
const SensorStatus SensorStatus_MAX = SENSORO_STATUS_ALARM;
const int SensorStatus_ARRAYSIZE = SensorStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* SensorStatus_descriptor();
inline const ::std::string& SensorStatus_Name(SensorStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    SensorStatus_descriptor(), value);
}
inline bool SensorStatus_Parse(
    const ::std::string& name, SensorStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SensorStatus>(
    SensorStatus_descriptor(), name, value);
}
enum AppCmd {
  APP_CMD_NONE = 0,
  APP_CMD_RESET = 1,
  APP_CMD_FAC_RESET = 2,
  APP_CMD_DFU = 3
};
bool AppCmd_IsValid(int value);
const AppCmd AppCmd_MIN = APP_CMD_NONE;
const AppCmd AppCmd_MAX = APP_CMD_DFU;
const int AppCmd_ARRAYSIZE = AppCmd_MAX + 1;

const ::google::protobuf::EnumDescriptor* AppCmd_descriptor();
inline const ::std::string& AppCmd_Name(AppCmd value) {
  return ::google::protobuf::internal::NameOfEnum(
    AppCmd_descriptor(), value);
}
inline bool AppCmd_Parse(
    const ::std::string& name, AppCmd* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AppCmd>(
    AppCmd_descriptor(), name, value);
}
enum NodeState {
  NODE_STATE_UNKNOWN = 0,
  NODE_STATE_STATIC = 1,
  NODE_STATE_MOVE = 2
};
bool NodeState_IsValid(int value);
const NodeState NodeState_MIN = NODE_STATE_UNKNOWN;
const NodeState NodeState_MAX = NODE_STATE_MOVE;
const int NodeState_ARRAYSIZE = NodeState_MAX + 1;

const ::google::protobuf::EnumDescriptor* NodeState_descriptor();
inline const ::std::string& NodeState_Name(NodeState value) {
  return ::google::protobuf::internal::NameOfEnum(
    NodeState_descriptor(), value);
}
inline bool NodeState_Parse(
    const ::std::string& name, NodeState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NodeState>(
    NodeState_descriptor(), name, value);
}
enum NodeAlarm {
  NODE_ALARM_NONE = 0,
  NODE_ALARM_STATIC = 1,
  NODE_ALARM_MOVE = 2,
  NODE_ALARM_COLLISION = 3,
  NODE_ALARM_ROLL = 4,
  NODE_ALARM_INVERTED = 5,
  NODE_ALARM_FALL = 6
};
bool NodeAlarm_IsValid(int value);
const NodeAlarm NodeAlarm_MIN = NODE_ALARM_NONE;
const NodeAlarm NodeAlarm_MAX = NODE_ALARM_FALL;
const int NodeAlarm_ARRAYSIZE = NodeAlarm_MAX + 1;

const ::google::protobuf::EnumDescriptor* NodeAlarm_descriptor();
inline const ::std::string& NodeAlarm_Name(NodeAlarm value) {
  return ::google::protobuf::internal::NameOfEnum(
    NodeAlarm_descriptor(), value);
}
inline bool NodeAlarm_Parse(
    const ::std::string& name, NodeAlarm* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NodeAlarm>(
    NodeAlarm_descriptor(), name, value);
}
enum SmokeCtrl {
  SMOKE_CTRL_NONE = 0,
  SMOKE_ERASURE = 1,
  SMOKE_INSPECTION_TEST = 2,
  SMOKE_INSPECTION_OVER = 3
};
bool SmokeCtrl_IsValid(int value);
const SmokeCtrl SmokeCtrl_MIN = SMOKE_CTRL_NONE;
const SmokeCtrl SmokeCtrl_MAX = SMOKE_INSPECTION_OVER;
const int SmokeCtrl_ARRAYSIZE = SmokeCtrl_MAX + 1;

const ::google::protobuf::EnumDescriptor* SmokeCtrl_descriptor();
inline const ::std::string& SmokeCtrl_Name(SmokeCtrl value) {
  return ::google::protobuf::internal::NameOfEnum(
    SmokeCtrl_descriptor(), value);
}
inline bool SmokeCtrl_Parse(
    const ::std::string& name, SmokeCtrl* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SmokeCtrl>(
    SmokeCtrl_descriptor(), name, value);
}
enum TrackerCtrl {
  TRACKER_Ctrl = 0,
  TRACKER_BOOT = 1,
  TRACKER_SHUTDOWN = 2,
  TRACKER_CALL_START = 3,
  TRACKER_CALL_END = 4,
  TRACKER_EMERGENCE_START = 5,
  TRACKER_EMERGENCE_END = 6
};
bool TrackerCtrl_IsValid(int value);
const TrackerCtrl TrackerCtrl_MIN = TRACKER_Ctrl;
const TrackerCtrl TrackerCtrl_MAX = TRACKER_EMERGENCE_END;
const int TrackerCtrl_ARRAYSIZE = TrackerCtrl_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrackerCtrl_descriptor();
inline const ::std::string& TrackerCtrl_Name(TrackerCtrl value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrackerCtrl_descriptor(), value);
}
inline bool TrackerCtrl_Parse(
    const ::std::string& name, TrackerCtrl* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrackerCtrl>(
    TrackerCtrl_descriptor(), name, value);
}
// ===================================================================

class LpwanParam : public ::google::protobuf::Message {
 public:
  LpwanParam();
  virtual ~LpwanParam();

  LpwanParam(const LpwanParam& from);

  inline LpwanParam& operator=(const LpwanParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LpwanParam& default_instance();

  void Swap(LpwanParam* other);

  // implements Message ----------------------------------------------

  LpwanParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LpwanParam& from);
  void MergeFrom(const LpwanParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes devEui = 1;
  inline bool has_deveui() const;
  inline void clear_deveui();
  static const int kDevEuiFieldNumber = 1;
  inline const ::std::string& deveui() const;
  inline void set_deveui(const ::std::string& value);
  inline void set_deveui(const char* value);
  inline void set_deveui(const void* value, size_t size);
  inline ::std::string* mutable_deveui();
  inline ::std::string* release_deveui();
  inline void set_allocated_deveui(::std::string* deveui);

  // optional bytes appEui = 2;
  inline bool has_appeui() const;
  inline void clear_appeui();
  static const int kAppEuiFieldNumber = 2;
  inline const ::std::string& appeui() const;
  inline void set_appeui(const ::std::string& value);
  inline void set_appeui(const char* value);
  inline void set_appeui(const void* value, size_t size);
  inline ::std::string* mutable_appeui();
  inline ::std::string* release_appeui();
  inline void set_allocated_appeui(::std::string* appeui);

  // optional bytes appKey = 3;
  inline bool has_appkey() const;
  inline void clear_appkey();
  static const int kAppKeyFieldNumber = 3;
  inline const ::std::string& appkey() const;
  inline void set_appkey(const ::std::string& value);
  inline void set_appkey(const char* value);
  inline void set_appkey(const void* value, size_t size);
  inline ::std::string* mutable_appkey();
  inline ::std::string* release_appkey();
  inline void set_allocated_appkey(::std::string* appkey);

  // optional bytes appSkey = 4;
  inline bool has_appskey() const;
  inline void clear_appskey();
  static const int kAppSkeyFieldNumber = 4;
  inline const ::std::string& appskey() const;
  inline void set_appskey(const ::std::string& value);
  inline void set_appskey(const char* value);
  inline void set_appskey(const void* value, size_t size);
  inline ::std::string* mutable_appskey();
  inline ::std::string* release_appskey();
  inline void set_allocated_appskey(::std::string* appskey);

  // optional bytes nwkSkey = 5;
  inline bool has_nwkskey() const;
  inline void clear_nwkskey();
  static const int kNwkSkeyFieldNumber = 5;
  inline const ::std::string& nwkskey() const;
  inline void set_nwkskey(const ::std::string& value);
  inline void set_nwkskey(const char* value);
  inline void set_nwkskey(const void* value, size_t size);
  inline ::std::string* mutable_nwkskey();
  inline ::std::string* release_nwkskey();
  inline void set_allocated_nwkskey(::std::string* nwkskey);

  // optional uint32 devAddr = 6;
  inline bool has_devaddr() const;
  inline void clear_devaddr();
  static const int kDevAddrFieldNumber = 6;
  inline ::google::protobuf::uint32 devaddr() const;
  inline void set_devaddr(::google::protobuf::uint32 value);

  // optional uint32 datarate = 7;
  inline bool has_datarate() const;
  inline void clear_datarate();
  static const int kDatarateFieldNumber = 7;
  inline ::google::protobuf::uint32 datarate() const;
  inline void set_datarate(::google::protobuf::uint32 value);

  // optional sint32 txPower = 8;
  inline bool has_txpower() const;
  inline void clear_txpower();
  static const int kTxPowerFieldNumber = 8;
  inline ::google::protobuf::int32 txpower() const;
  inline void set_txpower(::google::protobuf::int32 value);

  // optional uint32 adr = 9;
  inline bool has_adr() const;
  inline void clear_adr();
  static const int kAdrFieldNumber = 9;
  inline ::google::protobuf::uint32 adr() const;
  inline void set_adr(::google::protobuf::uint32 value);

  // optional .Activtion activition = 10;
  inline bool has_activition() const;
  inline void clear_activition();
  static const int kActivitionFieldNumber = 10;
  inline ::Activtion activition() const;
  inline void set_activition(::Activtion value);

  // optional .ClassType classType = 11;
  inline bool has_classtype() const;
  inline void clear_classtype();
  static const int kClassTypeFieldNumber = 11;
  inline ::ClassType classtype() const;
  inline void set_classtype(::ClassType value);

  // optional uint32 delay = 12;
  inline bool has_delay() const;
  inline void clear_delay();
  static const int kDelayFieldNumber = 12;
  inline ::google::protobuf::uint32 delay() const;
  inline void set_delay(::google::protobuf::uint32 value);

  // repeated uint32 channelMask = 13;
  inline int channelmask_size() const;
  inline void clear_channelmask();
  static const int kChannelMaskFieldNumber = 13;
  inline ::google::protobuf::uint32 channelmask(int index) const;
  inline void set_channelmask(int index, ::google::protobuf::uint32 value);
  inline void add_channelmask(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      channelmask() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_channelmask();

  // optional uint32 maxEIRP = 14;
  inline bool has_maxeirp() const;
  inline void clear_maxeirp();
  static const int kMaxEIRPFieldNumber = 14;
  inline ::google::protobuf::uint32 maxeirp() const;
  inline void set_maxeirp(::google::protobuf::uint32 value);

  // optional uint32 sglStatus = 15;
  inline bool has_sglstatus() const;
  inline void clear_sglstatus();
  static const int kSglStatusFieldNumber = 15;
  inline ::google::protobuf::uint32 sglstatus() const;
  inline void set_sglstatus(::google::protobuf::uint32 value);

  // optional uint32 sglFrequency = 16;
  inline bool has_sglfrequency() const;
  inline void clear_sglfrequency();
  static const int kSglFrequencyFieldNumber = 16;
  inline ::google::protobuf::uint32 sglfrequency() const;
  inline void set_sglfrequency(::google::protobuf::uint32 value);

  // optional uint32 sglDatarate = 17;
  inline bool has_sgldatarate() const;
  inline void clear_sgldatarate();
  static const int kSglDatarateFieldNumber = 17;
  inline ::google::protobuf::uint32 sgldatarate() const;
  inline void set_sgldatarate(::google::protobuf::uint32 value);

  // optional uint32 lbtStatus = 18;
  inline bool has_lbtstatus() const;
  inline void clear_lbtstatus();
  static const int kLbtStatusFieldNumber = 18;
  inline ::google::protobuf::uint32 lbtstatus() const;
  inline void set_lbtstatus(::google::protobuf::uint32 value);

  // optional sint32 lbtThreshold = 19;
  inline bool has_lbtthreshold() const;
  inline void clear_lbtthreshold();
  static const int kLbtThresholdFieldNumber = 19;
  inline ::google::protobuf::int32 lbtthreshold() const;
  inline void set_lbtthreshold(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:LpwanParam)
 private:
  inline void set_has_deveui();
  inline void clear_has_deveui();
  inline void set_has_appeui();
  inline void clear_has_appeui();
  inline void set_has_appkey();
  inline void clear_has_appkey();
  inline void set_has_appskey();
  inline void clear_has_appskey();
  inline void set_has_nwkskey();
  inline void clear_has_nwkskey();
  inline void set_has_devaddr();
  inline void clear_has_devaddr();
  inline void set_has_datarate();
  inline void clear_has_datarate();
  inline void set_has_txpower();
  inline void clear_has_txpower();
  inline void set_has_adr();
  inline void clear_has_adr();
  inline void set_has_activition();
  inline void clear_has_activition();
  inline void set_has_classtype();
  inline void clear_has_classtype();
  inline void set_has_delay();
  inline void clear_has_delay();
  inline void set_has_maxeirp();
  inline void clear_has_maxeirp();
  inline void set_has_sglstatus();
  inline void clear_has_sglstatus();
  inline void set_has_sglfrequency();
  inline void clear_has_sglfrequency();
  inline void set_has_sgldatarate();
  inline void clear_has_sgldatarate();
  inline void set_has_lbtstatus();
  inline void clear_has_lbtstatus();
  inline void set_has_lbtthreshold();
  inline void clear_has_lbtthreshold();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* deveui_;
  ::std::string* appeui_;
  ::std::string* appkey_;
  ::std::string* appskey_;
  ::std::string* nwkskey_;
  ::google::protobuf::uint32 devaddr_;
  ::google::protobuf::uint32 datarate_;
  ::google::protobuf::int32 txpower_;
  ::google::protobuf::uint32 adr_;
  int activition_;
  int classtype_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > channelmask_;
  ::google::protobuf::uint32 delay_;
  ::google::protobuf::uint32 maxeirp_;
  ::google::protobuf::uint32 sglstatus_;
  ::google::protobuf::uint32 sglfrequency_;
  ::google::protobuf::uint32 sgldatarate_;
  ::google::protobuf::uint32 lbtstatus_;
  ::google::protobuf::int32 lbtthreshold_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(19 + 31) / 32];

  friend void  protobuf_AddDesc_MsgNode_5f1v1_5fm13_2eproto();
  friend void protobuf_AssignDesc_MsgNode_5f1v1_5fm13_2eproto();
  friend void protobuf_ShutdownFile_MsgNode_5f1v1_5fm13_2eproto();

  void InitAsDefaultInstance();
  static LpwanParam* default_instance_;
};
// -------------------------------------------------------------------

class BleParam : public ::google::protobuf::Message {
 public:
  BleParam();
  virtual ~BleParam();

  BleParam(const BleParam& from);

  inline BleParam& operator=(const BleParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BleParam& default_instance();

  void Swap(BleParam* other);

  // implements Message ----------------------------------------------

  BleParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BleParam& from);
  void MergeFrom(const BleParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float bleInterval = 1;
  inline bool has_bleinterval() const;
  inline void clear_bleinterval();
  static const int kBleIntervalFieldNumber = 1;
  inline float bleinterval() const;
  inline void set_bleinterval(float value);

  // optional sint32 bleTxp = 2;
  inline bool has_bletxp() const;
  inline void clear_bletxp();
  static const int kBleTxpFieldNumber = 2;
  inline ::google::protobuf::int32 bletxp() const;
  inline void set_bletxp(::google::protobuf::int32 value);

  // optional uint32 bleOnTime = 3;
  inline bool has_bleontime() const;
  inline void clear_bleontime();
  static const int kBleOnTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 bleontime() const;
  inline void set_bleontime(::google::protobuf::uint32 value);

  // optional uint32 bleOffTime = 4;
  inline bool has_bleofftime() const;
  inline void clear_bleofftime();
  static const int kBleOffTimeFieldNumber = 4;
  inline ::google::protobuf::uint32 bleofftime() const;
  inline void set_bleofftime(::google::protobuf::uint32 value);

  // optional uint32 bleOnOff = 5;
  inline bool has_bleonoff() const;
  inline void clear_bleonoff();
  static const int kBleOnOffFieldNumber = 5;
  inline ::google::protobuf::uint32 bleonoff() const;
  inline void set_bleonoff(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:BleParam)
 private:
  inline void set_has_bleinterval();
  inline void clear_has_bleinterval();
  inline void set_has_bletxp();
  inline void clear_has_bletxp();
  inline void set_has_bleontime();
  inline void clear_has_bleontime();
  inline void set_has_bleofftime();
  inline void clear_has_bleofftime();
  inline void set_has_bleonoff();
  inline void clear_has_bleonoff();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float bleinterval_;
  ::google::protobuf::int32 bletxp_;
  ::google::protobuf::uint32 bleontime_;
  ::google::protobuf::uint32 bleofftime_;
  ::google::protobuf::uint32 bleonoff_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_MsgNode_5f1v1_5fm13_2eproto();
  friend void protobuf_AssignDesc_MsgNode_5f1v1_5fm13_2eproto();
  friend void protobuf_ShutdownFile_MsgNode_5f1v1_5fm13_2eproto();

  void InitAsDefaultInstance();
  static BleParam* default_instance_;
};
// -------------------------------------------------------------------

class SensorData : public ::google::protobuf::Message {
 public:
  SensorData();
  virtual ~SensorData();

  SensorData(const SensorData& from);

  inline SensorData& operator=(const SensorData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SensorData& default_instance();

  void Swap(SensorData* other);

  // implements Message ----------------------------------------------

  SensorData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SensorData& from);
  void MergeFrom(const SensorData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SensorType type = 9;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 9;
  inline ::SensorType type() const;
  inline void set_type(::SensorType value);

  // optional float data = 1;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline float data() const;
  inline void set_data(float value);

  // optional float alarmHigh = 2;
  inline bool has_alarmhigh() const;
  inline void clear_alarmhigh();
  static const int kAlarmHighFieldNumber = 2;
  inline float alarmhigh() const;
  inline void set_alarmhigh(float value);

  // optional float alarmLow = 3;
  inline bool has_alarmlow() const;
  inline void clear_alarmlow();
  static const int kAlarmLowFieldNumber = 3;
  inline float alarmlow() const;
  inline void set_alarmlow(float value);

  // optional uint32 calibration = 4;
  inline bool has_calibration() const;
  inline void clear_calibration();
  static const int kCalibrationFieldNumber = 4;
  inline ::google::protobuf::uint32 calibration() const;
  inline void set_calibration(::google::protobuf::uint32 value);

  // optional .SensorError error = 5;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 5;
  inline ::SensorError error() const;
  inline void set_error(::SensorError value);

  // optional uint32 status = 6;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 6;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // optional float alarmStepHigh = 7;
  inline bool has_alarmstephigh() const;
  inline void clear_alarmstephigh();
  static const int kAlarmStepHighFieldNumber = 7;
  inline float alarmstephigh() const;
  inline void set_alarmstephigh(float value);

  // optional float alarmStepLow = 8;
  inline bool has_alarmsteplow() const;
  inline void clear_alarmsteplow();
  static const int kAlarmStepLowFieldNumber = 8;
  inline float alarmsteplow() const;
  inline void set_alarmsteplow(float value);

  // @@protoc_insertion_point(class_scope:SensorData)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_alarmhigh();
  inline void clear_has_alarmhigh();
  inline void set_has_alarmlow();
  inline void clear_has_alarmlow();
  inline void set_has_calibration();
  inline void clear_has_calibration();
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_alarmstephigh();
  inline void clear_has_alarmstephigh();
  inline void set_has_alarmsteplow();
  inline void clear_has_alarmsteplow();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  float data_;
  float alarmhigh_;
  float alarmlow_;
  ::google::protobuf::uint32 calibration_;
  int error_;
  ::google::protobuf::uint32 status_;
  float alarmstephigh_;
  float alarmsteplow_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_MsgNode_5f1v1_5fm13_2eproto();
  friend void protobuf_AssignDesc_MsgNode_5f1v1_5fm13_2eproto();
  friend void protobuf_ShutdownFile_MsgNode_5f1v1_5fm13_2eproto();

  void InitAsDefaultInstance();
  static SensorData* default_instance_;
};
// -------------------------------------------------------------------

class SensorDataInt : public ::google::protobuf::Message {
 public:
  SensorDataInt();
  virtual ~SensorDataInt();

  SensorDataInt(const SensorDataInt& from);

  inline SensorDataInt& operator=(const SensorDataInt& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SensorDataInt& default_instance();

  void Swap(SensorDataInt* other);

  // implements Message ----------------------------------------------

  SensorDataInt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SensorDataInt& from);
  void MergeFrom(const SensorDataInt& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SensorType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::SensorType type() const;
  inline void set_type(::SensorType value);

  // optional sint32 data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline ::google::protobuf::int32 data() const;
  inline void set_data(::google::protobuf::int32 value);

  // optional sint32 alarmHigh = 3;
  inline bool has_alarmhigh() const;
  inline void clear_alarmhigh();
  static const int kAlarmHighFieldNumber = 3;
  inline ::google::protobuf::int32 alarmhigh() const;
  inline void set_alarmhigh(::google::protobuf::int32 value);

  // optional sint32 alarmLow = 4;
  inline bool has_alarmlow() const;
  inline void clear_alarmlow();
  static const int kAlarmLowFieldNumber = 4;
  inline ::google::protobuf::int32 alarmlow() const;
  inline void set_alarmlow(::google::protobuf::int32 value);

  // optional sint32 calibration = 5;
  inline bool has_calibration() const;
  inline void clear_calibration();
  static const int kCalibrationFieldNumber = 5;
  inline ::google::protobuf::int32 calibration() const;
  inline void set_calibration(::google::protobuf::int32 value);

  // optional .SensorError error = 6;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 6;
  inline ::SensorError error() const;
  inline void set_error(::SensorError value);

  // optional uint32 status = 7;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 7;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // optional sint32 alarmStepHigh = 8;
  inline bool has_alarmstephigh() const;
  inline void clear_alarmstephigh();
  static const int kAlarmStepHighFieldNumber = 8;
  inline ::google::protobuf::int32 alarmstephigh() const;
  inline void set_alarmstephigh(::google::protobuf::int32 value);

  // optional sint32 alarmStepLow = 9;
  inline bool has_alarmsteplow() const;
  inline void clear_alarmsteplow();
  static const int kAlarmStepLowFieldNumber = 9;
  inline ::google::protobuf::int32 alarmsteplow() const;
  inline void set_alarmsteplow(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SensorDataInt)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_alarmhigh();
  inline void clear_has_alarmhigh();
  inline void set_has_alarmlow();
  inline void clear_has_alarmlow();
  inline void set_has_calibration();
  inline void clear_has_calibration();
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_alarmstephigh();
  inline void clear_has_alarmstephigh();
  inline void set_has_alarmsteplow();
  inline void clear_has_alarmsteplow();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  ::google::protobuf::int32 data_;
  ::google::protobuf::int32 alarmhigh_;
  ::google::protobuf::int32 alarmlow_;
  ::google::protobuf::int32 calibration_;
  int error_;
  ::google::protobuf::uint32 status_;
  ::google::protobuf::int32 alarmstephigh_;
  ::google::protobuf::int32 alarmsteplow_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_MsgNode_5f1v1_5fm13_2eproto();
  friend void protobuf_AssignDesc_MsgNode_5f1v1_5fm13_2eproto();
  friend void protobuf_ShutdownFile_MsgNode_5f1v1_5fm13_2eproto();

  void InitAsDefaultInstance();
  static SensorDataInt* default_instance_;
};
// -------------------------------------------------------------------

class SensorDataFloat : public ::google::protobuf::Message {
 public:
  SensorDataFloat();
  virtual ~SensorDataFloat();

  SensorDataFloat(const SensorDataFloat& from);

  inline SensorDataFloat& operator=(const SensorDataFloat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SensorDataFloat& default_instance();

  void Swap(SensorDataFloat* other);

  // implements Message ----------------------------------------------

  SensorDataFloat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SensorDataFloat& from);
  void MergeFrom(const SensorDataFloat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SensorType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::SensorType type() const;
  inline void set_type(::SensorType value);

  // optional float data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline float data() const;
  inline void set_data(float value);

  // optional float alarmHigh = 3;
  inline bool has_alarmhigh() const;
  inline void clear_alarmhigh();
  static const int kAlarmHighFieldNumber = 3;
  inline float alarmhigh() const;
  inline void set_alarmhigh(float value);

  // optional float alarmLow = 4;
  inline bool has_alarmlow() const;
  inline void clear_alarmlow();
  static const int kAlarmLowFieldNumber = 4;
  inline float alarmlow() const;
  inline void set_alarmlow(float value);

  // optional sint32 calibration = 5;
  inline bool has_calibration() const;
  inline void clear_calibration();
  static const int kCalibrationFieldNumber = 5;
  inline ::google::protobuf::int32 calibration() const;
  inline void set_calibration(::google::protobuf::int32 value);

  // optional .SensorError error = 6;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 6;
  inline ::SensorError error() const;
  inline void set_error(::SensorError value);

  // optional uint32 status = 7;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 7;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // optional float alarmStepHigh = 8;
  inline bool has_alarmstephigh() const;
  inline void clear_alarmstephigh();
  static const int kAlarmStepHighFieldNumber = 8;
  inline float alarmstephigh() const;
  inline void set_alarmstephigh(float value);

  // optional float alarmStepLow = 9;
  inline bool has_alarmsteplow() const;
  inline void clear_alarmsteplow();
  static const int kAlarmStepLowFieldNumber = 9;
  inline float alarmsteplow() const;
  inline void set_alarmsteplow(float value);

  // @@protoc_insertion_point(class_scope:SensorDataFloat)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_alarmhigh();
  inline void clear_has_alarmhigh();
  inline void set_has_alarmlow();
  inline void clear_has_alarmlow();
  inline void set_has_calibration();
  inline void clear_has_calibration();
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_alarmstephigh();
  inline void clear_has_alarmstephigh();
  inline void set_has_alarmsteplow();
  inline void clear_has_alarmsteplow();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  float data_;
  float alarmhigh_;
  float alarmlow_;
  ::google::protobuf::int32 calibration_;
  int error_;
  ::google::protobuf::uint32 status_;
  float alarmstephigh_;
  float alarmsteplow_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_MsgNode_5f1v1_5fm13_2eproto();
  friend void protobuf_AssignDesc_MsgNode_5f1v1_5fm13_2eproto();
  friend void protobuf_ShutdownFile_MsgNode_5f1v1_5fm13_2eproto();

  void InitAsDefaultInstance();
  static SensorDataFloat* default_instance_;
};
// -------------------------------------------------------------------

class MultiSensorData : public ::google::protobuf::Message {
 public:
  MultiSensorData();
  virtual ~MultiSensorData();

  MultiSensorData(const MultiSensorData& from);

  inline MultiSensorData& operator=(const MultiSensorData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MultiSensorData& default_instance();

  void Swap(MultiSensorData* other);

  // implements Message ----------------------------------------------

  MultiSensorData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MultiSensorData& from);
  void MergeFrom(const MultiSensorData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float data = 1;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline float data(int index) const;
  inline void set_data(int index, float value);
  inline void add_data(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      data() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_data();

  // optional float alarmHigh = 2;
  inline bool has_alarmhigh() const;
  inline void clear_alarmhigh();
  static const int kAlarmHighFieldNumber = 2;
  inline float alarmhigh() const;
  inline void set_alarmhigh(float value);

  // optional float alarmLow = 3;
  inline bool has_alarmlow() const;
  inline void clear_alarmlow();
  static const int kAlarmLowFieldNumber = 3;
  inline float alarmlow() const;
  inline void set_alarmlow(float value);

  // optional uint32 calibration = 4;
  inline bool has_calibration() const;
  inline void clear_calibration();
  static const int kCalibrationFieldNumber = 4;
  inline ::google::protobuf::uint32 calibration() const;
  inline void set_calibration(::google::protobuf::uint32 value);

  // optional .SensorError error = 5;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 5;
  inline ::SensorError error() const;
  inline void set_error(::SensorError value);

  // optional uint32 status = 6;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 6;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // optional float alarmStepHigh = 7;
  inline bool has_alarmstephigh() const;
  inline void clear_alarmstephigh();
  static const int kAlarmStepHighFieldNumber = 7;
  inline float alarmstephigh() const;
  inline void set_alarmstephigh(float value);

  // optional float alarmStepLow = 8;
  inline bool has_alarmsteplow() const;
  inline void clear_alarmsteplow();
  static const int kAlarmStepLowFieldNumber = 8;
  inline float alarmsteplow() const;
  inline void set_alarmsteplow(float value);

  // @@protoc_insertion_point(class_scope:MultiSensorData)
 private:
  inline void set_has_alarmhigh();
  inline void clear_has_alarmhigh();
  inline void set_has_alarmlow();
  inline void clear_has_alarmlow();
  inline void set_has_calibration();
  inline void clear_has_calibration();
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_alarmstephigh();
  inline void clear_has_alarmstephigh();
  inline void set_has_alarmsteplow();
  inline void clear_has_alarmsteplow();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< float > data_;
  float alarmhigh_;
  float alarmlow_;
  ::google::protobuf::uint32 calibration_;
  int error_;
  ::google::protobuf::uint32 status_;
  float alarmstephigh_;
  float alarmsteplow_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_MsgNode_5f1v1_5fm13_2eproto();
  friend void protobuf_AssignDesc_MsgNode_5f1v1_5fm13_2eproto();
  friend void protobuf_ShutdownFile_MsgNode_5f1v1_5fm13_2eproto();

  void InitAsDefaultInstance();
  static MultiSensorData* default_instance_;
};
// -------------------------------------------------------------------

class MultiSensorDataInt : public ::google::protobuf::Message {
 public:
  MultiSensorDataInt();
  virtual ~MultiSensorDataInt();

  MultiSensorDataInt(const MultiSensorDataInt& from);

  inline MultiSensorDataInt& operator=(const MultiSensorDataInt& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MultiSensorDataInt& default_instance();

  void Swap(MultiSensorDataInt* other);

  // implements Message ----------------------------------------------

  MultiSensorDataInt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MultiSensorDataInt& from);
  void MergeFrom(const MultiSensorDataInt& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated sint32 data = 1;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline ::google::protobuf::int32 data(int index) const;
  inline void set_data(int index, ::google::protobuf::int32 value);
  inline void add_data(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      data() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_data();

  // optional sint32 alarmHigh = 2;
  inline bool has_alarmhigh() const;
  inline void clear_alarmhigh();
  static const int kAlarmHighFieldNumber = 2;
  inline ::google::protobuf::int32 alarmhigh() const;
  inline void set_alarmhigh(::google::protobuf::int32 value);

  // optional sint32 alarmLow = 3;
  inline bool has_alarmlow() const;
  inline void clear_alarmlow();
  static const int kAlarmLowFieldNumber = 3;
  inline ::google::protobuf::int32 alarmlow() const;
  inline void set_alarmlow(::google::protobuf::int32 value);

  // optional uint32 calibration = 4;
  inline bool has_calibration() const;
  inline void clear_calibration();
  static const int kCalibrationFieldNumber = 4;
  inline ::google::protobuf::uint32 calibration() const;
  inline void set_calibration(::google::protobuf::uint32 value);

  // optional .SensorError error = 5;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 5;
  inline ::SensorError error() const;
  inline void set_error(::SensorError value);

  // optional uint32 status = 6;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 6;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // optional sint32 alarmStepHigh = 7;
  inline bool has_alarmstephigh() const;
  inline void clear_alarmstephigh();
  static const int kAlarmStepHighFieldNumber = 7;
  inline ::google::protobuf::int32 alarmstephigh() const;
  inline void set_alarmstephigh(::google::protobuf::int32 value);

  // optional sint32 alarmStepLow = 8;
  inline bool has_alarmsteplow() const;
  inline void clear_alarmsteplow();
  static const int kAlarmStepLowFieldNumber = 8;
  inline ::google::protobuf::int32 alarmsteplow() const;
  inline void set_alarmsteplow(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:MultiSensorDataInt)
 private:
  inline void set_has_alarmhigh();
  inline void clear_has_alarmhigh();
  inline void set_has_alarmlow();
  inline void clear_has_alarmlow();
  inline void set_has_calibration();
  inline void clear_has_calibration();
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_alarmstephigh();
  inline void clear_has_alarmstephigh();
  inline void set_has_alarmsteplow();
  inline void clear_has_alarmsteplow();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > data_;
  ::google::protobuf::int32 alarmhigh_;
  ::google::protobuf::int32 alarmlow_;
  ::google::protobuf::uint32 calibration_;
  int error_;
  ::google::protobuf::uint32 status_;
  ::google::protobuf::int32 alarmstephigh_;
  ::google::protobuf::int32 alarmsteplow_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_MsgNode_5f1v1_5fm13_2eproto();
  friend void protobuf_AssignDesc_MsgNode_5f1v1_5fm13_2eproto();
  friend void protobuf_ShutdownFile_MsgNode_5f1v1_5fm13_2eproto();

  void InitAsDefaultInstance();
  static MultiSensorDataInt* default_instance_;
};
// -------------------------------------------------------------------

class GpsData : public ::google::protobuf::Message {
 public:
  GpsData();
  virtual ~GpsData();

  GpsData(const GpsData& from);

  inline GpsData& operator=(const GpsData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GpsData& default_instance();

  void Swap(GpsData* other);

  // implements Message ----------------------------------------------

  GpsData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GpsData& from);
  void MergeFrom(const GpsData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double latitude = 1;
  inline bool has_latitude() const;
  inline void clear_latitude();
  static const int kLatitudeFieldNumber = 1;
  inline double latitude() const;
  inline void set_latitude(double value);

  // optional double longitude = 2;
  inline bool has_longitude() const;
  inline void clear_longitude();
  static const int kLongitudeFieldNumber = 2;
  inline double longitude() const;
  inline void set_longitude(double value);

  // optional double altitude = 3;
  inline bool has_altitude() const;
  inline void clear_altitude();
  static const int kAltitudeFieldNumber = 3;
  inline double altitude() const;
  inline void set_altitude(double value);

  // @@protoc_insertion_point(class_scope:GpsData)
 private:
  inline void set_has_latitude();
  inline void clear_has_latitude();
  inline void set_has_longitude();
  inline void clear_has_longitude();
  inline void set_has_altitude();
  inline void clear_has_altitude();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double latitude_;
  double longitude_;
  double altitude_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_MsgNode_5f1v1_5fm13_2eproto();
  friend void protobuf_AssignDesc_MsgNode_5f1v1_5fm13_2eproto();
  friend void protobuf_ShutdownFile_MsgNode_5f1v1_5fm13_2eproto();

  void InitAsDefaultInstance();
  static GpsData* default_instance_;
};
// -------------------------------------------------------------------

class AxisData : public ::google::protobuf::Message {
 public:
  AxisData();
  virtual ~AxisData();

  AxisData(const AxisData& from);

  inline AxisData& operator=(const AxisData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AxisData& default_instance();

  void Swap(AxisData* other);

  // implements Message ----------------------------------------------

  AxisData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AxisData& from);
  void MergeFrom(const AxisData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // optional float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);

  // optional float z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline float z() const;
  inline void set_z(float value);

  // @@protoc_insertion_point(class_scope:AxisData)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float x_;
  float y_;
  float z_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_MsgNode_5f1v1_5fm13_2eproto();
  friend void protobuf_AssignDesc_MsgNode_5f1v1_5fm13_2eproto();
  friend void protobuf_ShutdownFile_MsgNode_5f1v1_5fm13_2eproto();

  void InitAsDefaultInstance();
  static AxisData* default_instance_;
};
// -------------------------------------------------------------------

class iBeacon : public ::google::protobuf::Message {
 public:
  iBeacon();
  virtual ~iBeacon();

  iBeacon(const iBeacon& from);

  inline iBeacon& operator=(const iBeacon& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const iBeacon& default_instance();

  void Swap(iBeacon* other);

  // implements Message ----------------------------------------------

  iBeacon* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const iBeacon& from);
  void MergeFrom(const iBeacon& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes addr = 1;
  inline bool has_addr() const;
  inline void clear_addr();
  static const int kAddrFieldNumber = 1;
  inline const ::std::string& addr() const;
  inline void set_addr(const ::std::string& value);
  inline void set_addr(const char* value);
  inline void set_addr(const void* value, size_t size);
  inline ::std::string* mutable_addr();
  inline ::std::string* release_addr();
  inline void set_allocated_addr(::std::string* addr);

  // optional bytes umm = 2;
  inline bool has_umm() const;
  inline void clear_umm();
  static const int kUmmFieldNumber = 2;
  inline const ::std::string& umm() const;
  inline void set_umm(const ::std::string& value);
  inline void set_umm(const char* value);
  inline void set_umm(const void* value, size_t size);
  inline ::std::string* mutable_umm();
  inline ::std::string* release_umm();
  inline void set_allocated_umm(::std::string* umm);

  // optional sint32 rssi = 3;
  inline bool has_rssi() const;
  inline void clear_rssi();
  static const int kRssiFieldNumber = 3;
  inline ::google::protobuf::int32 rssi() const;
  inline void set_rssi(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:iBeacon)
 private:
  inline void set_has_addr();
  inline void clear_has_addr();
  inline void set_has_umm();
  inline void clear_has_umm();
  inline void set_has_rssi();
  inline void clear_has_rssi();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* addr_;
  ::std::string* umm_;
  ::google::protobuf::int32 rssi_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_MsgNode_5f1v1_5fm13_2eproto();
  friend void protobuf_AssignDesc_MsgNode_5f1v1_5fm13_2eproto();
  friend void protobuf_ShutdownFile_MsgNode_5f1v1_5fm13_2eproto();

  void InitAsDefaultInstance();
  static iBeacon* default_instance_;
};
// -------------------------------------------------------------------

class ExtSmoke : public ::google::protobuf::Message {
 public:
  ExtSmoke();
  virtual ~ExtSmoke();

  ExtSmoke(const ExtSmoke& from);

  inline ExtSmoke& operator=(const ExtSmoke& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExtSmoke& default_instance();

  void Swap(ExtSmoke* other);

  // implements Message ----------------------------------------------

  ExtSmoke* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExtSmoke& from);
  void MergeFrom(const ExtSmoke& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 bgSignal = 1;
  inline bool has_bgsignal() const;
  inline void clear_bgsignal();
  static const int kBgSignalFieldNumber = 1;
  inline ::google::protobuf::uint32 bgsignal() const;
  inline void set_bgsignal(::google::protobuf::uint32 value);

  // optional uint32 bgSignalThreshold = 2;
  inline bool has_bgsignalthreshold() const;
  inline void clear_bgsignalthreshold();
  static const int kBgSignalThresholdFieldNumber = 2;
  inline ::google::protobuf::uint32 bgsignalthreshold() const;
  inline void set_bgsignalthreshold(::google::protobuf::uint32 value);

  // optional uint32 bgSignalCalibration = 3;
  inline bool has_bgsignalcalibration() const;
  inline void clear_bgsignalcalibration();
  static const int kBgSignalCalibrationFieldNumber = 3;
  inline ::google::protobuf::uint32 bgsignalcalibration() const;
  inline void set_bgsignalcalibration(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ExtSmoke)
 private:
  inline void set_has_bgsignal();
  inline void clear_has_bgsignal();
  inline void set_has_bgsignalthreshold();
  inline void clear_has_bgsignalthreshold();
  inline void set_has_bgsignalcalibration();
  inline void clear_has_bgsignalcalibration();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 bgsignal_;
  ::google::protobuf::uint32 bgsignalthreshold_;
  ::google::protobuf::uint32 bgsignalcalibration_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_MsgNode_5f1v1_5fm13_2eproto();
  friend void protobuf_AssignDesc_MsgNode_5f1v1_5fm13_2eproto();
  friend void protobuf_ShutdownFile_MsgNode_5f1v1_5fm13_2eproto();

  void InitAsDefaultInstance();
  static ExtSmoke* default_instance_;
};
// -------------------------------------------------------------------

class AppParam : public ::google::protobuf::Message {
 public:
  AppParam();
  virtual ~AppParam();

  AppParam(const AppParam& from);

  inline AppParam& operator=(const AppParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AppParam& default_instance();

  void Swap(AppParam* other);

  // implements Message ----------------------------------------------

  AppParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AppParam& from);
  void MergeFrom(const AppParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .AppCmd cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::AppCmd cmd() const;
  inline void set_cmd(::AppCmd value);

  // optional uint32 uploadInterval = 2;
  inline bool has_uploadinterval() const;
  inline void clear_uploadinterval();
  static const int kUploadIntervalFieldNumber = 2;
  inline ::google::protobuf::uint32 uploadinterval() const;
  inline void set_uploadinterval(::google::protobuf::uint32 value);

  // optional uint32 syncTime = 3;
  inline bool has_synctime() const;
  inline void clear_synctime();
  static const int kSyncTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 synctime() const;
  inline void set_synctime(::google::protobuf::uint32 value);

  // optional .NodeState nodeState = 4;
  inline bool has_nodestate() const;
  inline void clear_nodestate();
  static const int kNodeStateFieldNumber = 4;
  inline ::NodeState nodestate() const;
  inline void set_nodestate(::NodeState value);

  // optional .NodeAlarm nodeAlarm = 5;
  inline bool has_nodealarm() const;
  inline void clear_nodealarm();
  static const int kNodeAlarmFieldNumber = 5;
  inline ::NodeAlarm nodealarm() const;
  inline void set_nodealarm(::NodeAlarm value);

  // optional uint32 nodeAlarmSet = 6;
  inline bool has_nodealarmset() const;
  inline void clear_nodealarmset();
  static const int kNodeAlarmSetFieldNumber = 6;
  inline ::google::protobuf::uint32 nodealarmset() const;
  inline void set_nodealarmset(::google::protobuf::uint32 value);

  // optional uint32 confirm = 7;
  inline bool has_confirm() const;
  inline void clear_confirm();
  static const int kConfirmFieldNumber = 7;
  inline ::google::protobuf::uint32 confirm() const;
  inline void set_confirm(::google::protobuf::uint32 value);

  // optional .SmokeCtrl smokeCtrl = 8;
  inline bool has_smokectrl() const;
  inline void clear_smokectrl();
  static const int kSmokeCtrlFieldNumber = 8;
  inline ::SmokeCtrl smokectrl() const;
  inline void set_smokectrl(::SmokeCtrl value);

  // optional uint32 uploadRepeat = 9;
  inline bool has_uploadrepeat() const;
  inline void clear_uploadrepeat();
  static const int kUploadRepeatFieldNumber = 9;
  inline ::google::protobuf::uint32 uploadrepeat() const;
  inline void set_uploadrepeat(::google::protobuf::uint32 value);

  // optional uint32 alarmUploadInterval = 10;
  inline bool has_alarmuploadinterval() const;
  inline void clear_alarmuploadinterval();
  static const int kAlarmUploadIntervalFieldNumber = 10;
  inline ::google::protobuf::uint32 alarmuploadinterval() const;
  inline void set_alarmuploadinterval(::google::protobuf::uint32 value);

  // optional uint32 alarmUploadNb = 11;
  inline bool has_alarmuploadnb() const;
  inline void clear_alarmuploadnb();
  static const int kAlarmUploadNbFieldNumber = 11;
  inline ::google::protobuf::uint32 alarmuploadnb() const;
  inline void set_alarmuploadnb(::google::protobuf::uint32 value);

  // optional .TrackerCtrl trackerCtrl = 12;
  inline bool has_trackerctrl() const;
  inline void clear_trackerctrl();
  static const int kTrackerCtrlFieldNumber = 12;
  inline ::TrackerCtrl trackerctrl() const;
  inline void set_trackerctrl(::TrackerCtrl value);

  // optional uint32 trackerEmergencyTime = 13;
  inline bool has_trackeremergencytime() const;
  inline void clear_trackeremergencytime();
  static const int kTrackerEmergencyTimeFieldNumber = 13;
  inline ::google::protobuf::uint32 trackeremergencytime() const;
  inline void set_trackeremergencytime(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:AppParam)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_uploadinterval();
  inline void clear_has_uploadinterval();
  inline void set_has_synctime();
  inline void clear_has_synctime();
  inline void set_has_nodestate();
  inline void clear_has_nodestate();
  inline void set_has_nodealarm();
  inline void clear_has_nodealarm();
  inline void set_has_nodealarmset();
  inline void clear_has_nodealarmset();
  inline void set_has_confirm();
  inline void clear_has_confirm();
  inline void set_has_smokectrl();
  inline void clear_has_smokectrl();
  inline void set_has_uploadrepeat();
  inline void clear_has_uploadrepeat();
  inline void set_has_alarmuploadinterval();
  inline void clear_has_alarmuploadinterval();
  inline void set_has_alarmuploadnb();
  inline void clear_has_alarmuploadnb();
  inline void set_has_trackerctrl();
  inline void clear_has_trackerctrl();
  inline void set_has_trackeremergencytime();
  inline void clear_has_trackeremergencytime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int cmd_;
  ::google::protobuf::uint32 uploadinterval_;
  ::google::protobuf::uint32 synctime_;
  int nodestate_;
  int nodealarm_;
  ::google::protobuf::uint32 nodealarmset_;
  ::google::protobuf::uint32 confirm_;
  int smokectrl_;
  ::google::protobuf::uint32 uploadrepeat_;
  ::google::protobuf::uint32 alarmuploadinterval_;
  ::google::protobuf::uint32 alarmuploadnb_;
  int trackerctrl_;
  ::google::protobuf::uint32 trackeremergencytime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_MsgNode_5f1v1_5fm13_2eproto();
  friend void protobuf_AssignDesc_MsgNode_5f1v1_5fm13_2eproto();
  friend void protobuf_ShutdownFile_MsgNode_5f1v1_5fm13_2eproto();

  void InitAsDefaultInstance();
  static AppParam* default_instance_;
};
// -------------------------------------------------------------------

class ElecFireData : public ::google::protobuf::Message {
 public:
  ElecFireData();
  virtual ~ElecFireData();

  ElecFireData(const ElecFireData& from);

  inline ElecFireData& operator=(const ElecFireData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ElecFireData& default_instance();

  void Swap(ElecFireData* other);

  // implements Message ----------------------------------------------

  ElecFireData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ElecFireData& from);
  void MergeFrom(const ElecFireData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint32 vol_val = 1;
  inline bool has_vol_val() const;
  inline void clear_vol_val();
  static const int kVolValFieldNumber = 1;
  inline ::google::protobuf::int32 vol_val() const;
  inline void set_vol_val(::google::protobuf::int32 value);

  // optional uint32 curr_val = 2;
  inline bool has_curr_val() const;
  inline void clear_curr_val();
  static const int kCurrValFieldNumber = 2;
  inline ::google::protobuf::uint32 curr_val() const;
  inline void set_curr_val(::google::protobuf::uint32 value);

  // optional sint32 leakage_val = 3;
  inline bool has_leakage_val() const;
  inline void clear_leakage_val();
  static const int kLeakageValFieldNumber = 3;
  inline ::google::protobuf::int32 leakage_val() const;
  inline void set_leakage_val(::google::protobuf::int32 value);

  // optional uint32 power_val = 4;
  inline bool has_power_val() const;
  inline void clear_power_val();
  static const int kPowerValFieldNumber = 4;
  inline ::google::protobuf::uint32 power_val() const;
  inline void set_power_val(::google::protobuf::uint32 value);

  // optional uint32 elec_energy_val = 5;
  inline bool has_elec_energy_val() const;
  inline void clear_elec_energy_val();
  static const int kElecEnergyValFieldNumber = 5;
  inline ::google::protobuf::uint32 elec_energy_val() const;
  inline void set_elec_energy_val(::google::protobuf::uint32 value);

  // optional uint32 temp_val = 6;
  inline bool has_temp_val() const;
  inline void clear_temp_val();
  static const int kTempValFieldNumber = 6;
  inline ::google::protobuf::uint32 temp_val() const;
  inline void set_temp_val(::google::protobuf::uint32 value);

  // optional uint32 status = 7;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 7;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // optional uint32 alarm = 8;
  inline bool has_alarm() const;
  inline void clear_alarm();
  static const int kAlarmFieldNumber = 8;
  inline ::google::protobuf::uint32 alarm() const;
  inline void set_alarm(::google::protobuf::uint32 value);

  // optional uint32 error = 9;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 9;
  inline ::google::protobuf::uint32 error() const;
  inline void set_error(::google::protobuf::uint32 value);

  // optional uint32 sensorPwd = 10;
  inline bool has_sensorpwd() const;
  inline void clear_sensorpwd();
  static const int kSensorPwdFieldNumber = 10;
  inline ::google::protobuf::uint32 sensorpwd() const;
  inline void set_sensorpwd(::google::protobuf::uint32 value);

  // optional uint32 leakageTh = 11;
  inline bool has_leakageth() const;
  inline void clear_leakageth();
  static const int kLeakageThFieldNumber = 11;
  inline ::google::protobuf::uint32 leakageth() const;
  inline void set_leakageth(::google::protobuf::uint32 value);

  // optional uint32 tempTh = 12;
  inline bool has_tempth() const;
  inline void clear_tempth();
  static const int kTempThFieldNumber = 12;
  inline ::google::protobuf::uint32 tempth() const;
  inline void set_tempth(::google::protobuf::uint32 value);

  // optional uint32 currentTh = 13;
  inline bool has_currentth() const;
  inline void clear_currentth();
  static const int kCurrentThFieldNumber = 13;
  inline ::google::protobuf::uint32 currentth() const;
  inline void set_currentth(::google::protobuf::uint32 value);

  // optional uint32 loadTh = 14;
  inline bool has_loadth() const;
  inline void clear_loadth();
  static const int kLoadThFieldNumber = 14;
  inline ::google::protobuf::uint32 loadth() const;
  inline void set_loadth(::google::protobuf::uint32 value);

  // optional uint32 volHighTh = 15;
  inline bool has_volhighth() const;
  inline void clear_volhighth();
  static const int kVolHighThFieldNumber = 15;
  inline ::google::protobuf::uint32 volhighth() const;
  inline void set_volhighth(::google::protobuf::uint32 value);

  // optional uint32 volLowTh = 16;
  inline bool has_vollowth() const;
  inline void clear_vollowth();
  static const int kVolLowThFieldNumber = 16;
  inline ::google::protobuf::uint32 vollowth() const;
  inline void set_vollowth(::google::protobuf::uint32 value);

  // optional uint32 cmd = 17;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 17;
  inline ::google::protobuf::uint32 cmd() const;
  inline void set_cmd(::google::protobuf::uint32 value);

  // optional uint32 autoSwitch = 18;
  inline bool has_autoswitch() const;
  inline void clear_autoswitch();
  static const int kAutoSwitchFieldNumber = 18;
  inline ::google::protobuf::uint32 autoswitch() const;
  inline void set_autoswitch(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ElecFireData)
 private:
  inline void set_has_vol_val();
  inline void clear_has_vol_val();
  inline void set_has_curr_val();
  inline void clear_has_curr_val();
  inline void set_has_leakage_val();
  inline void clear_has_leakage_val();
  inline void set_has_power_val();
  inline void clear_has_power_val();
  inline void set_has_elec_energy_val();
  inline void clear_has_elec_energy_val();
  inline void set_has_temp_val();
  inline void clear_has_temp_val();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_alarm();
  inline void clear_has_alarm();
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_sensorpwd();
  inline void clear_has_sensorpwd();
  inline void set_has_leakageth();
  inline void clear_has_leakageth();
  inline void set_has_tempth();
  inline void clear_has_tempth();
  inline void set_has_currentth();
  inline void clear_has_currentth();
  inline void set_has_loadth();
  inline void clear_has_loadth();
  inline void set_has_volhighth();
  inline void clear_has_volhighth();
  inline void set_has_vollowth();
  inline void clear_has_vollowth();
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_autoswitch();
  inline void clear_has_autoswitch();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 vol_val_;
  ::google::protobuf::uint32 curr_val_;
  ::google::protobuf::int32 leakage_val_;
  ::google::protobuf::uint32 power_val_;
  ::google::protobuf::uint32 elec_energy_val_;
  ::google::protobuf::uint32 temp_val_;
  ::google::protobuf::uint32 status_;
  ::google::protobuf::uint32 alarm_;
  ::google::protobuf::uint32 error_;
  ::google::protobuf::uint32 sensorpwd_;
  ::google::protobuf::uint32 leakageth_;
  ::google::protobuf::uint32 tempth_;
  ::google::protobuf::uint32 currentth_;
  ::google::protobuf::uint32 loadth_;
  ::google::protobuf::uint32 volhighth_;
  ::google::protobuf::uint32 vollowth_;
  ::google::protobuf::uint32 cmd_;
  ::google::protobuf::uint32 autoswitch_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(18 + 31) / 32];

  friend void  protobuf_AddDesc_MsgNode_5f1v1_5fm13_2eproto();
  friend void protobuf_AssignDesc_MsgNode_5f1v1_5fm13_2eproto();
  friend void protobuf_ShutdownFile_MsgNode_5f1v1_5fm13_2eproto();

  void InitAsDefaultInstance();
  static ElecFireData* default_instance_;
};
// -------------------------------------------------------------------

class MantunData : public ::google::protobuf::Message {
 public:
  MantunData();
  virtual ~MantunData();

  MantunData(const MantunData& from);

  inline MantunData& operator=(const MantunData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MantunData& default_instance();

  void Swap(MantunData* other);

  // implements Message ----------------------------------------------

  MantunData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MantunData& from);
  void MergeFrom(const MantunData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 volVal = 1;
  inline bool has_volval() const;
  inline void clear_volval();
  static const int kVolValFieldNumber = 1;
  inline ::google::protobuf::uint32 volval() const;
  inline void set_volval(::google::protobuf::uint32 value);

  // optional uint32 currVal = 2;
  inline bool has_currval() const;
  inline void clear_currval();
  static const int kCurrValFieldNumber = 2;
  inline ::google::protobuf::uint32 currval() const;
  inline void set_currval(::google::protobuf::uint32 value);

  // optional uint32 leakageVal = 3;
  inline bool has_leakageval() const;
  inline void clear_leakageval();
  static const int kLeakageValFieldNumber = 3;
  inline ::google::protobuf::uint32 leakageval() const;
  inline void set_leakageval(::google::protobuf::uint32 value);

  // optional uint32 powerVal = 4;
  inline bool has_powerval() const;
  inline void clear_powerval();
  static const int kPowerValFieldNumber = 4;
  inline ::google::protobuf::uint32 powerval() const;
  inline void set_powerval(::google::protobuf::uint32 value);

  // optional uint32 kwhVal = 5;
  inline bool has_kwhval() const;
  inline void clear_kwhval();
  static const int kKwhValFieldNumber = 5;
  inline ::google::protobuf::uint32 kwhval() const;
  inline void set_kwhval(::google::protobuf::uint32 value);

  // optional uint32 tempVal = 6;
  inline bool has_tempval() const;
  inline void clear_tempval();
  static const int kTempValFieldNumber = 6;
  inline ::google::protobuf::uint32 tempval() const;
  inline void set_tempval(::google::protobuf::uint32 value);

  // optional uint32 status = 7;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 7;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // optional uint32 swOnOff = 8;
  inline bool has_swonoff() const;
  inline void clear_swonoff();
  static const int kSwOnOffFieldNumber = 8;
  inline ::google::protobuf::uint32 swonoff() const;
  inline void set_swonoff(::google::protobuf::uint32 value);

  // optional uint32 temp1Outside = 9;
  inline bool has_temp1outside() const;
  inline void clear_temp1outside();
  static const int kTemp1OutsideFieldNumber = 9;
  inline ::google::protobuf::uint32 temp1outside() const;
  inline void set_temp1outside(::google::protobuf::uint32 value);

  // optional uint32 temp2Contact = 10;
  inline bool has_temp2contact() const;
  inline void clear_temp2contact();
  static const int kTemp2ContactFieldNumber = 10;
  inline ::google::protobuf::uint32 temp2contact() const;
  inline void set_temp2contact(::google::protobuf::uint32 value);

  // optional uint32 volHighTh = 11;
  inline bool has_volhighth() const;
  inline void clear_volhighth();
  static const int kVolHighThFieldNumber = 11;
  inline ::google::protobuf::uint32 volhighth() const;
  inline void set_volhighth(::google::protobuf::uint32 value);

  // optional uint32 volLowTh = 12;
  inline bool has_vollowth() const;
  inline void clear_vollowth();
  static const int kVolLowThFieldNumber = 12;
  inline ::google::protobuf::uint32 vollowth() const;
  inline void set_vollowth(::google::protobuf::uint32 value);

  // optional uint32 leakageTh = 13;
  inline bool has_leakageth() const;
  inline void clear_leakageth();
  static const int kLeakageThFieldNumber = 13;
  inline ::google::protobuf::uint32 leakageth() const;
  inline void set_leakageth(::google::protobuf::uint32 value);

  // optional uint32 tempTh = 14;
  inline bool has_tempth() const;
  inline void clear_tempth();
  static const int kTempThFieldNumber = 14;
  inline ::google::protobuf::uint32 tempth() const;
  inline void set_tempth(::google::protobuf::uint32 value);

  // optional uint32 currentTh = 15;
  inline bool has_currentth() const;
  inline void clear_currentth();
  static const int kCurrentThFieldNumber = 15;
  inline ::google::protobuf::uint32 currentth() const;
  inline void set_currentth(::google::protobuf::uint32 value);

  // optional uint32 powerTh = 16;
  inline bool has_powerth() const;
  inline void clear_powerth();
  static const int kPowerThFieldNumber = 16;
  inline ::google::protobuf::uint32 powerth() const;
  inline void set_powerth(::google::protobuf::uint32 value);

  // optional uint32 temp1OutsideTh = 17;
  inline bool has_temp1outsideth() const;
  inline void clear_temp1outsideth();
  static const int kTemp1OutsideThFieldNumber = 17;
  inline ::google::protobuf::uint32 temp1outsideth() const;
  inline void set_temp1outsideth(::google::protobuf::uint32 value);

  // optional uint32 temp2ContactTh = 18;
  inline bool has_temp2contactth() const;
  inline void clear_temp2contactth();
  static const int kTemp2ContactThFieldNumber = 18;
  inline ::google::protobuf::uint32 temp2contactth() const;
  inline void set_temp2contactth(::google::protobuf::uint32 value);

  // optional uint32 attribute = 19;
  inline bool has_attribute() const;
  inline void clear_attribute();
  static const int kAttributeFieldNumber = 19;
  inline ::google::protobuf::uint32 attribute() const;
  inline void set_attribute(::google::protobuf::uint32 value);

  // optional uint32 cmd = 20;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 20;
  inline ::google::protobuf::uint32 cmd() const;
  inline void set_cmd(::google::protobuf::uint32 value);

  // optional uint32 warning = 21;
  inline bool has_warning() const;
  inline void clear_warning();
  static const int kWarningFieldNumber = 21;
  inline ::google::protobuf::uint32 warning() const;
  inline void set_warning(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MantunData)
 private:
  inline void set_has_volval();
  inline void clear_has_volval();
  inline void set_has_currval();
  inline void clear_has_currval();
  inline void set_has_leakageval();
  inline void clear_has_leakageval();
  inline void set_has_powerval();
  inline void clear_has_powerval();
  inline void set_has_kwhval();
  inline void clear_has_kwhval();
  inline void set_has_tempval();
  inline void clear_has_tempval();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_swonoff();
  inline void clear_has_swonoff();
  inline void set_has_temp1outside();
  inline void clear_has_temp1outside();
  inline void set_has_temp2contact();
  inline void clear_has_temp2contact();
  inline void set_has_volhighth();
  inline void clear_has_volhighth();
  inline void set_has_vollowth();
  inline void clear_has_vollowth();
  inline void set_has_leakageth();
  inline void clear_has_leakageth();
  inline void set_has_tempth();
  inline void clear_has_tempth();
  inline void set_has_currentth();
  inline void clear_has_currentth();
  inline void set_has_powerth();
  inline void clear_has_powerth();
  inline void set_has_temp1outsideth();
  inline void clear_has_temp1outsideth();
  inline void set_has_temp2contactth();
  inline void clear_has_temp2contactth();
  inline void set_has_attribute();
  inline void clear_has_attribute();
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_warning();
  inline void clear_has_warning();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 volval_;
  ::google::protobuf::uint32 currval_;
  ::google::protobuf::uint32 leakageval_;
  ::google::protobuf::uint32 powerval_;
  ::google::protobuf::uint32 kwhval_;
  ::google::protobuf::uint32 tempval_;
  ::google::protobuf::uint32 status_;
  ::google::protobuf::uint32 swonoff_;
  ::google::protobuf::uint32 temp1outside_;
  ::google::protobuf::uint32 temp2contact_;
  ::google::protobuf::uint32 volhighth_;
  ::google::protobuf::uint32 vollowth_;
  ::google::protobuf::uint32 leakageth_;
  ::google::protobuf::uint32 tempth_;
  ::google::protobuf::uint32 currentth_;
  ::google::protobuf::uint32 powerth_;
  ::google::protobuf::uint32 temp1outsideth_;
  ::google::protobuf::uint32 temp2contactth_;
  ::google::protobuf::uint32 attribute_;
  ::google::protobuf::uint32 cmd_;
  ::google::protobuf::uint32 warning_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(21 + 31) / 32];

  friend void  protobuf_AddDesc_MsgNode_5f1v1_5fm13_2eproto();
  friend void protobuf_AssignDesc_MsgNode_5f1v1_5fm13_2eproto();
  friend void protobuf_ShutdownFile_MsgNode_5f1v1_5fm13_2eproto();

  void InitAsDefaultInstance();
  static MantunData* default_instance_;
};
// -------------------------------------------------------------------

class Cayman : public ::google::protobuf::Message {
 public:
  Cayman();
  virtual ~Cayman();

  Cayman(const Cayman& from);

  inline Cayman& operator=(const Cayman& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Cayman& default_instance();

  void Swap(Cayman* other);

  // implements Message ----------------------------------------------

  Cayman* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Cayman& from);
  void MergeFrom(const Cayman& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 isSmoke = 1;
  inline bool has_issmoke() const;
  inline void clear_issmoke();
  static const int kIsSmokeFieldNumber = 1;
  inline ::google::protobuf::uint32 issmoke() const;
  inline void set_issmoke(::google::protobuf::uint32 value);

  // optional uint32 isMoved = 2;
  inline bool has_ismoved() const;
  inline void clear_ismoved();
  static const int kIsMovedFieldNumber = 2;
  inline ::google::protobuf::uint32 ismoved() const;
  inline void set_ismoved(::google::protobuf::uint32 value);

  // optional sint32 valueOfTem = 3;
  inline bool has_valueoftem() const;
  inline void clear_valueoftem();
  static const int kValueOfTemFieldNumber = 3;
  inline ::google::protobuf::int32 valueoftem() const;
  inline void set_valueoftem(::google::protobuf::int32 value);

  // optional uint32 valueOfHum = 4;
  inline bool has_valueofhum() const;
  inline void clear_valueofhum();
  static const int kValueOfHumFieldNumber = 4;
  inline ::google::protobuf::uint32 valueofhum() const;
  inline void set_valueofhum(::google::protobuf::uint32 value);

  // optional uint32 valueOfSmoke = 5;
  inline bool has_valueofsmoke() const;
  inline void clear_valueofsmoke();
  static const int kValueOfSmokeFieldNumber = 5;
  inline ::google::protobuf::uint32 valueofsmoke() const;
  inline void set_valueofsmoke(::google::protobuf::uint32 value);

  // optional uint32 standarOfSmoke = 6;
  inline bool has_standarofsmoke() const;
  inline void clear_standarofsmoke();
  static const int kStandarOfSmokeFieldNumber = 6;
  inline ::google::protobuf::uint32 standarofsmoke() const;
  inline void set_standarofsmoke(::google::protobuf::uint32 value);

  // optional sint32 alarmOfHighTem = 7;
  inline bool has_alarmofhightem() const;
  inline void clear_alarmofhightem();
  static const int kAlarmOfHighTemFieldNumber = 7;
  inline ::google::protobuf::int32 alarmofhightem() const;
  inline void set_alarmofhightem(::google::protobuf::int32 value);

  // optional sint32 alarmOfLowTem = 8;
  inline bool has_alarmoflowtem() const;
  inline void clear_alarmoflowtem();
  static const int kAlarmOfLowTemFieldNumber = 8;
  inline ::google::protobuf::int32 alarmoflowtem() const;
  inline void set_alarmoflowtem(::google::protobuf::int32 value);

  // optional uint32 alarmOfHighHum = 9;
  inline bool has_alarmofhighhum() const;
  inline void clear_alarmofhighhum();
  static const int kAlarmOfHighHumFieldNumber = 9;
  inline ::google::protobuf::uint32 alarmofhighhum() const;
  inline void set_alarmofhighhum(::google::protobuf::uint32 value);

  // optional uint32 alarmOfLowHum = 10;
  inline bool has_alarmoflowhum() const;
  inline void clear_alarmoflowhum();
  static const int kAlarmOfLowHumFieldNumber = 10;
  inline ::google::protobuf::uint32 alarmoflowhum() const;
  inline void set_alarmoflowhum(::google::protobuf::uint32 value);

  // optional uint32 cmd = 11;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 11;
  inline ::google::protobuf::uint32 cmd() const;
  inline void set_cmd(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Cayman)
 private:
  inline void set_has_issmoke();
  inline void clear_has_issmoke();
  inline void set_has_ismoved();
  inline void clear_has_ismoved();
  inline void set_has_valueoftem();
  inline void clear_has_valueoftem();
  inline void set_has_valueofhum();
  inline void clear_has_valueofhum();
  inline void set_has_valueofsmoke();
  inline void clear_has_valueofsmoke();
  inline void set_has_standarofsmoke();
  inline void clear_has_standarofsmoke();
  inline void set_has_alarmofhightem();
  inline void clear_has_alarmofhightem();
  inline void set_has_alarmoflowtem();
  inline void clear_has_alarmoflowtem();
  inline void set_has_alarmofhighhum();
  inline void clear_has_alarmofhighhum();
  inline void set_has_alarmoflowhum();
  inline void clear_has_alarmoflowhum();
  inline void set_has_cmd();
  inline void clear_has_cmd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 issmoke_;
  ::google::protobuf::uint32 ismoved_;
  ::google::protobuf::int32 valueoftem_;
  ::google::protobuf::uint32 valueofhum_;
  ::google::protobuf::uint32 valueofsmoke_;
  ::google::protobuf::uint32 standarofsmoke_;
  ::google::protobuf::int32 alarmofhightem_;
  ::google::protobuf::int32 alarmoflowtem_;
  ::google::protobuf::uint32 alarmofhighhum_;
  ::google::protobuf::uint32 alarmoflowhum_;
  ::google::protobuf::uint32 cmd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_MsgNode_5f1v1_5fm13_2eproto();
  friend void protobuf_AssignDesc_MsgNode_5f1v1_5fm13_2eproto();
  friend void protobuf_ShutdownFile_MsgNode_5f1v1_5fm13_2eproto();

  void InitAsDefaultInstance();
  static Cayman* default_instance_;
};
// -------------------------------------------------------------------

class AcrelData : public ::google::protobuf::Message {
 public:
  AcrelData();
  virtual ~AcrelData();

  AcrelData(const AcrelData& from);

  inline AcrelData& operator=(const AcrelData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AcrelData& default_instance();

  void Swap(AcrelData* other);

  // implements Message ----------------------------------------------

  AcrelData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AcrelData& from);
  void MergeFrom(const AcrelData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 channelType = 1;
  inline bool has_channeltype() const;
  inline void clear_channeltype();
  static const int kChannelTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 channeltype() const;
  inline void set_channeltype(::google::protobuf::uint32 value);

  // optional uint32 shortCircuit = 2;
  inline bool has_shortcircuit() const;
  inline void clear_shortcircuit();
  static const int kShortCircuitFieldNumber = 2;
  inline ::google::protobuf::uint32 shortcircuit() const;
  inline void set_shortcircuit(::google::protobuf::uint32 value);

  // optional uint32 openCircuit = 3;
  inline bool has_opencircuit() const;
  inline void clear_opencircuit();
  static const int kOpenCircuitFieldNumber = 3;
  inline ::google::protobuf::uint32 opencircuit() const;
  inline void set_opencircuit(::google::protobuf::uint32 value);

  // optional uint32 chStatus = 4;
  inline bool has_chstatus() const;
  inline void clear_chstatus();
  static const int kChStatusFieldNumber = 4;
  inline ::google::protobuf::uint32 chstatus() const;
  inline void set_chstatus(::google::protobuf::uint32 value);

  // optional sint32 leakageVal = 5;
  inline bool has_leakageval() const;
  inline void clear_leakageval();
  static const int kLeakageValFieldNumber = 5;
  inline ::google::protobuf::int32 leakageval() const;
  inline void set_leakageval(::google::protobuf::int32 value);

  // optional sint32 t1Val = 6;
  inline bool has_t1val() const;
  inline void clear_t1val();
  static const int kT1ValFieldNumber = 6;
  inline ::google::protobuf::int32 t1val() const;
  inline void set_t1val(::google::protobuf::int32 value);

  // optional sint32 t2Val = 7;
  inline bool has_t2val() const;
  inline void clear_t2val();
  static const int kT2ValFieldNumber = 7;
  inline ::google::protobuf::int32 t2val() const;
  inline void set_t2val(::google::protobuf::int32 value);

  // optional sint32 t3Val = 8;
  inline bool has_t3val() const;
  inline void clear_t3val();
  static const int kT3ValFieldNumber = 8;
  inline ::google::protobuf::int32 t3val() const;
  inline void set_t3val(::google::protobuf::int32 value);

  // optional sint32 t4Val = 9;
  inline bool has_t4val() const;
  inline void clear_t4val();
  static const int kT4ValFieldNumber = 9;
  inline ::google::protobuf::int32 t4val() const;
  inline void set_t4val(::google::protobuf::int32 value);

  // optional uint32 connectSw = 10;
  inline bool has_connectsw() const;
  inline void clear_connectsw();
  static const int kConnectSwFieldNumber = 10;
  inline ::google::protobuf::uint32 connectsw() const;
  inline void set_connectsw(::google::protobuf::uint32 value);

  // optional uint32 chEnable = 11;
  inline bool has_chenable() const;
  inline void clear_chenable();
  static const int kChEnableFieldNumber = 11;
  inline ::google::protobuf::uint32 chenable() const;
  inline void set_chenable(::google::protobuf::uint32 value);

  // optional uint32 leakageTh = 12;
  inline bool has_leakageth() const;
  inline void clear_leakageth();
  static const int kLeakageThFieldNumber = 12;
  inline ::google::protobuf::uint32 leakageth() const;
  inline void set_leakageth(::google::protobuf::uint32 value);

  // optional uint32 t1Th = 13;
  inline bool has_t1th() const;
  inline void clear_t1th();
  static const int kT1ThFieldNumber = 13;
  inline ::google::protobuf::uint32 t1th() const;
  inline void set_t1th(::google::protobuf::uint32 value);

  // optional uint32 t2Th = 14;
  inline bool has_t2th() const;
  inline void clear_t2th();
  static const int kT2ThFieldNumber = 14;
  inline ::google::protobuf::uint32 t2th() const;
  inline void set_t2th(::google::protobuf::uint32 value);

  // optional uint32 t3Th = 15;
  inline bool has_t3th() const;
  inline void clear_t3th();
  static const int kT3ThFieldNumber = 15;
  inline ::google::protobuf::uint32 t3th() const;
  inline void set_t3th(::google::protobuf::uint32 value);

  // optional uint32 t4Th = 16;
  inline bool has_t4th() const;
  inline void clear_t4th();
  static const int kT4ThFieldNumber = 16;
  inline ::google::protobuf::uint32 t4th() const;
  inline void set_t4th(::google::protobuf::uint32 value);

  // optional uint32 passwd = 17;
  inline bool has_passwd() const;
  inline void clear_passwd();
  static const int kPasswdFieldNumber = 17;
  inline ::google::protobuf::uint32 passwd() const;
  inline void set_passwd(::google::protobuf::uint32 value);

  // optional uint32 aVal = 18;
  inline bool has_aval() const;
  inline void clear_aval();
  static const int kAValFieldNumber = 18;
  inline ::google::protobuf::uint32 aval() const;
  inline void set_aval(::google::protobuf::uint32 value);

  // optional uint32 bVal = 19;
  inline bool has_bval() const;
  inline void clear_bval();
  static const int kBValFieldNumber = 19;
  inline ::google::protobuf::uint32 bval() const;
  inline void set_bval(::google::protobuf::uint32 value);

  // optional uint32 cVal = 20;
  inline bool has_cval() const;
  inline void clear_cval();
  static const int kCValFieldNumber = 20;
  inline ::google::protobuf::uint32 cval() const;
  inline void set_cval(::google::protobuf::uint32 value);

  // optional uint32 valStatus = 21;
  inline bool has_valstatus() const;
  inline void clear_valstatus();
  static const int kValStatusFieldNumber = 21;
  inline ::google::protobuf::uint32 valstatus() const;
  inline void set_valstatus(::google::protobuf::uint32 value);

  // optional uint32 aCurr = 22;
  inline bool has_acurr() const;
  inline void clear_acurr();
  static const int kACurrFieldNumber = 22;
  inline ::google::protobuf::uint32 acurr() const;
  inline void set_acurr(::google::protobuf::uint32 value);

  // optional uint32 bCurr = 23;
  inline bool has_bcurr() const;
  inline void clear_bcurr();
  static const int kBCurrFieldNumber = 23;
  inline ::google::protobuf::uint32 bcurr() const;
  inline void set_bcurr(::google::protobuf::uint32 value);

  // optional uint32 cCurr = 24;
  inline bool has_ccurr() const;
  inline void clear_ccurr();
  static const int kCCurrFieldNumber = 24;
  inline ::google::protobuf::uint32 ccurr() const;
  inline void set_ccurr(::google::protobuf::uint32 value);

  // optional uint32 currStatus = 25;
  inline bool has_currstatus() const;
  inline void clear_currstatus();
  static const int kCurrStatusFieldNumber = 25;
  inline ::google::protobuf::uint32 currstatus() const;
  inline void set_currstatus(::google::protobuf::uint32 value);

  // optional uint32 totalYg = 26;
  inline bool has_totalyg() const;
  inline void clear_totalyg();
  static const int kTotalYgFieldNumber = 26;
  inline ::google::protobuf::uint32 totalyg() const;
  inline void set_totalyg(::google::protobuf::uint32 value);

  // optional uint32 totalWg = 27;
  inline bool has_totalwg() const;
  inline void clear_totalwg();
  static const int kTotalWgFieldNumber = 27;
  inline ::google::protobuf::uint32 totalwg() const;
  inline void set_totalwg(::google::protobuf::uint32 value);

  // optional uint32 totalSz = 28;
  inline bool has_totalsz() const;
  inline void clear_totalsz();
  static const int kTotalSzFieldNumber = 28;
  inline ::google::protobuf::uint32 totalsz() const;
  inline void set_totalsz(::google::protobuf::uint32 value);

  // optional uint32 totalFactor = 29;
  inline bool has_totalfactor() const;
  inline void clear_totalfactor();
  static const int kTotalFactorFieldNumber = 29;
  inline ::google::protobuf::uint32 totalfactor() const;
  inline void set_totalfactor(::google::protobuf::uint32 value);

  // optional uint32 valHighSet = 30;
  inline bool has_valhighset() const;
  inline void clear_valhighset();
  static const int kValHighSetFieldNumber = 30;
  inline ::google::protobuf::uint32 valhighset() const;
  inline void set_valhighset(::google::protobuf::uint32 value);

  // optional uint32 valLowSet = 31;
  inline bool has_vallowset() const;
  inline void clear_vallowset();
  static const int kValLowSetFieldNumber = 31;
  inline ::google::protobuf::uint32 vallowset() const;
  inline void set_vallowset(::google::protobuf::uint32 value);

  // optional uint32 currHighSet = 32;
  inline bool has_currhighset() const;
  inline void clear_currhighset();
  static const int kCurrHighSetFieldNumber = 32;
  inline ::google::protobuf::uint32 currhighset() const;
  inline void set_currhighset(::google::protobuf::uint32 value);

  // optional uint32 energyKwh = 33;
  inline bool has_energykwh() const;
  inline void clear_energykwh();
  static const int kEnergyKwhFieldNumber = 33;
  inline ::google::protobuf::uint32 energykwh() const;
  inline void set_energykwh(::google::protobuf::uint32 value);

  // optional uint32 currentTh = 34;
  inline bool has_currentth() const;
  inline void clear_currentth();
  static const int kCurrentThFieldNumber = 34;
  inline ::google::protobuf::uint32 currentth() const;
  inline void set_currentth(::google::protobuf::uint32 value);

  // optional uint32 cmd = 35;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 35;
  inline ::google::protobuf::uint32 cmd() const;
  inline void set_cmd(::google::protobuf::uint32 value);

  // optional uint32 devError = 36;
  inline bool has_deverror() const;
  inline void clear_deverror();
  static const int kDevErrorFieldNumber = 36;
  inline ::google::protobuf::uint32 deverror() const;
  inline void set_deverror(::google::protobuf::uint32 value);

  // optional uint32 ct = 37;
  inline bool has_ct() const;
  inline void clear_ct();
  static const int kCtFieldNumber = 37;
  inline ::google::protobuf::uint32 ct() const;
  inline void set_ct(::google::protobuf::uint32 value);

  // optional uint32 outputSw = 38;
  inline bool has_outputsw() const;
  inline void clear_outputsw();
  static const int kOutputSwFieldNumber = 38;
  inline ::google::protobuf::uint32 outputsw() const;
  inline void set_outputsw(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:AcrelData)
 private:
  inline void set_has_channeltype();
  inline void clear_has_channeltype();
  inline void set_has_shortcircuit();
  inline void clear_has_shortcircuit();
  inline void set_has_opencircuit();
  inline void clear_has_opencircuit();
  inline void set_has_chstatus();
  inline void clear_has_chstatus();
  inline void set_has_leakageval();
  inline void clear_has_leakageval();
  inline void set_has_t1val();
  inline void clear_has_t1val();
  inline void set_has_t2val();
  inline void clear_has_t2val();
  inline void set_has_t3val();
  inline void clear_has_t3val();
  inline void set_has_t4val();
  inline void clear_has_t4val();
  inline void set_has_connectsw();
  inline void clear_has_connectsw();
  inline void set_has_chenable();
  inline void clear_has_chenable();
  inline void set_has_leakageth();
  inline void clear_has_leakageth();
  inline void set_has_t1th();
  inline void clear_has_t1th();
  inline void set_has_t2th();
  inline void clear_has_t2th();
  inline void set_has_t3th();
  inline void clear_has_t3th();
  inline void set_has_t4th();
  inline void clear_has_t4th();
  inline void set_has_passwd();
  inline void clear_has_passwd();
  inline void set_has_aval();
  inline void clear_has_aval();
  inline void set_has_bval();
  inline void clear_has_bval();
  inline void set_has_cval();
  inline void clear_has_cval();
  inline void set_has_valstatus();
  inline void clear_has_valstatus();
  inline void set_has_acurr();
  inline void clear_has_acurr();
  inline void set_has_bcurr();
  inline void clear_has_bcurr();
  inline void set_has_ccurr();
  inline void clear_has_ccurr();
  inline void set_has_currstatus();
  inline void clear_has_currstatus();
  inline void set_has_totalyg();
  inline void clear_has_totalyg();
  inline void set_has_totalwg();
  inline void clear_has_totalwg();
  inline void set_has_totalsz();
  inline void clear_has_totalsz();
  inline void set_has_totalfactor();
  inline void clear_has_totalfactor();
  inline void set_has_valhighset();
  inline void clear_has_valhighset();
  inline void set_has_vallowset();
  inline void clear_has_vallowset();
  inline void set_has_currhighset();
  inline void clear_has_currhighset();
  inline void set_has_energykwh();
  inline void clear_has_energykwh();
  inline void set_has_currentth();
  inline void clear_has_currentth();
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_deverror();
  inline void clear_has_deverror();
  inline void set_has_ct();
  inline void clear_has_ct();
  inline void set_has_outputsw();
  inline void clear_has_outputsw();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 channeltype_;
  ::google::protobuf::uint32 shortcircuit_;
  ::google::protobuf::uint32 opencircuit_;
  ::google::protobuf::uint32 chstatus_;
  ::google::protobuf::int32 leakageval_;
  ::google::protobuf::int32 t1val_;
  ::google::protobuf::int32 t2val_;
  ::google::protobuf::int32 t3val_;
  ::google::protobuf::int32 t4val_;
  ::google::protobuf::uint32 connectsw_;
  ::google::protobuf::uint32 chenable_;
  ::google::protobuf::uint32 leakageth_;
  ::google::protobuf::uint32 t1th_;
  ::google::protobuf::uint32 t2th_;
  ::google::protobuf::uint32 t3th_;
  ::google::protobuf::uint32 t4th_;
  ::google::protobuf::uint32 passwd_;
  ::google::protobuf::uint32 aval_;
  ::google::protobuf::uint32 bval_;
  ::google::protobuf::uint32 cval_;
  ::google::protobuf::uint32 valstatus_;
  ::google::protobuf::uint32 acurr_;
  ::google::protobuf::uint32 bcurr_;
  ::google::protobuf::uint32 ccurr_;
  ::google::protobuf::uint32 currstatus_;
  ::google::protobuf::uint32 totalyg_;
  ::google::protobuf::uint32 totalwg_;
  ::google::protobuf::uint32 totalsz_;
  ::google::protobuf::uint32 totalfactor_;
  ::google::protobuf::uint32 valhighset_;
  ::google::protobuf::uint32 vallowset_;
  ::google::protobuf::uint32 currhighset_;
  ::google::protobuf::uint32 energykwh_;
  ::google::protobuf::uint32 currentth_;
  ::google::protobuf::uint32 cmd_;
  ::google::protobuf::uint32 deverror_;
  ::google::protobuf::uint32 ct_;
  ::google::protobuf::uint32 outputsw_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(38 + 31) / 32];

  friend void  protobuf_AddDesc_MsgNode_5f1v1_5fm13_2eproto();
  friend void protobuf_AssignDesc_MsgNode_5f1v1_5fm13_2eproto();
  friend void protobuf_ShutdownFile_MsgNode_5f1v1_5fm13_2eproto();

  void InitAsDefaultInstance();
  static AcrelData* default_instance_;
};
// -------------------------------------------------------------------

class MsgNode : public ::google::protobuf::Message {
 public:
  MsgNode();
  virtual ~MsgNode();

  MsgNode(const MsgNode& from);

  inline MsgNode& operator=(const MsgNode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgNode& default_instance();

  void Swap(MsgNode* other);

  // implements Message ----------------------------------------------

  MsgNode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgNode& from);
  void MergeFrom(const MsgNode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional uint32 cmd = 2;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 2;
  inline ::google::protobuf::uint32 cmd() const;
  inline void set_cmd(::google::protobuf::uint32 value);

  // optional uint32 cmdRet = 3;
  inline bool has_cmdret() const;
  inline void clear_cmdret();
  static const int kCmdRetFieldNumber = 3;
  inline ::google::protobuf::uint32 cmdret() const;
  inline void set_cmdret(::google::protobuf::uint32 value);

  // optional .LpwanParam lpwanParam = 4;
  inline bool has_lpwanparam() const;
  inline void clear_lpwanparam();
  static const int kLpwanParamFieldNumber = 4;
  inline const ::LpwanParam& lpwanparam() const;
  inline ::LpwanParam* mutable_lpwanparam();
  inline ::LpwanParam* release_lpwanparam();
  inline void set_allocated_lpwanparam(::LpwanParam* lpwanparam);

  // optional .BleParam bleParam = 5;
  inline bool has_bleparam() const;
  inline void clear_bleparam();
  static const int kBleParamFieldNumber = 5;
  inline const ::BleParam& bleparam() const;
  inline ::BleParam* mutable_bleparam();
  inline ::BleParam* release_bleparam();
  inline void set_allocated_bleparam(::BleParam* bleparam);

  // optional .AppParam appParam = 6;
  inline bool has_appparam() const;
  inline void clear_appparam();
  static const int kAppParamFieldNumber = 6;
  inline const ::AppParam& appparam() const;
  inline ::AppParam* mutable_appparam();
  inline ::AppParam* release_appparam();
  inline void set_allocated_appparam(::AppParam* appparam);

  // optional sint32 battery = 7;
  inline bool has_battery() const;
  inline void clear_battery();
  static const int kBatteryFieldNumber = 7;
  inline ::google::protobuf::int32 battery() const;
  inline void set_battery(::google::protobuf::int32 value);

  // optional .GpsData gps = 8;
  inline bool has_gps() const;
  inline void clear_gps();
  static const int kGpsFieldNumber = 8;
  inline const ::GpsData& gps() const;
  inline ::GpsData* mutable_gps();
  inline ::GpsData* release_gps();
  inline void set_allocated_gps(::GpsData* gps);

  // optional .AxisData acceleration = 9;
  inline bool has_acceleration() const;
  inline void clear_acceleration();
  static const int kAccelerationFieldNumber = 9;
  inline const ::AxisData& acceleration() const;
  inline ::AxisData* mutable_acceleration();
  inline ::AxisData* release_acceleration();
  inline void set_allocated_acceleration(::AxisData* acceleration);

  // optional .AxisData magnetism = 10;
  inline bool has_magnetism() const;
  inline void clear_magnetism();
  static const int kMagnetismFieldNumber = 10;
  inline const ::AxisData& magnetism() const;
  inline ::AxisData* mutable_magnetism();
  inline ::AxisData* release_magnetism();
  inline void set_allocated_magnetism(::AxisData* magnetism);

  // optional .AxisData gyroscope = 11;
  inline bool has_gyroscope() const;
  inline void clear_gyroscope();
  static const int kGyroscopeFieldNumber = 11;
  inline const ::AxisData& gyroscope() const;
  inline ::AxisData* mutable_gyroscope();
  inline ::AxisData* release_gyroscope();
  inline void set_allocated_gyroscope(::AxisData* gyroscope);

  // optional .SensorData temperature = 12;
  inline bool has_temperature() const;
  inline void clear_temperature();
  static const int kTemperatureFieldNumber = 12;
  inline const ::SensorData& temperature() const;
  inline ::SensorData* mutable_temperature();
  inline ::SensorData* release_temperature();
  inline void set_allocated_temperature(::SensorData* temperature);

  // optional .SensorData humidity = 13;
  inline bool has_humidity() const;
  inline void clear_humidity();
  static const int kHumidityFieldNumber = 13;
  inline const ::SensorData& humidity() const;
  inline ::SensorData* mutable_humidity();
  inline ::SensorData* release_humidity();
  inline void set_allocated_humidity(::SensorData* humidity);

  // optional .SensorData light = 14;
  inline bool has_light() const;
  inline void clear_light();
  static const int kLightFieldNumber = 14;
  inline const ::SensorData& light() const;
  inline ::SensorData* mutable_light();
  inline ::SensorData* release_light();
  inline void set_allocated_light(::SensorData* light);

  // optional .SensorData leak = 15;
  inline bool has_leak() const;
  inline void clear_leak();
  static const int kLeakFieldNumber = 15;
  inline const ::SensorData& leak() const;
  inline ::SensorData* mutable_leak();
  inline ::SensorData* release_leak();
  inline void set_allocated_leak(::SensorData* leak);

  // optional .SensorData co = 16;
  inline bool has_co() const;
  inline void clear_co();
  static const int kCoFieldNumber = 16;
  inline const ::SensorData& co() const;
  inline ::SensorData* mutable_co();
  inline ::SensorData* release_co();
  inline void set_allocated_co(::SensorData* co);

  // optional .SensorData co2 = 17;
  inline bool has_co2() const;
  inline void clear_co2();
  static const int kCo2FieldNumber = 17;
  inline const ::SensorData& co2() const;
  inline ::SensorData* mutable_co2();
  inline ::SensorData* release_co2();
  inline void set_allocated_co2(::SensorData* co2);

  // optional .SensorData so2 = 18;
  inline bool has_so2() const;
  inline void clear_so2();
  static const int kSo2FieldNumber = 18;
  inline const ::SensorData& so2() const;
  inline ::SensorData* mutable_so2();
  inline ::SensorData* release_so2();
  inline void set_allocated_so2(::SensorData* so2);

  // optional .SensorData no2 = 19;
  inline bool has_no2() const;
  inline void clear_no2();
  static const int kNo2FieldNumber = 19;
  inline const ::SensorData& no2() const;
  inline ::SensorData* mutable_no2();
  inline ::SensorData* release_no2();
  inline void set_allocated_no2(::SensorData* no2);

  // optional .SensorData ch4 = 20;
  inline bool has_ch4() const;
  inline void clear_ch4();
  static const int kCh4FieldNumber = 20;
  inline const ::SensorData& ch4() const;
  inline ::SensorData* mutable_ch4();
  inline ::SensorData* release_ch4();
  inline void set_allocated_ch4(::SensorData* ch4);

  // optional .SensorData ch2o = 21;
  inline bool has_ch2o() const;
  inline void clear_ch2o();
  static const int kCh2OFieldNumber = 21;
  inline const ::SensorData& ch2o() const;
  inline ::SensorData* mutable_ch2o();
  inline ::SensorData* release_ch2o();
  inline void set_allocated_ch2o(::SensorData* ch2o);

  // optional .SensorData lpg = 22;
  inline bool has_lpg() const;
  inline void clear_lpg();
  static const int kLpgFieldNumber = 22;
  inline const ::SensorData& lpg() const;
  inline ::SensorData* mutable_lpg();
  inline ::SensorData* release_lpg();
  inline void set_allocated_lpg(::SensorData* lpg);

  // optional .SensorData o3 = 23;
  inline bool has_o3() const;
  inline void clear_o3();
  static const int kO3FieldNumber = 23;
  inline const ::SensorData& o3() const;
  inline ::SensorData* mutable_o3();
  inline ::SensorData* release_o3();
  inline void set_allocated_o3(::SensorData* o3);

  // optional .SensorData pm1 = 24;
  inline bool has_pm1() const;
  inline void clear_pm1();
  static const int kPm1FieldNumber = 24;
  inline const ::SensorData& pm1() const;
  inline ::SensorData* mutable_pm1();
  inline ::SensorData* release_pm1();
  inline void set_allocated_pm1(::SensorData* pm1);

  // optional .SensorData pm2_5 = 25;
  inline bool has_pm2_5() const;
  inline void clear_pm2_5();
  static const int kPm25FieldNumber = 25;
  inline const ::SensorData& pm2_5() const;
  inline ::SensorData* mutable_pm2_5();
  inline ::SensorData* release_pm2_5();
  inline void set_allocated_pm2_5(::SensorData* pm2_5);

  // optional .SensorData pm10 = 26;
  inline bool has_pm10() const;
  inline void clear_pm10();
  static const int kPm10FieldNumber = 26;
  inline const ::SensorData& pm10() const;
  inline ::SensorData* mutable_pm10();
  inline ::SensorData* release_pm10();
  inline void set_allocated_pm10(::SensorData* pm10);

  // optional .SensorData angle = 27;
  inline bool has_angle() const;
  inline void clear_angle();
  static const int kAngleFieldNumber = 27;
  inline const ::SensorData& angle() const;
  inline ::SensorData* mutable_angle();
  inline ::SensorData* release_angle();
  inline void set_allocated_angle(::SensorData* angle);

  // optional .SensorData cover = 28;
  inline bool has_cover() const;
  inline void clear_cover();
  static const int kCoverFieldNumber = 28;
  inline const ::SensorData& cover() const;
  inline ::SensorData* mutable_cover();
  inline ::SensorData* release_cover();
  inline void set_allocated_cover(::SensorData* cover);

  // optional .SensorData level = 29;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 29;
  inline const ::SensorData& level() const;
  inline ::SensorData* mutable_level();
  inline ::SensorData* release_level();
  inline void set_allocated_level(::SensorData* level);

  // optional .SensorData smoke = 30;
  inline bool has_smoke() const;
  inline void clear_smoke();
  static const int kSmokeFieldNumber = 30;
  inline const ::SensorData& smoke() const;
  inline ::SensorData* mutable_smoke();
  inline ::SensorData* release_smoke();
  inline void set_allocated_smoke(::SensorData* smoke);

  // optional .SensorData pitch = 31;
  inline bool has_pitch() const;
  inline void clear_pitch();
  static const int kPitchFieldNumber = 31;
  inline const ::SensorData& pitch() const;
  inline ::SensorData* mutable_pitch();
  inline ::SensorData* release_pitch();
  inline void set_allocated_pitch(::SensorData* pitch);

  // optional .SensorData roll = 32;
  inline bool has_roll() const;
  inline void clear_roll();
  static const int kRollFieldNumber = 32;
  inline const ::SensorData& roll() const;
  inline ::SensorData* mutable_roll();
  inline ::SensorData* release_roll();
  inline void set_allocated_roll(::SensorData* roll);

  // optional .SensorData yaw = 33;
  inline bool has_yaw() const;
  inline void clear_yaw();
  static const int kYawFieldNumber = 33;
  inline const ::SensorData& yaw() const;
  inline ::SensorData* mutable_yaw();
  inline ::SensorData* release_yaw();
  inline void set_allocated_yaw(::SensorData* yaw);

  // optional .SensorDataInt flame = 34;
  inline bool has_flame() const;
  inline void clear_flame();
  static const int kFlameFieldNumber = 34;
  inline const ::SensorDataInt& flame() const;
  inline ::SensorDataInt* mutable_flame();
  inline ::SensorDataInt* release_flame();
  inline void set_allocated_flame(::SensorDataInt* flame);

  // optional .SensorData artificialGas = 35;
  inline bool has_artificialgas() const;
  inline void clear_artificialgas();
  static const int kArtificialGasFieldNumber = 35;
  inline const ::SensorData& artificialgas() const;
  inline ::SensorData* mutable_artificialgas();
  inline ::SensorData* release_artificialgas();
  inline void set_allocated_artificialgas(::SensorData* artificialgas);

  // optional .MultiSensorDataInt multiTemp = 36;
  inline bool has_multitemp() const;
  inline void clear_multitemp();
  static const int kMultiTempFieldNumber = 36;
  inline const ::MultiSensorDataInt& multitemp() const;
  inline ::MultiSensorDataInt* mutable_multitemp();
  inline ::MultiSensorDataInt* release_multitemp();
  inline void set_allocated_multitemp(::MultiSensorDataInt* multitemp);

  // optional .SensorData waterPressure = 37;
  inline bool has_waterpressure() const;
  inline void clear_waterpressure();
  static const int kWaterPressureFieldNumber = 37;
  inline const ::SensorData& waterpressure() const;
  inline ::SensorData* mutable_waterpressure();
  inline ::SensorData* release_waterpressure();
  inline void set_allocated_waterpressure(::SensorData* waterpressure);

  // optional .iBeacon ibeacon = 38;
  inline bool has_ibeacon() const;
  inline void clear_ibeacon();
  static const int kIbeaconFieldNumber = 38;
  inline const ::iBeacon& ibeacon() const;
  inline ::iBeacon* mutable_ibeacon();
  inline ::iBeacon* release_ibeacon();
  inline void set_allocated_ibeacon(::iBeacon* ibeacon);

  // repeated .SensorData sensors = 39;
  inline int sensors_size() const;
  inline void clear_sensors();
  static const int kSensorsFieldNumber = 39;
  inline const ::SensorData& sensors(int index) const;
  inline ::SensorData* mutable_sensors(int index);
  inline ::SensorData* add_sensors();
  inline const ::google::protobuf::RepeatedPtrField< ::SensorData >&
      sensors() const;
  inline ::google::protobuf::RepeatedPtrField< ::SensorData >*
      mutable_sensors();

  // optional bool installed = 40;
  inline bool has_installed() const;
  inline void clear_installed();
  static const int kInstalledFieldNumber = 40;
  inline bool installed() const;
  inline void set_installed(bool value);

  // optional .ExtSmoke extSmoke = 41;
  inline bool has_extsmoke() const;
  inline void clear_extsmoke();
  static const int kExtSmokeFieldNumber = 41;
  inline const ::ExtSmoke& extsmoke() const;
  inline ::ExtSmoke* mutable_extsmoke();
  inline ::ExtSmoke* release_extsmoke();
  inline void set_allocated_extsmoke(::ExtSmoke* extsmoke);

  // optional .ElecFireData fireData = 42;
  inline bool has_firedata() const;
  inline void clear_firedata();
  static const int kFireDataFieldNumber = 42;
  inline const ::ElecFireData& firedata() const;
  inline ::ElecFireData* mutable_firedata();
  inline ::ElecFireData* release_firedata();
  inline void set_allocated_firedata(::ElecFireData* firedata);

  // optional .MantunData mtunData = 43;
  inline bool has_mtundata() const;
  inline void clear_mtundata();
  static const int kMtunDataFieldNumber = 43;
  inline const ::MantunData& mtundata() const;
  inline ::MantunData* mutable_mtundata();
  inline ::MantunData* release_mtundata();
  inline void set_allocated_mtundata(::MantunData* mtundata);

  // optional .AcrelData acrelData = 44;
  inline bool has_acreldata() const;
  inline void clear_acreldata();
  static const int kAcrelDataFieldNumber = 44;
  inline const ::AcrelData& acreldata() const;
  inline ::AcrelData* mutable_acreldata();
  inline ::AcrelData* release_acreldata();
  inline void set_allocated_acreldata(::AcrelData* acreldata);

  // optional .Cayman caymanData = 45;
  inline bool has_caymandata() const;
  inline void clear_caymandata();
  static const int kCaymanDataFieldNumber = 45;
  inline const ::Cayman& caymandata() const;
  inline ::Cayman* mutable_caymandata();
  inline ::Cayman* release_caymandata();
  inline void set_allocated_caymandata(::Cayman* caymandata);

  // @@protoc_insertion_point(class_scope:MsgNode)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_cmdret();
  inline void clear_has_cmdret();
  inline void set_has_lpwanparam();
  inline void clear_has_lpwanparam();
  inline void set_has_bleparam();
  inline void clear_has_bleparam();
  inline void set_has_appparam();
  inline void clear_has_appparam();
  inline void set_has_battery();
  inline void clear_has_battery();
  inline void set_has_gps();
  inline void clear_has_gps();
  inline void set_has_acceleration();
  inline void clear_has_acceleration();
  inline void set_has_magnetism();
  inline void clear_has_magnetism();
  inline void set_has_gyroscope();
  inline void clear_has_gyroscope();
  inline void set_has_temperature();
  inline void clear_has_temperature();
  inline void set_has_humidity();
  inline void clear_has_humidity();
  inline void set_has_light();
  inline void clear_has_light();
  inline void set_has_leak();
  inline void clear_has_leak();
  inline void set_has_co();
  inline void clear_has_co();
  inline void set_has_co2();
  inline void clear_has_co2();
  inline void set_has_so2();
  inline void clear_has_so2();
  inline void set_has_no2();
  inline void clear_has_no2();
  inline void set_has_ch4();
  inline void clear_has_ch4();
  inline void set_has_ch2o();
  inline void clear_has_ch2o();
  inline void set_has_lpg();
  inline void clear_has_lpg();
  inline void set_has_o3();
  inline void clear_has_o3();
  inline void set_has_pm1();
  inline void clear_has_pm1();
  inline void set_has_pm2_5();
  inline void clear_has_pm2_5();
  inline void set_has_pm10();
  inline void clear_has_pm10();
  inline void set_has_angle();
  inline void clear_has_angle();
  inline void set_has_cover();
  inline void clear_has_cover();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_smoke();
  inline void clear_has_smoke();
  inline void set_has_pitch();
  inline void clear_has_pitch();
  inline void set_has_roll();
  inline void clear_has_roll();
  inline void set_has_yaw();
  inline void clear_has_yaw();
  inline void set_has_flame();
  inline void clear_has_flame();
  inline void set_has_artificialgas();
  inline void clear_has_artificialgas();
  inline void set_has_multitemp();
  inline void clear_has_multitemp();
  inline void set_has_waterpressure();
  inline void clear_has_waterpressure();
  inline void set_has_ibeacon();
  inline void clear_has_ibeacon();
  inline void set_has_installed();
  inline void clear_has_installed();
  inline void set_has_extsmoke();
  inline void clear_has_extsmoke();
  inline void set_has_firedata();
  inline void clear_has_firedata();
  inline void set_has_mtundata();
  inline void clear_has_mtundata();
  inline void set_has_acreldata();
  inline void clear_has_acreldata();
  inline void set_has_caymandata();
  inline void clear_has_caymandata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 cmd_;
  ::LpwanParam* lpwanparam_;
  ::google::protobuf::uint32 cmdret_;
  ::google::protobuf::int32 battery_;
  ::BleParam* bleparam_;
  ::AppParam* appparam_;
  ::GpsData* gps_;
  ::AxisData* acceleration_;
  ::AxisData* magnetism_;
  ::AxisData* gyroscope_;
  ::SensorData* temperature_;
  ::SensorData* humidity_;
  ::SensorData* light_;
  ::SensorData* leak_;
  ::SensorData* co_;
  ::SensorData* co2_;
  ::SensorData* so2_;
  ::SensorData* no2_;
  ::SensorData* ch4_;
  ::SensorData* ch2o_;
  ::SensorData* lpg_;
  ::SensorData* o3_;
  ::SensorData* pm1_;
  ::SensorData* pm2_5_;
  ::SensorData* pm10_;
  ::SensorData* angle_;
  ::SensorData* cover_;
  ::SensorData* level_;
  ::SensorData* smoke_;
  ::SensorData* pitch_;
  ::SensorData* roll_;
  ::SensorData* yaw_;
  ::SensorDataInt* flame_;
  ::SensorData* artificialgas_;
  ::MultiSensorDataInt* multitemp_;
  ::SensorData* waterpressure_;
  ::iBeacon* ibeacon_;
  ::google::protobuf::RepeatedPtrField< ::SensorData > sensors_;
  ::ExtSmoke* extsmoke_;
  ::ElecFireData* firedata_;
  ::MantunData* mtundata_;
  ::AcrelData* acreldata_;
  ::Cayman* caymandata_;
  bool installed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(45 + 31) / 32];

  friend void  protobuf_AddDesc_MsgNode_5f1v1_5fm13_2eproto();
  friend void protobuf_AssignDesc_MsgNode_5f1v1_5fm13_2eproto();
  friend void protobuf_ShutdownFile_MsgNode_5f1v1_5fm13_2eproto();

  void InitAsDefaultInstance();
  static MsgNode* default_instance_;
};
// ===================================================================


// ===================================================================

// LpwanParam

// optional bytes devEui = 1;
inline bool LpwanParam::has_deveui() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LpwanParam::set_has_deveui() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LpwanParam::clear_has_deveui() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LpwanParam::clear_deveui() {
  if (deveui_ != &::google::protobuf::internal::kEmptyString) {
    deveui_->clear();
  }
  clear_has_deveui();
}
inline const ::std::string& LpwanParam::deveui() const {
  return *deveui_;
}
inline void LpwanParam::set_deveui(const ::std::string& value) {
  set_has_deveui();
  if (deveui_ == &::google::protobuf::internal::kEmptyString) {
    deveui_ = new ::std::string;
  }
  deveui_->assign(value);
}
inline void LpwanParam::set_deveui(const char* value) {
  set_has_deveui();
  if (deveui_ == &::google::protobuf::internal::kEmptyString) {
    deveui_ = new ::std::string;
  }
  deveui_->assign(value);
}
inline void LpwanParam::set_deveui(const void* value, size_t size) {
  set_has_deveui();
  if (deveui_ == &::google::protobuf::internal::kEmptyString) {
    deveui_ = new ::std::string;
  }
  deveui_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LpwanParam::mutable_deveui() {
  set_has_deveui();
  if (deveui_ == &::google::protobuf::internal::kEmptyString) {
    deveui_ = new ::std::string;
  }
  return deveui_;
}
inline ::std::string* LpwanParam::release_deveui() {
  clear_has_deveui();
  if (deveui_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deveui_;
    deveui_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LpwanParam::set_allocated_deveui(::std::string* deveui) {
  if (deveui_ != &::google::protobuf::internal::kEmptyString) {
    delete deveui_;
  }
  if (deveui) {
    set_has_deveui();
    deveui_ = deveui;
  } else {
    clear_has_deveui();
    deveui_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes appEui = 2;
inline bool LpwanParam::has_appeui() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LpwanParam::set_has_appeui() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LpwanParam::clear_has_appeui() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LpwanParam::clear_appeui() {
  if (appeui_ != &::google::protobuf::internal::kEmptyString) {
    appeui_->clear();
  }
  clear_has_appeui();
}
inline const ::std::string& LpwanParam::appeui() const {
  return *appeui_;
}
inline void LpwanParam::set_appeui(const ::std::string& value) {
  set_has_appeui();
  if (appeui_ == &::google::protobuf::internal::kEmptyString) {
    appeui_ = new ::std::string;
  }
  appeui_->assign(value);
}
inline void LpwanParam::set_appeui(const char* value) {
  set_has_appeui();
  if (appeui_ == &::google::protobuf::internal::kEmptyString) {
    appeui_ = new ::std::string;
  }
  appeui_->assign(value);
}
inline void LpwanParam::set_appeui(const void* value, size_t size) {
  set_has_appeui();
  if (appeui_ == &::google::protobuf::internal::kEmptyString) {
    appeui_ = new ::std::string;
  }
  appeui_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LpwanParam::mutable_appeui() {
  set_has_appeui();
  if (appeui_ == &::google::protobuf::internal::kEmptyString) {
    appeui_ = new ::std::string;
  }
  return appeui_;
}
inline ::std::string* LpwanParam::release_appeui() {
  clear_has_appeui();
  if (appeui_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = appeui_;
    appeui_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LpwanParam::set_allocated_appeui(::std::string* appeui) {
  if (appeui_ != &::google::protobuf::internal::kEmptyString) {
    delete appeui_;
  }
  if (appeui) {
    set_has_appeui();
    appeui_ = appeui;
  } else {
    clear_has_appeui();
    appeui_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes appKey = 3;
inline bool LpwanParam::has_appkey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LpwanParam::set_has_appkey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LpwanParam::clear_has_appkey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LpwanParam::clear_appkey() {
  if (appkey_ != &::google::protobuf::internal::kEmptyString) {
    appkey_->clear();
  }
  clear_has_appkey();
}
inline const ::std::string& LpwanParam::appkey() const {
  return *appkey_;
}
inline void LpwanParam::set_appkey(const ::std::string& value) {
  set_has_appkey();
  if (appkey_ == &::google::protobuf::internal::kEmptyString) {
    appkey_ = new ::std::string;
  }
  appkey_->assign(value);
}
inline void LpwanParam::set_appkey(const char* value) {
  set_has_appkey();
  if (appkey_ == &::google::protobuf::internal::kEmptyString) {
    appkey_ = new ::std::string;
  }
  appkey_->assign(value);
}
inline void LpwanParam::set_appkey(const void* value, size_t size) {
  set_has_appkey();
  if (appkey_ == &::google::protobuf::internal::kEmptyString) {
    appkey_ = new ::std::string;
  }
  appkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LpwanParam::mutable_appkey() {
  set_has_appkey();
  if (appkey_ == &::google::protobuf::internal::kEmptyString) {
    appkey_ = new ::std::string;
  }
  return appkey_;
}
inline ::std::string* LpwanParam::release_appkey() {
  clear_has_appkey();
  if (appkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = appkey_;
    appkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LpwanParam::set_allocated_appkey(::std::string* appkey) {
  if (appkey_ != &::google::protobuf::internal::kEmptyString) {
    delete appkey_;
  }
  if (appkey) {
    set_has_appkey();
    appkey_ = appkey;
  } else {
    clear_has_appkey();
    appkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes appSkey = 4;
inline bool LpwanParam::has_appskey() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LpwanParam::set_has_appskey() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LpwanParam::clear_has_appskey() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LpwanParam::clear_appskey() {
  if (appskey_ != &::google::protobuf::internal::kEmptyString) {
    appskey_->clear();
  }
  clear_has_appskey();
}
inline const ::std::string& LpwanParam::appskey() const {
  return *appskey_;
}
inline void LpwanParam::set_appskey(const ::std::string& value) {
  set_has_appskey();
  if (appskey_ == &::google::protobuf::internal::kEmptyString) {
    appskey_ = new ::std::string;
  }
  appskey_->assign(value);
}
inline void LpwanParam::set_appskey(const char* value) {
  set_has_appskey();
  if (appskey_ == &::google::protobuf::internal::kEmptyString) {
    appskey_ = new ::std::string;
  }
  appskey_->assign(value);
}
inline void LpwanParam::set_appskey(const void* value, size_t size) {
  set_has_appskey();
  if (appskey_ == &::google::protobuf::internal::kEmptyString) {
    appskey_ = new ::std::string;
  }
  appskey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LpwanParam::mutable_appskey() {
  set_has_appskey();
  if (appskey_ == &::google::protobuf::internal::kEmptyString) {
    appskey_ = new ::std::string;
  }
  return appskey_;
}
inline ::std::string* LpwanParam::release_appskey() {
  clear_has_appskey();
  if (appskey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = appskey_;
    appskey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LpwanParam::set_allocated_appskey(::std::string* appskey) {
  if (appskey_ != &::google::protobuf::internal::kEmptyString) {
    delete appskey_;
  }
  if (appskey) {
    set_has_appskey();
    appskey_ = appskey;
  } else {
    clear_has_appskey();
    appskey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes nwkSkey = 5;
inline bool LpwanParam::has_nwkskey() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LpwanParam::set_has_nwkskey() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LpwanParam::clear_has_nwkskey() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LpwanParam::clear_nwkskey() {
  if (nwkskey_ != &::google::protobuf::internal::kEmptyString) {
    nwkskey_->clear();
  }
  clear_has_nwkskey();
}
inline const ::std::string& LpwanParam::nwkskey() const {
  return *nwkskey_;
}
inline void LpwanParam::set_nwkskey(const ::std::string& value) {
  set_has_nwkskey();
  if (nwkskey_ == &::google::protobuf::internal::kEmptyString) {
    nwkskey_ = new ::std::string;
  }
  nwkskey_->assign(value);
}
inline void LpwanParam::set_nwkskey(const char* value) {
  set_has_nwkskey();
  if (nwkskey_ == &::google::protobuf::internal::kEmptyString) {
    nwkskey_ = new ::std::string;
  }
  nwkskey_->assign(value);
}
inline void LpwanParam::set_nwkskey(const void* value, size_t size) {
  set_has_nwkskey();
  if (nwkskey_ == &::google::protobuf::internal::kEmptyString) {
    nwkskey_ = new ::std::string;
  }
  nwkskey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LpwanParam::mutable_nwkskey() {
  set_has_nwkskey();
  if (nwkskey_ == &::google::protobuf::internal::kEmptyString) {
    nwkskey_ = new ::std::string;
  }
  return nwkskey_;
}
inline ::std::string* LpwanParam::release_nwkskey() {
  clear_has_nwkskey();
  if (nwkskey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nwkskey_;
    nwkskey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LpwanParam::set_allocated_nwkskey(::std::string* nwkskey) {
  if (nwkskey_ != &::google::protobuf::internal::kEmptyString) {
    delete nwkskey_;
  }
  if (nwkskey) {
    set_has_nwkskey();
    nwkskey_ = nwkskey;
  } else {
    clear_has_nwkskey();
    nwkskey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 devAddr = 6;
inline bool LpwanParam::has_devaddr() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LpwanParam::set_has_devaddr() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LpwanParam::clear_has_devaddr() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LpwanParam::clear_devaddr() {
  devaddr_ = 0u;
  clear_has_devaddr();
}
inline ::google::protobuf::uint32 LpwanParam::devaddr() const {
  return devaddr_;
}
inline void LpwanParam::set_devaddr(::google::protobuf::uint32 value) {
  set_has_devaddr();
  devaddr_ = value;
}

// optional uint32 datarate = 7;
inline bool LpwanParam::has_datarate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LpwanParam::set_has_datarate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LpwanParam::clear_has_datarate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LpwanParam::clear_datarate() {
  datarate_ = 0u;
  clear_has_datarate();
}
inline ::google::protobuf::uint32 LpwanParam::datarate() const {
  return datarate_;
}
inline void LpwanParam::set_datarate(::google::protobuf::uint32 value) {
  set_has_datarate();
  datarate_ = value;
}

// optional sint32 txPower = 8;
inline bool LpwanParam::has_txpower() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LpwanParam::set_has_txpower() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LpwanParam::clear_has_txpower() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LpwanParam::clear_txpower() {
  txpower_ = 0;
  clear_has_txpower();
}
inline ::google::protobuf::int32 LpwanParam::txpower() const {
  return txpower_;
}
inline void LpwanParam::set_txpower(::google::protobuf::int32 value) {
  set_has_txpower();
  txpower_ = value;
}

// optional uint32 adr = 9;
inline bool LpwanParam::has_adr() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LpwanParam::set_has_adr() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LpwanParam::clear_has_adr() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LpwanParam::clear_adr() {
  adr_ = 0u;
  clear_has_adr();
}
inline ::google::protobuf::uint32 LpwanParam::adr() const {
  return adr_;
}
inline void LpwanParam::set_adr(::google::protobuf::uint32 value) {
  set_has_adr();
  adr_ = value;
}

// optional .Activtion activition = 10;
inline bool LpwanParam::has_activition() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LpwanParam::set_has_activition() {
  _has_bits_[0] |= 0x00000200u;
}
inline void LpwanParam::clear_has_activition() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void LpwanParam::clear_activition() {
  activition_ = 0;
  clear_has_activition();
}
inline ::Activtion LpwanParam::activition() const {
  return static_cast< ::Activtion >(activition_);
}
inline void LpwanParam::set_activition(::Activtion value) {
  assert(::Activtion_IsValid(value));
  set_has_activition();
  activition_ = value;
}

// optional .ClassType classType = 11;
inline bool LpwanParam::has_classtype() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void LpwanParam::set_has_classtype() {
  _has_bits_[0] |= 0x00000400u;
}
inline void LpwanParam::clear_has_classtype() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void LpwanParam::clear_classtype() {
  classtype_ = 0;
  clear_has_classtype();
}
inline ::ClassType LpwanParam::classtype() const {
  return static_cast< ::ClassType >(classtype_);
}
inline void LpwanParam::set_classtype(::ClassType value) {
  assert(::ClassType_IsValid(value));
  set_has_classtype();
  classtype_ = value;
}

// optional uint32 delay = 12;
inline bool LpwanParam::has_delay() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void LpwanParam::set_has_delay() {
  _has_bits_[0] |= 0x00000800u;
}
inline void LpwanParam::clear_has_delay() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void LpwanParam::clear_delay() {
  delay_ = 0u;
  clear_has_delay();
}
inline ::google::protobuf::uint32 LpwanParam::delay() const {
  return delay_;
}
inline void LpwanParam::set_delay(::google::protobuf::uint32 value) {
  set_has_delay();
  delay_ = value;
}

// repeated uint32 channelMask = 13;
inline int LpwanParam::channelmask_size() const {
  return channelmask_.size();
}
inline void LpwanParam::clear_channelmask() {
  channelmask_.Clear();
}
inline ::google::protobuf::uint32 LpwanParam::channelmask(int index) const {
  return channelmask_.Get(index);
}
inline void LpwanParam::set_channelmask(int index, ::google::protobuf::uint32 value) {
  channelmask_.Set(index, value);
}
inline void LpwanParam::add_channelmask(::google::protobuf::uint32 value) {
  channelmask_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
LpwanParam::channelmask() const {
  return channelmask_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
LpwanParam::mutable_channelmask() {
  return &channelmask_;
}

// optional uint32 maxEIRP = 14;
inline bool LpwanParam::has_maxeirp() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void LpwanParam::set_has_maxeirp() {
  _has_bits_[0] |= 0x00002000u;
}
inline void LpwanParam::clear_has_maxeirp() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void LpwanParam::clear_maxeirp() {
  maxeirp_ = 0u;
  clear_has_maxeirp();
}
inline ::google::protobuf::uint32 LpwanParam::maxeirp() const {
  return maxeirp_;
}
inline void LpwanParam::set_maxeirp(::google::protobuf::uint32 value) {
  set_has_maxeirp();
  maxeirp_ = value;
}

// optional uint32 sglStatus = 15;
inline bool LpwanParam::has_sglstatus() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void LpwanParam::set_has_sglstatus() {
  _has_bits_[0] |= 0x00004000u;
}
inline void LpwanParam::clear_has_sglstatus() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void LpwanParam::clear_sglstatus() {
  sglstatus_ = 0u;
  clear_has_sglstatus();
}
inline ::google::protobuf::uint32 LpwanParam::sglstatus() const {
  return sglstatus_;
}
inline void LpwanParam::set_sglstatus(::google::protobuf::uint32 value) {
  set_has_sglstatus();
  sglstatus_ = value;
}

// optional uint32 sglFrequency = 16;
inline bool LpwanParam::has_sglfrequency() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void LpwanParam::set_has_sglfrequency() {
  _has_bits_[0] |= 0x00008000u;
}
inline void LpwanParam::clear_has_sglfrequency() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void LpwanParam::clear_sglfrequency() {
  sglfrequency_ = 0u;
  clear_has_sglfrequency();
}
inline ::google::protobuf::uint32 LpwanParam::sglfrequency() const {
  return sglfrequency_;
}
inline void LpwanParam::set_sglfrequency(::google::protobuf::uint32 value) {
  set_has_sglfrequency();
  sglfrequency_ = value;
}

// optional uint32 sglDatarate = 17;
inline bool LpwanParam::has_sgldatarate() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void LpwanParam::set_has_sgldatarate() {
  _has_bits_[0] |= 0x00010000u;
}
inline void LpwanParam::clear_has_sgldatarate() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void LpwanParam::clear_sgldatarate() {
  sgldatarate_ = 0u;
  clear_has_sgldatarate();
}
inline ::google::protobuf::uint32 LpwanParam::sgldatarate() const {
  return sgldatarate_;
}
inline void LpwanParam::set_sgldatarate(::google::protobuf::uint32 value) {
  set_has_sgldatarate();
  sgldatarate_ = value;
}

// optional uint32 lbtStatus = 18;
inline bool LpwanParam::has_lbtstatus() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void LpwanParam::set_has_lbtstatus() {
  _has_bits_[0] |= 0x00020000u;
}
inline void LpwanParam::clear_has_lbtstatus() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void LpwanParam::clear_lbtstatus() {
  lbtstatus_ = 0u;
  clear_has_lbtstatus();
}
inline ::google::protobuf::uint32 LpwanParam::lbtstatus() const {
  return lbtstatus_;
}
inline void LpwanParam::set_lbtstatus(::google::protobuf::uint32 value) {
  set_has_lbtstatus();
  lbtstatus_ = value;
}

// optional sint32 lbtThreshold = 19;
inline bool LpwanParam::has_lbtthreshold() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void LpwanParam::set_has_lbtthreshold() {
  _has_bits_[0] |= 0x00040000u;
}
inline void LpwanParam::clear_has_lbtthreshold() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void LpwanParam::clear_lbtthreshold() {
  lbtthreshold_ = 0;
  clear_has_lbtthreshold();
}
inline ::google::protobuf::int32 LpwanParam::lbtthreshold() const {
  return lbtthreshold_;
}
inline void LpwanParam::set_lbtthreshold(::google::protobuf::int32 value) {
  set_has_lbtthreshold();
  lbtthreshold_ = value;
}

// -------------------------------------------------------------------

// BleParam

// optional float bleInterval = 1;
inline bool BleParam::has_bleinterval() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BleParam::set_has_bleinterval() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BleParam::clear_has_bleinterval() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BleParam::clear_bleinterval() {
  bleinterval_ = 0;
  clear_has_bleinterval();
}
inline float BleParam::bleinterval() const {
  return bleinterval_;
}
inline void BleParam::set_bleinterval(float value) {
  set_has_bleinterval();
  bleinterval_ = value;
}

// optional sint32 bleTxp = 2;
inline bool BleParam::has_bletxp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BleParam::set_has_bletxp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BleParam::clear_has_bletxp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BleParam::clear_bletxp() {
  bletxp_ = 0;
  clear_has_bletxp();
}
inline ::google::protobuf::int32 BleParam::bletxp() const {
  return bletxp_;
}
inline void BleParam::set_bletxp(::google::protobuf::int32 value) {
  set_has_bletxp();
  bletxp_ = value;
}

// optional uint32 bleOnTime = 3;
inline bool BleParam::has_bleontime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BleParam::set_has_bleontime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BleParam::clear_has_bleontime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BleParam::clear_bleontime() {
  bleontime_ = 0u;
  clear_has_bleontime();
}
inline ::google::protobuf::uint32 BleParam::bleontime() const {
  return bleontime_;
}
inline void BleParam::set_bleontime(::google::protobuf::uint32 value) {
  set_has_bleontime();
  bleontime_ = value;
}

// optional uint32 bleOffTime = 4;
inline bool BleParam::has_bleofftime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BleParam::set_has_bleofftime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BleParam::clear_has_bleofftime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BleParam::clear_bleofftime() {
  bleofftime_ = 0u;
  clear_has_bleofftime();
}
inline ::google::protobuf::uint32 BleParam::bleofftime() const {
  return bleofftime_;
}
inline void BleParam::set_bleofftime(::google::protobuf::uint32 value) {
  set_has_bleofftime();
  bleofftime_ = value;
}

// optional uint32 bleOnOff = 5;
inline bool BleParam::has_bleonoff() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BleParam::set_has_bleonoff() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BleParam::clear_has_bleonoff() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BleParam::clear_bleonoff() {
  bleonoff_ = 0u;
  clear_has_bleonoff();
}
inline ::google::protobuf::uint32 BleParam::bleonoff() const {
  return bleonoff_;
}
inline void BleParam::set_bleonoff(::google::protobuf::uint32 value) {
  set_has_bleonoff();
  bleonoff_ = value;
}

// -------------------------------------------------------------------

// SensorData

// optional .SensorType type = 9;
inline bool SensorData::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SensorData::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SensorData::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SensorData::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::SensorType SensorData::type() const {
  return static_cast< ::SensorType >(type_);
}
inline void SensorData::set_type(::SensorType value) {
  assert(::SensorType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional float data = 1;
inline bool SensorData::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SensorData::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SensorData::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SensorData::clear_data() {
  data_ = 0;
  clear_has_data();
}
inline float SensorData::data() const {
  return data_;
}
inline void SensorData::set_data(float value) {
  set_has_data();
  data_ = value;
}

// optional float alarmHigh = 2;
inline bool SensorData::has_alarmhigh() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SensorData::set_has_alarmhigh() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SensorData::clear_has_alarmhigh() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SensorData::clear_alarmhigh() {
  alarmhigh_ = 0;
  clear_has_alarmhigh();
}
inline float SensorData::alarmhigh() const {
  return alarmhigh_;
}
inline void SensorData::set_alarmhigh(float value) {
  set_has_alarmhigh();
  alarmhigh_ = value;
}

// optional float alarmLow = 3;
inline bool SensorData::has_alarmlow() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SensorData::set_has_alarmlow() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SensorData::clear_has_alarmlow() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SensorData::clear_alarmlow() {
  alarmlow_ = 0;
  clear_has_alarmlow();
}
inline float SensorData::alarmlow() const {
  return alarmlow_;
}
inline void SensorData::set_alarmlow(float value) {
  set_has_alarmlow();
  alarmlow_ = value;
}

// optional uint32 calibration = 4;
inline bool SensorData::has_calibration() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SensorData::set_has_calibration() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SensorData::clear_has_calibration() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SensorData::clear_calibration() {
  calibration_ = 0u;
  clear_has_calibration();
}
inline ::google::protobuf::uint32 SensorData::calibration() const {
  return calibration_;
}
inline void SensorData::set_calibration(::google::protobuf::uint32 value) {
  set_has_calibration();
  calibration_ = value;
}

// optional .SensorError error = 5;
inline bool SensorData::has_error() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SensorData::set_has_error() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SensorData::clear_has_error() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SensorData::clear_error() {
  error_ = 0;
  clear_has_error();
}
inline ::SensorError SensorData::error() const {
  return static_cast< ::SensorError >(error_);
}
inline void SensorData::set_error(::SensorError value) {
  assert(::SensorError_IsValid(value));
  set_has_error();
  error_ = value;
}

// optional uint32 status = 6;
inline bool SensorData::has_status() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SensorData::set_has_status() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SensorData::clear_has_status() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SensorData::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 SensorData::status() const {
  return status_;
}
inline void SensorData::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// optional float alarmStepHigh = 7;
inline bool SensorData::has_alarmstephigh() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SensorData::set_has_alarmstephigh() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SensorData::clear_has_alarmstephigh() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SensorData::clear_alarmstephigh() {
  alarmstephigh_ = 0;
  clear_has_alarmstephigh();
}
inline float SensorData::alarmstephigh() const {
  return alarmstephigh_;
}
inline void SensorData::set_alarmstephigh(float value) {
  set_has_alarmstephigh();
  alarmstephigh_ = value;
}

// optional float alarmStepLow = 8;
inline bool SensorData::has_alarmsteplow() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SensorData::set_has_alarmsteplow() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SensorData::clear_has_alarmsteplow() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SensorData::clear_alarmsteplow() {
  alarmsteplow_ = 0;
  clear_has_alarmsteplow();
}
inline float SensorData::alarmsteplow() const {
  return alarmsteplow_;
}
inline void SensorData::set_alarmsteplow(float value) {
  set_has_alarmsteplow();
  alarmsteplow_ = value;
}

// -------------------------------------------------------------------

// SensorDataInt

// optional .SensorType type = 1;
inline bool SensorDataInt::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SensorDataInt::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SensorDataInt::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SensorDataInt::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::SensorType SensorDataInt::type() const {
  return static_cast< ::SensorType >(type_);
}
inline void SensorDataInt::set_type(::SensorType value) {
  assert(::SensorType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional sint32 data = 2;
inline bool SensorDataInt::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SensorDataInt::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SensorDataInt::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SensorDataInt::clear_data() {
  data_ = 0;
  clear_has_data();
}
inline ::google::protobuf::int32 SensorDataInt::data() const {
  return data_;
}
inline void SensorDataInt::set_data(::google::protobuf::int32 value) {
  set_has_data();
  data_ = value;
}

// optional sint32 alarmHigh = 3;
inline bool SensorDataInt::has_alarmhigh() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SensorDataInt::set_has_alarmhigh() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SensorDataInt::clear_has_alarmhigh() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SensorDataInt::clear_alarmhigh() {
  alarmhigh_ = 0;
  clear_has_alarmhigh();
}
inline ::google::protobuf::int32 SensorDataInt::alarmhigh() const {
  return alarmhigh_;
}
inline void SensorDataInt::set_alarmhigh(::google::protobuf::int32 value) {
  set_has_alarmhigh();
  alarmhigh_ = value;
}

// optional sint32 alarmLow = 4;
inline bool SensorDataInt::has_alarmlow() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SensorDataInt::set_has_alarmlow() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SensorDataInt::clear_has_alarmlow() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SensorDataInt::clear_alarmlow() {
  alarmlow_ = 0;
  clear_has_alarmlow();
}
inline ::google::protobuf::int32 SensorDataInt::alarmlow() const {
  return alarmlow_;
}
inline void SensorDataInt::set_alarmlow(::google::protobuf::int32 value) {
  set_has_alarmlow();
  alarmlow_ = value;
}

// optional sint32 calibration = 5;
inline bool SensorDataInt::has_calibration() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SensorDataInt::set_has_calibration() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SensorDataInt::clear_has_calibration() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SensorDataInt::clear_calibration() {
  calibration_ = 0;
  clear_has_calibration();
}
inline ::google::protobuf::int32 SensorDataInt::calibration() const {
  return calibration_;
}
inline void SensorDataInt::set_calibration(::google::protobuf::int32 value) {
  set_has_calibration();
  calibration_ = value;
}

// optional .SensorError error = 6;
inline bool SensorDataInt::has_error() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SensorDataInt::set_has_error() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SensorDataInt::clear_has_error() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SensorDataInt::clear_error() {
  error_ = 0;
  clear_has_error();
}
inline ::SensorError SensorDataInt::error() const {
  return static_cast< ::SensorError >(error_);
}
inline void SensorDataInt::set_error(::SensorError value) {
  assert(::SensorError_IsValid(value));
  set_has_error();
  error_ = value;
}

// optional uint32 status = 7;
inline bool SensorDataInt::has_status() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SensorDataInt::set_has_status() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SensorDataInt::clear_has_status() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SensorDataInt::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 SensorDataInt::status() const {
  return status_;
}
inline void SensorDataInt::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// optional sint32 alarmStepHigh = 8;
inline bool SensorDataInt::has_alarmstephigh() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SensorDataInt::set_has_alarmstephigh() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SensorDataInt::clear_has_alarmstephigh() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SensorDataInt::clear_alarmstephigh() {
  alarmstephigh_ = 0;
  clear_has_alarmstephigh();
}
inline ::google::protobuf::int32 SensorDataInt::alarmstephigh() const {
  return alarmstephigh_;
}
inline void SensorDataInt::set_alarmstephigh(::google::protobuf::int32 value) {
  set_has_alarmstephigh();
  alarmstephigh_ = value;
}

// optional sint32 alarmStepLow = 9;
inline bool SensorDataInt::has_alarmsteplow() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SensorDataInt::set_has_alarmsteplow() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SensorDataInt::clear_has_alarmsteplow() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SensorDataInt::clear_alarmsteplow() {
  alarmsteplow_ = 0;
  clear_has_alarmsteplow();
}
inline ::google::protobuf::int32 SensorDataInt::alarmsteplow() const {
  return alarmsteplow_;
}
inline void SensorDataInt::set_alarmsteplow(::google::protobuf::int32 value) {
  set_has_alarmsteplow();
  alarmsteplow_ = value;
}

// -------------------------------------------------------------------

// SensorDataFloat

// optional .SensorType type = 1;
inline bool SensorDataFloat::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SensorDataFloat::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SensorDataFloat::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SensorDataFloat::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::SensorType SensorDataFloat::type() const {
  return static_cast< ::SensorType >(type_);
}
inline void SensorDataFloat::set_type(::SensorType value) {
  assert(::SensorType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional float data = 2;
inline bool SensorDataFloat::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SensorDataFloat::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SensorDataFloat::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SensorDataFloat::clear_data() {
  data_ = 0;
  clear_has_data();
}
inline float SensorDataFloat::data() const {
  return data_;
}
inline void SensorDataFloat::set_data(float value) {
  set_has_data();
  data_ = value;
}

// optional float alarmHigh = 3;
inline bool SensorDataFloat::has_alarmhigh() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SensorDataFloat::set_has_alarmhigh() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SensorDataFloat::clear_has_alarmhigh() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SensorDataFloat::clear_alarmhigh() {
  alarmhigh_ = 0;
  clear_has_alarmhigh();
}
inline float SensorDataFloat::alarmhigh() const {
  return alarmhigh_;
}
inline void SensorDataFloat::set_alarmhigh(float value) {
  set_has_alarmhigh();
  alarmhigh_ = value;
}

// optional float alarmLow = 4;
inline bool SensorDataFloat::has_alarmlow() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SensorDataFloat::set_has_alarmlow() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SensorDataFloat::clear_has_alarmlow() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SensorDataFloat::clear_alarmlow() {
  alarmlow_ = 0;
  clear_has_alarmlow();
}
inline float SensorDataFloat::alarmlow() const {
  return alarmlow_;
}
inline void SensorDataFloat::set_alarmlow(float value) {
  set_has_alarmlow();
  alarmlow_ = value;
}

// optional sint32 calibration = 5;
inline bool SensorDataFloat::has_calibration() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SensorDataFloat::set_has_calibration() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SensorDataFloat::clear_has_calibration() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SensorDataFloat::clear_calibration() {
  calibration_ = 0;
  clear_has_calibration();
}
inline ::google::protobuf::int32 SensorDataFloat::calibration() const {
  return calibration_;
}
inline void SensorDataFloat::set_calibration(::google::protobuf::int32 value) {
  set_has_calibration();
  calibration_ = value;
}

// optional .SensorError error = 6;
inline bool SensorDataFloat::has_error() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SensorDataFloat::set_has_error() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SensorDataFloat::clear_has_error() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SensorDataFloat::clear_error() {
  error_ = 0;
  clear_has_error();
}
inline ::SensorError SensorDataFloat::error() const {
  return static_cast< ::SensorError >(error_);
}
inline void SensorDataFloat::set_error(::SensorError value) {
  assert(::SensorError_IsValid(value));
  set_has_error();
  error_ = value;
}

// optional uint32 status = 7;
inline bool SensorDataFloat::has_status() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SensorDataFloat::set_has_status() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SensorDataFloat::clear_has_status() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SensorDataFloat::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 SensorDataFloat::status() const {
  return status_;
}
inline void SensorDataFloat::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// optional float alarmStepHigh = 8;
inline bool SensorDataFloat::has_alarmstephigh() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SensorDataFloat::set_has_alarmstephigh() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SensorDataFloat::clear_has_alarmstephigh() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SensorDataFloat::clear_alarmstephigh() {
  alarmstephigh_ = 0;
  clear_has_alarmstephigh();
}
inline float SensorDataFloat::alarmstephigh() const {
  return alarmstephigh_;
}
inline void SensorDataFloat::set_alarmstephigh(float value) {
  set_has_alarmstephigh();
  alarmstephigh_ = value;
}

// optional float alarmStepLow = 9;
inline bool SensorDataFloat::has_alarmsteplow() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SensorDataFloat::set_has_alarmsteplow() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SensorDataFloat::clear_has_alarmsteplow() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SensorDataFloat::clear_alarmsteplow() {
  alarmsteplow_ = 0;
  clear_has_alarmsteplow();
}
inline float SensorDataFloat::alarmsteplow() const {
  return alarmsteplow_;
}
inline void SensorDataFloat::set_alarmsteplow(float value) {
  set_has_alarmsteplow();
  alarmsteplow_ = value;
}

// -------------------------------------------------------------------

// MultiSensorData

// repeated float data = 1;
inline int MultiSensorData::data_size() const {
  return data_.size();
}
inline void MultiSensorData::clear_data() {
  data_.Clear();
}
inline float MultiSensorData::data(int index) const {
  return data_.Get(index);
}
inline void MultiSensorData::set_data(int index, float value) {
  data_.Set(index, value);
}
inline void MultiSensorData::add_data(float value) {
  data_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
MultiSensorData::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedField< float >*
MultiSensorData::mutable_data() {
  return &data_;
}

// optional float alarmHigh = 2;
inline bool MultiSensorData::has_alarmhigh() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MultiSensorData::set_has_alarmhigh() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MultiSensorData::clear_has_alarmhigh() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MultiSensorData::clear_alarmhigh() {
  alarmhigh_ = 0;
  clear_has_alarmhigh();
}
inline float MultiSensorData::alarmhigh() const {
  return alarmhigh_;
}
inline void MultiSensorData::set_alarmhigh(float value) {
  set_has_alarmhigh();
  alarmhigh_ = value;
}

// optional float alarmLow = 3;
inline bool MultiSensorData::has_alarmlow() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MultiSensorData::set_has_alarmlow() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MultiSensorData::clear_has_alarmlow() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MultiSensorData::clear_alarmlow() {
  alarmlow_ = 0;
  clear_has_alarmlow();
}
inline float MultiSensorData::alarmlow() const {
  return alarmlow_;
}
inline void MultiSensorData::set_alarmlow(float value) {
  set_has_alarmlow();
  alarmlow_ = value;
}

// optional uint32 calibration = 4;
inline bool MultiSensorData::has_calibration() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MultiSensorData::set_has_calibration() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MultiSensorData::clear_has_calibration() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MultiSensorData::clear_calibration() {
  calibration_ = 0u;
  clear_has_calibration();
}
inline ::google::protobuf::uint32 MultiSensorData::calibration() const {
  return calibration_;
}
inline void MultiSensorData::set_calibration(::google::protobuf::uint32 value) {
  set_has_calibration();
  calibration_ = value;
}

// optional .SensorError error = 5;
inline bool MultiSensorData::has_error() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MultiSensorData::set_has_error() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MultiSensorData::clear_has_error() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MultiSensorData::clear_error() {
  error_ = 0;
  clear_has_error();
}
inline ::SensorError MultiSensorData::error() const {
  return static_cast< ::SensorError >(error_);
}
inline void MultiSensorData::set_error(::SensorError value) {
  assert(::SensorError_IsValid(value));
  set_has_error();
  error_ = value;
}

// optional uint32 status = 6;
inline bool MultiSensorData::has_status() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MultiSensorData::set_has_status() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MultiSensorData::clear_has_status() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MultiSensorData::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 MultiSensorData::status() const {
  return status_;
}
inline void MultiSensorData::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// optional float alarmStepHigh = 7;
inline bool MultiSensorData::has_alarmstephigh() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MultiSensorData::set_has_alarmstephigh() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MultiSensorData::clear_has_alarmstephigh() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MultiSensorData::clear_alarmstephigh() {
  alarmstephigh_ = 0;
  clear_has_alarmstephigh();
}
inline float MultiSensorData::alarmstephigh() const {
  return alarmstephigh_;
}
inline void MultiSensorData::set_alarmstephigh(float value) {
  set_has_alarmstephigh();
  alarmstephigh_ = value;
}

// optional float alarmStepLow = 8;
inline bool MultiSensorData::has_alarmsteplow() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MultiSensorData::set_has_alarmsteplow() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MultiSensorData::clear_has_alarmsteplow() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MultiSensorData::clear_alarmsteplow() {
  alarmsteplow_ = 0;
  clear_has_alarmsteplow();
}
inline float MultiSensorData::alarmsteplow() const {
  return alarmsteplow_;
}
inline void MultiSensorData::set_alarmsteplow(float value) {
  set_has_alarmsteplow();
  alarmsteplow_ = value;
}

// -------------------------------------------------------------------

// MultiSensorDataInt

// repeated sint32 data = 1;
inline int MultiSensorDataInt::data_size() const {
  return data_.size();
}
inline void MultiSensorDataInt::clear_data() {
  data_.Clear();
}
inline ::google::protobuf::int32 MultiSensorDataInt::data(int index) const {
  return data_.Get(index);
}
inline void MultiSensorDataInt::set_data(int index, ::google::protobuf::int32 value) {
  data_.Set(index, value);
}
inline void MultiSensorDataInt::add_data(::google::protobuf::int32 value) {
  data_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
MultiSensorDataInt::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
MultiSensorDataInt::mutable_data() {
  return &data_;
}

// optional sint32 alarmHigh = 2;
inline bool MultiSensorDataInt::has_alarmhigh() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MultiSensorDataInt::set_has_alarmhigh() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MultiSensorDataInt::clear_has_alarmhigh() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MultiSensorDataInt::clear_alarmhigh() {
  alarmhigh_ = 0;
  clear_has_alarmhigh();
}
inline ::google::protobuf::int32 MultiSensorDataInt::alarmhigh() const {
  return alarmhigh_;
}
inline void MultiSensorDataInt::set_alarmhigh(::google::protobuf::int32 value) {
  set_has_alarmhigh();
  alarmhigh_ = value;
}

// optional sint32 alarmLow = 3;
inline bool MultiSensorDataInt::has_alarmlow() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MultiSensorDataInt::set_has_alarmlow() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MultiSensorDataInt::clear_has_alarmlow() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MultiSensorDataInt::clear_alarmlow() {
  alarmlow_ = 0;
  clear_has_alarmlow();
}
inline ::google::protobuf::int32 MultiSensorDataInt::alarmlow() const {
  return alarmlow_;
}
inline void MultiSensorDataInt::set_alarmlow(::google::protobuf::int32 value) {
  set_has_alarmlow();
  alarmlow_ = value;
}

// optional uint32 calibration = 4;
inline bool MultiSensorDataInt::has_calibration() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MultiSensorDataInt::set_has_calibration() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MultiSensorDataInt::clear_has_calibration() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MultiSensorDataInt::clear_calibration() {
  calibration_ = 0u;
  clear_has_calibration();
}
inline ::google::protobuf::uint32 MultiSensorDataInt::calibration() const {
  return calibration_;
}
inline void MultiSensorDataInt::set_calibration(::google::protobuf::uint32 value) {
  set_has_calibration();
  calibration_ = value;
}

// optional .SensorError error = 5;
inline bool MultiSensorDataInt::has_error() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MultiSensorDataInt::set_has_error() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MultiSensorDataInt::clear_has_error() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MultiSensorDataInt::clear_error() {
  error_ = 0;
  clear_has_error();
}
inline ::SensorError MultiSensorDataInt::error() const {
  return static_cast< ::SensorError >(error_);
}
inline void MultiSensorDataInt::set_error(::SensorError value) {
  assert(::SensorError_IsValid(value));
  set_has_error();
  error_ = value;
}

// optional uint32 status = 6;
inline bool MultiSensorDataInt::has_status() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MultiSensorDataInt::set_has_status() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MultiSensorDataInt::clear_has_status() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MultiSensorDataInt::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 MultiSensorDataInt::status() const {
  return status_;
}
inline void MultiSensorDataInt::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// optional sint32 alarmStepHigh = 7;
inline bool MultiSensorDataInt::has_alarmstephigh() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MultiSensorDataInt::set_has_alarmstephigh() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MultiSensorDataInt::clear_has_alarmstephigh() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MultiSensorDataInt::clear_alarmstephigh() {
  alarmstephigh_ = 0;
  clear_has_alarmstephigh();
}
inline ::google::protobuf::int32 MultiSensorDataInt::alarmstephigh() const {
  return alarmstephigh_;
}
inline void MultiSensorDataInt::set_alarmstephigh(::google::protobuf::int32 value) {
  set_has_alarmstephigh();
  alarmstephigh_ = value;
}

// optional sint32 alarmStepLow = 8;
inline bool MultiSensorDataInt::has_alarmsteplow() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MultiSensorDataInt::set_has_alarmsteplow() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MultiSensorDataInt::clear_has_alarmsteplow() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MultiSensorDataInt::clear_alarmsteplow() {
  alarmsteplow_ = 0;
  clear_has_alarmsteplow();
}
inline ::google::protobuf::int32 MultiSensorDataInt::alarmsteplow() const {
  return alarmsteplow_;
}
inline void MultiSensorDataInt::set_alarmsteplow(::google::protobuf::int32 value) {
  set_has_alarmsteplow();
  alarmsteplow_ = value;
}

// -------------------------------------------------------------------

// GpsData

// optional double latitude = 1;
inline bool GpsData::has_latitude() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GpsData::set_has_latitude() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GpsData::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GpsData::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline double GpsData::latitude() const {
  return latitude_;
}
inline void GpsData::set_latitude(double value) {
  set_has_latitude();
  latitude_ = value;
}

// optional double longitude = 2;
inline bool GpsData::has_longitude() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GpsData::set_has_longitude() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GpsData::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GpsData::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline double GpsData::longitude() const {
  return longitude_;
}
inline void GpsData::set_longitude(double value) {
  set_has_longitude();
  longitude_ = value;
}

// optional double altitude = 3;
inline bool GpsData::has_altitude() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GpsData::set_has_altitude() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GpsData::clear_has_altitude() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GpsData::clear_altitude() {
  altitude_ = 0;
  clear_has_altitude();
}
inline double GpsData::altitude() const {
  return altitude_;
}
inline void GpsData::set_altitude(double value) {
  set_has_altitude();
  altitude_ = value;
}

// -------------------------------------------------------------------

// AxisData

// optional float x = 1;
inline bool AxisData::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AxisData::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AxisData::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AxisData::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float AxisData::x() const {
  return x_;
}
inline void AxisData::set_x(float value) {
  set_has_x();
  x_ = value;
}

// optional float y = 2;
inline bool AxisData::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AxisData::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AxisData::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AxisData::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float AxisData::y() const {
  return y_;
}
inline void AxisData::set_y(float value) {
  set_has_y();
  y_ = value;
}

// optional float z = 3;
inline bool AxisData::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AxisData::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AxisData::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AxisData::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float AxisData::z() const {
  return z_;
}
inline void AxisData::set_z(float value) {
  set_has_z();
  z_ = value;
}

// -------------------------------------------------------------------

// iBeacon

// optional bytes addr = 1;
inline bool iBeacon::has_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void iBeacon::set_has_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void iBeacon::clear_has_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void iBeacon::clear_addr() {
  if (addr_ != &::google::protobuf::internal::kEmptyString) {
    addr_->clear();
  }
  clear_has_addr();
}
inline const ::std::string& iBeacon::addr() const {
  return *addr_;
}
inline void iBeacon::set_addr(const ::std::string& value) {
  set_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    addr_ = new ::std::string;
  }
  addr_->assign(value);
}
inline void iBeacon::set_addr(const char* value) {
  set_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    addr_ = new ::std::string;
  }
  addr_->assign(value);
}
inline void iBeacon::set_addr(const void* value, size_t size) {
  set_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    addr_ = new ::std::string;
  }
  addr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* iBeacon::mutable_addr() {
  set_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    addr_ = new ::std::string;
  }
  return addr_;
}
inline ::std::string* iBeacon::release_addr() {
  clear_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = addr_;
    addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void iBeacon::set_allocated_addr(::std::string* addr) {
  if (addr_ != &::google::protobuf::internal::kEmptyString) {
    delete addr_;
  }
  if (addr) {
    set_has_addr();
    addr_ = addr;
  } else {
    clear_has_addr();
    addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes umm = 2;
inline bool iBeacon::has_umm() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void iBeacon::set_has_umm() {
  _has_bits_[0] |= 0x00000002u;
}
inline void iBeacon::clear_has_umm() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void iBeacon::clear_umm() {
  if (umm_ != &::google::protobuf::internal::kEmptyString) {
    umm_->clear();
  }
  clear_has_umm();
}
inline const ::std::string& iBeacon::umm() const {
  return *umm_;
}
inline void iBeacon::set_umm(const ::std::string& value) {
  set_has_umm();
  if (umm_ == &::google::protobuf::internal::kEmptyString) {
    umm_ = new ::std::string;
  }
  umm_->assign(value);
}
inline void iBeacon::set_umm(const char* value) {
  set_has_umm();
  if (umm_ == &::google::protobuf::internal::kEmptyString) {
    umm_ = new ::std::string;
  }
  umm_->assign(value);
}
inline void iBeacon::set_umm(const void* value, size_t size) {
  set_has_umm();
  if (umm_ == &::google::protobuf::internal::kEmptyString) {
    umm_ = new ::std::string;
  }
  umm_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* iBeacon::mutable_umm() {
  set_has_umm();
  if (umm_ == &::google::protobuf::internal::kEmptyString) {
    umm_ = new ::std::string;
  }
  return umm_;
}
inline ::std::string* iBeacon::release_umm() {
  clear_has_umm();
  if (umm_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = umm_;
    umm_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void iBeacon::set_allocated_umm(::std::string* umm) {
  if (umm_ != &::google::protobuf::internal::kEmptyString) {
    delete umm_;
  }
  if (umm) {
    set_has_umm();
    umm_ = umm;
  } else {
    clear_has_umm();
    umm_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sint32 rssi = 3;
inline bool iBeacon::has_rssi() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void iBeacon::set_has_rssi() {
  _has_bits_[0] |= 0x00000004u;
}
inline void iBeacon::clear_has_rssi() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void iBeacon::clear_rssi() {
  rssi_ = 0;
  clear_has_rssi();
}
inline ::google::protobuf::int32 iBeacon::rssi() const {
  return rssi_;
}
inline void iBeacon::set_rssi(::google::protobuf::int32 value) {
  set_has_rssi();
  rssi_ = value;
}

// -------------------------------------------------------------------

// ExtSmoke

// optional uint32 bgSignal = 1;
inline bool ExtSmoke::has_bgsignal() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExtSmoke::set_has_bgsignal() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExtSmoke::clear_has_bgsignal() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExtSmoke::clear_bgsignal() {
  bgsignal_ = 0u;
  clear_has_bgsignal();
}
inline ::google::protobuf::uint32 ExtSmoke::bgsignal() const {
  return bgsignal_;
}
inline void ExtSmoke::set_bgsignal(::google::protobuf::uint32 value) {
  set_has_bgsignal();
  bgsignal_ = value;
}

// optional uint32 bgSignalThreshold = 2;
inline bool ExtSmoke::has_bgsignalthreshold() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExtSmoke::set_has_bgsignalthreshold() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExtSmoke::clear_has_bgsignalthreshold() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExtSmoke::clear_bgsignalthreshold() {
  bgsignalthreshold_ = 0u;
  clear_has_bgsignalthreshold();
}
inline ::google::protobuf::uint32 ExtSmoke::bgsignalthreshold() const {
  return bgsignalthreshold_;
}
inline void ExtSmoke::set_bgsignalthreshold(::google::protobuf::uint32 value) {
  set_has_bgsignalthreshold();
  bgsignalthreshold_ = value;
}

// optional uint32 bgSignalCalibration = 3;
inline bool ExtSmoke::has_bgsignalcalibration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExtSmoke::set_has_bgsignalcalibration() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExtSmoke::clear_has_bgsignalcalibration() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExtSmoke::clear_bgsignalcalibration() {
  bgsignalcalibration_ = 0u;
  clear_has_bgsignalcalibration();
}
inline ::google::protobuf::uint32 ExtSmoke::bgsignalcalibration() const {
  return bgsignalcalibration_;
}
inline void ExtSmoke::set_bgsignalcalibration(::google::protobuf::uint32 value) {
  set_has_bgsignalcalibration();
  bgsignalcalibration_ = value;
}

// -------------------------------------------------------------------

// AppParam

// optional .AppCmd cmd = 1;
inline bool AppParam::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AppParam::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AppParam::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AppParam::clear_cmd() {
  cmd_ = 0;
  clear_has_cmd();
}
inline ::AppCmd AppParam::cmd() const {
  return static_cast< ::AppCmd >(cmd_);
}
inline void AppParam::set_cmd(::AppCmd value) {
  assert(::AppCmd_IsValid(value));
  set_has_cmd();
  cmd_ = value;
}

// optional uint32 uploadInterval = 2;
inline bool AppParam::has_uploadinterval() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AppParam::set_has_uploadinterval() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AppParam::clear_has_uploadinterval() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AppParam::clear_uploadinterval() {
  uploadinterval_ = 0u;
  clear_has_uploadinterval();
}
inline ::google::protobuf::uint32 AppParam::uploadinterval() const {
  return uploadinterval_;
}
inline void AppParam::set_uploadinterval(::google::protobuf::uint32 value) {
  set_has_uploadinterval();
  uploadinterval_ = value;
}

// optional uint32 syncTime = 3;
inline bool AppParam::has_synctime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AppParam::set_has_synctime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AppParam::clear_has_synctime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AppParam::clear_synctime() {
  synctime_ = 0u;
  clear_has_synctime();
}
inline ::google::protobuf::uint32 AppParam::synctime() const {
  return synctime_;
}
inline void AppParam::set_synctime(::google::protobuf::uint32 value) {
  set_has_synctime();
  synctime_ = value;
}

// optional .NodeState nodeState = 4;
inline bool AppParam::has_nodestate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AppParam::set_has_nodestate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AppParam::clear_has_nodestate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AppParam::clear_nodestate() {
  nodestate_ = 0;
  clear_has_nodestate();
}
inline ::NodeState AppParam::nodestate() const {
  return static_cast< ::NodeState >(nodestate_);
}
inline void AppParam::set_nodestate(::NodeState value) {
  assert(::NodeState_IsValid(value));
  set_has_nodestate();
  nodestate_ = value;
}

// optional .NodeAlarm nodeAlarm = 5;
inline bool AppParam::has_nodealarm() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AppParam::set_has_nodealarm() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AppParam::clear_has_nodealarm() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AppParam::clear_nodealarm() {
  nodealarm_ = 0;
  clear_has_nodealarm();
}
inline ::NodeAlarm AppParam::nodealarm() const {
  return static_cast< ::NodeAlarm >(nodealarm_);
}
inline void AppParam::set_nodealarm(::NodeAlarm value) {
  assert(::NodeAlarm_IsValid(value));
  set_has_nodealarm();
  nodealarm_ = value;
}

// optional uint32 nodeAlarmSet = 6;
inline bool AppParam::has_nodealarmset() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AppParam::set_has_nodealarmset() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AppParam::clear_has_nodealarmset() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AppParam::clear_nodealarmset() {
  nodealarmset_ = 0u;
  clear_has_nodealarmset();
}
inline ::google::protobuf::uint32 AppParam::nodealarmset() const {
  return nodealarmset_;
}
inline void AppParam::set_nodealarmset(::google::protobuf::uint32 value) {
  set_has_nodealarmset();
  nodealarmset_ = value;
}

// optional uint32 confirm = 7;
inline bool AppParam::has_confirm() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AppParam::set_has_confirm() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AppParam::clear_has_confirm() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AppParam::clear_confirm() {
  confirm_ = 0u;
  clear_has_confirm();
}
inline ::google::protobuf::uint32 AppParam::confirm() const {
  return confirm_;
}
inline void AppParam::set_confirm(::google::protobuf::uint32 value) {
  set_has_confirm();
  confirm_ = value;
}

// optional .SmokeCtrl smokeCtrl = 8;
inline bool AppParam::has_smokectrl() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AppParam::set_has_smokectrl() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AppParam::clear_has_smokectrl() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AppParam::clear_smokectrl() {
  smokectrl_ = 0;
  clear_has_smokectrl();
}
inline ::SmokeCtrl AppParam::smokectrl() const {
  return static_cast< ::SmokeCtrl >(smokectrl_);
}
inline void AppParam::set_smokectrl(::SmokeCtrl value) {
  assert(::SmokeCtrl_IsValid(value));
  set_has_smokectrl();
  smokectrl_ = value;
}

// optional uint32 uploadRepeat = 9;
inline bool AppParam::has_uploadrepeat() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AppParam::set_has_uploadrepeat() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AppParam::clear_has_uploadrepeat() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AppParam::clear_uploadrepeat() {
  uploadrepeat_ = 0u;
  clear_has_uploadrepeat();
}
inline ::google::protobuf::uint32 AppParam::uploadrepeat() const {
  return uploadrepeat_;
}
inline void AppParam::set_uploadrepeat(::google::protobuf::uint32 value) {
  set_has_uploadrepeat();
  uploadrepeat_ = value;
}

// optional uint32 alarmUploadInterval = 10;
inline bool AppParam::has_alarmuploadinterval() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AppParam::set_has_alarmuploadinterval() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AppParam::clear_has_alarmuploadinterval() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AppParam::clear_alarmuploadinterval() {
  alarmuploadinterval_ = 0u;
  clear_has_alarmuploadinterval();
}
inline ::google::protobuf::uint32 AppParam::alarmuploadinterval() const {
  return alarmuploadinterval_;
}
inline void AppParam::set_alarmuploadinterval(::google::protobuf::uint32 value) {
  set_has_alarmuploadinterval();
  alarmuploadinterval_ = value;
}

// optional uint32 alarmUploadNb = 11;
inline bool AppParam::has_alarmuploadnb() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AppParam::set_has_alarmuploadnb() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AppParam::clear_has_alarmuploadnb() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AppParam::clear_alarmuploadnb() {
  alarmuploadnb_ = 0u;
  clear_has_alarmuploadnb();
}
inline ::google::protobuf::uint32 AppParam::alarmuploadnb() const {
  return alarmuploadnb_;
}
inline void AppParam::set_alarmuploadnb(::google::protobuf::uint32 value) {
  set_has_alarmuploadnb();
  alarmuploadnb_ = value;
}

// optional .TrackerCtrl trackerCtrl = 12;
inline bool AppParam::has_trackerctrl() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void AppParam::set_has_trackerctrl() {
  _has_bits_[0] |= 0x00000800u;
}
inline void AppParam::clear_has_trackerctrl() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void AppParam::clear_trackerctrl() {
  trackerctrl_ = 0;
  clear_has_trackerctrl();
}
inline ::TrackerCtrl AppParam::trackerctrl() const {
  return static_cast< ::TrackerCtrl >(trackerctrl_);
}
inline void AppParam::set_trackerctrl(::TrackerCtrl value) {
  assert(::TrackerCtrl_IsValid(value));
  set_has_trackerctrl();
  trackerctrl_ = value;
}

// optional uint32 trackerEmergencyTime = 13;
inline bool AppParam::has_trackeremergencytime() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void AppParam::set_has_trackeremergencytime() {
  _has_bits_[0] |= 0x00001000u;
}
inline void AppParam::clear_has_trackeremergencytime() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void AppParam::clear_trackeremergencytime() {
  trackeremergencytime_ = 0u;
  clear_has_trackeremergencytime();
}
inline ::google::protobuf::uint32 AppParam::trackeremergencytime() const {
  return trackeremergencytime_;
}
inline void AppParam::set_trackeremergencytime(::google::protobuf::uint32 value) {
  set_has_trackeremergencytime();
  trackeremergencytime_ = value;
}

// -------------------------------------------------------------------

// ElecFireData

// optional sint32 vol_val = 1;
inline bool ElecFireData::has_vol_val() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ElecFireData::set_has_vol_val() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ElecFireData::clear_has_vol_val() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ElecFireData::clear_vol_val() {
  vol_val_ = 0;
  clear_has_vol_val();
}
inline ::google::protobuf::int32 ElecFireData::vol_val() const {
  return vol_val_;
}
inline void ElecFireData::set_vol_val(::google::protobuf::int32 value) {
  set_has_vol_val();
  vol_val_ = value;
}

// optional uint32 curr_val = 2;
inline bool ElecFireData::has_curr_val() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ElecFireData::set_has_curr_val() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ElecFireData::clear_has_curr_val() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ElecFireData::clear_curr_val() {
  curr_val_ = 0u;
  clear_has_curr_val();
}
inline ::google::protobuf::uint32 ElecFireData::curr_val() const {
  return curr_val_;
}
inline void ElecFireData::set_curr_val(::google::protobuf::uint32 value) {
  set_has_curr_val();
  curr_val_ = value;
}

// optional sint32 leakage_val = 3;
inline bool ElecFireData::has_leakage_val() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ElecFireData::set_has_leakage_val() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ElecFireData::clear_has_leakage_val() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ElecFireData::clear_leakage_val() {
  leakage_val_ = 0;
  clear_has_leakage_val();
}
inline ::google::protobuf::int32 ElecFireData::leakage_val() const {
  return leakage_val_;
}
inline void ElecFireData::set_leakage_val(::google::protobuf::int32 value) {
  set_has_leakage_val();
  leakage_val_ = value;
}

// optional uint32 power_val = 4;
inline bool ElecFireData::has_power_val() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ElecFireData::set_has_power_val() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ElecFireData::clear_has_power_val() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ElecFireData::clear_power_val() {
  power_val_ = 0u;
  clear_has_power_val();
}
inline ::google::protobuf::uint32 ElecFireData::power_val() const {
  return power_val_;
}
inline void ElecFireData::set_power_val(::google::protobuf::uint32 value) {
  set_has_power_val();
  power_val_ = value;
}

// optional uint32 elec_energy_val = 5;
inline bool ElecFireData::has_elec_energy_val() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ElecFireData::set_has_elec_energy_val() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ElecFireData::clear_has_elec_energy_val() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ElecFireData::clear_elec_energy_val() {
  elec_energy_val_ = 0u;
  clear_has_elec_energy_val();
}
inline ::google::protobuf::uint32 ElecFireData::elec_energy_val() const {
  return elec_energy_val_;
}
inline void ElecFireData::set_elec_energy_val(::google::protobuf::uint32 value) {
  set_has_elec_energy_val();
  elec_energy_val_ = value;
}

// optional uint32 temp_val = 6;
inline bool ElecFireData::has_temp_val() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ElecFireData::set_has_temp_val() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ElecFireData::clear_has_temp_val() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ElecFireData::clear_temp_val() {
  temp_val_ = 0u;
  clear_has_temp_val();
}
inline ::google::protobuf::uint32 ElecFireData::temp_val() const {
  return temp_val_;
}
inline void ElecFireData::set_temp_val(::google::protobuf::uint32 value) {
  set_has_temp_val();
  temp_val_ = value;
}

// optional uint32 status = 7;
inline bool ElecFireData::has_status() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ElecFireData::set_has_status() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ElecFireData::clear_has_status() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ElecFireData::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 ElecFireData::status() const {
  return status_;
}
inline void ElecFireData::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// optional uint32 alarm = 8;
inline bool ElecFireData::has_alarm() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ElecFireData::set_has_alarm() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ElecFireData::clear_has_alarm() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ElecFireData::clear_alarm() {
  alarm_ = 0u;
  clear_has_alarm();
}
inline ::google::protobuf::uint32 ElecFireData::alarm() const {
  return alarm_;
}
inline void ElecFireData::set_alarm(::google::protobuf::uint32 value) {
  set_has_alarm();
  alarm_ = value;
}

// optional uint32 error = 9;
inline bool ElecFireData::has_error() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ElecFireData::set_has_error() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ElecFireData::clear_has_error() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ElecFireData::clear_error() {
  error_ = 0u;
  clear_has_error();
}
inline ::google::protobuf::uint32 ElecFireData::error() const {
  return error_;
}
inline void ElecFireData::set_error(::google::protobuf::uint32 value) {
  set_has_error();
  error_ = value;
}

// optional uint32 sensorPwd = 10;
inline bool ElecFireData::has_sensorpwd() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ElecFireData::set_has_sensorpwd() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ElecFireData::clear_has_sensorpwd() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ElecFireData::clear_sensorpwd() {
  sensorpwd_ = 0u;
  clear_has_sensorpwd();
}
inline ::google::protobuf::uint32 ElecFireData::sensorpwd() const {
  return sensorpwd_;
}
inline void ElecFireData::set_sensorpwd(::google::protobuf::uint32 value) {
  set_has_sensorpwd();
  sensorpwd_ = value;
}

// optional uint32 leakageTh = 11;
inline bool ElecFireData::has_leakageth() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ElecFireData::set_has_leakageth() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ElecFireData::clear_has_leakageth() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ElecFireData::clear_leakageth() {
  leakageth_ = 0u;
  clear_has_leakageth();
}
inline ::google::protobuf::uint32 ElecFireData::leakageth() const {
  return leakageth_;
}
inline void ElecFireData::set_leakageth(::google::protobuf::uint32 value) {
  set_has_leakageth();
  leakageth_ = value;
}

// optional uint32 tempTh = 12;
inline bool ElecFireData::has_tempth() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ElecFireData::set_has_tempth() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ElecFireData::clear_has_tempth() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ElecFireData::clear_tempth() {
  tempth_ = 0u;
  clear_has_tempth();
}
inline ::google::protobuf::uint32 ElecFireData::tempth() const {
  return tempth_;
}
inline void ElecFireData::set_tempth(::google::protobuf::uint32 value) {
  set_has_tempth();
  tempth_ = value;
}

// optional uint32 currentTh = 13;
inline bool ElecFireData::has_currentth() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ElecFireData::set_has_currentth() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ElecFireData::clear_has_currentth() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ElecFireData::clear_currentth() {
  currentth_ = 0u;
  clear_has_currentth();
}
inline ::google::protobuf::uint32 ElecFireData::currentth() const {
  return currentth_;
}
inline void ElecFireData::set_currentth(::google::protobuf::uint32 value) {
  set_has_currentth();
  currentth_ = value;
}

// optional uint32 loadTh = 14;
inline bool ElecFireData::has_loadth() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ElecFireData::set_has_loadth() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ElecFireData::clear_has_loadth() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ElecFireData::clear_loadth() {
  loadth_ = 0u;
  clear_has_loadth();
}
inline ::google::protobuf::uint32 ElecFireData::loadth() const {
  return loadth_;
}
inline void ElecFireData::set_loadth(::google::protobuf::uint32 value) {
  set_has_loadth();
  loadth_ = value;
}

// optional uint32 volHighTh = 15;
inline bool ElecFireData::has_volhighth() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ElecFireData::set_has_volhighth() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ElecFireData::clear_has_volhighth() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ElecFireData::clear_volhighth() {
  volhighth_ = 0u;
  clear_has_volhighth();
}
inline ::google::protobuf::uint32 ElecFireData::volhighth() const {
  return volhighth_;
}
inline void ElecFireData::set_volhighth(::google::protobuf::uint32 value) {
  set_has_volhighth();
  volhighth_ = value;
}

// optional uint32 volLowTh = 16;
inline bool ElecFireData::has_vollowth() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ElecFireData::set_has_vollowth() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ElecFireData::clear_has_vollowth() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ElecFireData::clear_vollowth() {
  vollowth_ = 0u;
  clear_has_vollowth();
}
inline ::google::protobuf::uint32 ElecFireData::vollowth() const {
  return vollowth_;
}
inline void ElecFireData::set_vollowth(::google::protobuf::uint32 value) {
  set_has_vollowth();
  vollowth_ = value;
}

// optional uint32 cmd = 17;
inline bool ElecFireData::has_cmd() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ElecFireData::set_has_cmd() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ElecFireData::clear_has_cmd() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ElecFireData::clear_cmd() {
  cmd_ = 0u;
  clear_has_cmd();
}
inline ::google::protobuf::uint32 ElecFireData::cmd() const {
  return cmd_;
}
inline void ElecFireData::set_cmd(::google::protobuf::uint32 value) {
  set_has_cmd();
  cmd_ = value;
}

// optional uint32 autoSwitch = 18;
inline bool ElecFireData::has_autoswitch() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ElecFireData::set_has_autoswitch() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ElecFireData::clear_has_autoswitch() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ElecFireData::clear_autoswitch() {
  autoswitch_ = 0u;
  clear_has_autoswitch();
}
inline ::google::protobuf::uint32 ElecFireData::autoswitch() const {
  return autoswitch_;
}
inline void ElecFireData::set_autoswitch(::google::protobuf::uint32 value) {
  set_has_autoswitch();
  autoswitch_ = value;
}

// -------------------------------------------------------------------

// MantunData

// optional uint32 volVal = 1;
inline bool MantunData::has_volval() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MantunData::set_has_volval() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MantunData::clear_has_volval() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MantunData::clear_volval() {
  volval_ = 0u;
  clear_has_volval();
}
inline ::google::protobuf::uint32 MantunData::volval() const {
  return volval_;
}
inline void MantunData::set_volval(::google::protobuf::uint32 value) {
  set_has_volval();
  volval_ = value;
}

// optional uint32 currVal = 2;
inline bool MantunData::has_currval() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MantunData::set_has_currval() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MantunData::clear_has_currval() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MantunData::clear_currval() {
  currval_ = 0u;
  clear_has_currval();
}
inline ::google::protobuf::uint32 MantunData::currval() const {
  return currval_;
}
inline void MantunData::set_currval(::google::protobuf::uint32 value) {
  set_has_currval();
  currval_ = value;
}

// optional uint32 leakageVal = 3;
inline bool MantunData::has_leakageval() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MantunData::set_has_leakageval() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MantunData::clear_has_leakageval() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MantunData::clear_leakageval() {
  leakageval_ = 0u;
  clear_has_leakageval();
}
inline ::google::protobuf::uint32 MantunData::leakageval() const {
  return leakageval_;
}
inline void MantunData::set_leakageval(::google::protobuf::uint32 value) {
  set_has_leakageval();
  leakageval_ = value;
}

// optional uint32 powerVal = 4;
inline bool MantunData::has_powerval() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MantunData::set_has_powerval() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MantunData::clear_has_powerval() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MantunData::clear_powerval() {
  powerval_ = 0u;
  clear_has_powerval();
}
inline ::google::protobuf::uint32 MantunData::powerval() const {
  return powerval_;
}
inline void MantunData::set_powerval(::google::protobuf::uint32 value) {
  set_has_powerval();
  powerval_ = value;
}

// optional uint32 kwhVal = 5;
inline bool MantunData::has_kwhval() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MantunData::set_has_kwhval() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MantunData::clear_has_kwhval() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MantunData::clear_kwhval() {
  kwhval_ = 0u;
  clear_has_kwhval();
}
inline ::google::protobuf::uint32 MantunData::kwhval() const {
  return kwhval_;
}
inline void MantunData::set_kwhval(::google::protobuf::uint32 value) {
  set_has_kwhval();
  kwhval_ = value;
}

// optional uint32 tempVal = 6;
inline bool MantunData::has_tempval() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MantunData::set_has_tempval() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MantunData::clear_has_tempval() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MantunData::clear_tempval() {
  tempval_ = 0u;
  clear_has_tempval();
}
inline ::google::protobuf::uint32 MantunData::tempval() const {
  return tempval_;
}
inline void MantunData::set_tempval(::google::protobuf::uint32 value) {
  set_has_tempval();
  tempval_ = value;
}

// optional uint32 status = 7;
inline bool MantunData::has_status() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MantunData::set_has_status() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MantunData::clear_has_status() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MantunData::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 MantunData::status() const {
  return status_;
}
inline void MantunData::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// optional uint32 swOnOff = 8;
inline bool MantunData::has_swonoff() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MantunData::set_has_swonoff() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MantunData::clear_has_swonoff() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MantunData::clear_swonoff() {
  swonoff_ = 0u;
  clear_has_swonoff();
}
inline ::google::protobuf::uint32 MantunData::swonoff() const {
  return swonoff_;
}
inline void MantunData::set_swonoff(::google::protobuf::uint32 value) {
  set_has_swonoff();
  swonoff_ = value;
}

// optional uint32 temp1Outside = 9;
inline bool MantunData::has_temp1outside() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MantunData::set_has_temp1outside() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MantunData::clear_has_temp1outside() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MantunData::clear_temp1outside() {
  temp1outside_ = 0u;
  clear_has_temp1outside();
}
inline ::google::protobuf::uint32 MantunData::temp1outside() const {
  return temp1outside_;
}
inline void MantunData::set_temp1outside(::google::protobuf::uint32 value) {
  set_has_temp1outside();
  temp1outside_ = value;
}

// optional uint32 temp2Contact = 10;
inline bool MantunData::has_temp2contact() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MantunData::set_has_temp2contact() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MantunData::clear_has_temp2contact() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MantunData::clear_temp2contact() {
  temp2contact_ = 0u;
  clear_has_temp2contact();
}
inline ::google::protobuf::uint32 MantunData::temp2contact() const {
  return temp2contact_;
}
inline void MantunData::set_temp2contact(::google::protobuf::uint32 value) {
  set_has_temp2contact();
  temp2contact_ = value;
}

// optional uint32 volHighTh = 11;
inline bool MantunData::has_volhighth() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MantunData::set_has_volhighth() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MantunData::clear_has_volhighth() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MantunData::clear_volhighth() {
  volhighth_ = 0u;
  clear_has_volhighth();
}
inline ::google::protobuf::uint32 MantunData::volhighth() const {
  return volhighth_;
}
inline void MantunData::set_volhighth(::google::protobuf::uint32 value) {
  set_has_volhighth();
  volhighth_ = value;
}

// optional uint32 volLowTh = 12;
inline bool MantunData::has_vollowth() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MantunData::set_has_vollowth() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MantunData::clear_has_vollowth() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MantunData::clear_vollowth() {
  vollowth_ = 0u;
  clear_has_vollowth();
}
inline ::google::protobuf::uint32 MantunData::vollowth() const {
  return vollowth_;
}
inline void MantunData::set_vollowth(::google::protobuf::uint32 value) {
  set_has_vollowth();
  vollowth_ = value;
}

// optional uint32 leakageTh = 13;
inline bool MantunData::has_leakageth() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MantunData::set_has_leakageth() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MantunData::clear_has_leakageth() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MantunData::clear_leakageth() {
  leakageth_ = 0u;
  clear_has_leakageth();
}
inline ::google::protobuf::uint32 MantunData::leakageth() const {
  return leakageth_;
}
inline void MantunData::set_leakageth(::google::protobuf::uint32 value) {
  set_has_leakageth();
  leakageth_ = value;
}

// optional uint32 tempTh = 14;
inline bool MantunData::has_tempth() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MantunData::set_has_tempth() {
  _has_bits_[0] |= 0x00002000u;
}
inline void MantunData::clear_has_tempth() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void MantunData::clear_tempth() {
  tempth_ = 0u;
  clear_has_tempth();
}
inline ::google::protobuf::uint32 MantunData::tempth() const {
  return tempth_;
}
inline void MantunData::set_tempth(::google::protobuf::uint32 value) {
  set_has_tempth();
  tempth_ = value;
}

// optional uint32 currentTh = 15;
inline bool MantunData::has_currentth() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void MantunData::set_has_currentth() {
  _has_bits_[0] |= 0x00004000u;
}
inline void MantunData::clear_has_currentth() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void MantunData::clear_currentth() {
  currentth_ = 0u;
  clear_has_currentth();
}
inline ::google::protobuf::uint32 MantunData::currentth() const {
  return currentth_;
}
inline void MantunData::set_currentth(::google::protobuf::uint32 value) {
  set_has_currentth();
  currentth_ = value;
}

// optional uint32 powerTh = 16;
inline bool MantunData::has_powerth() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void MantunData::set_has_powerth() {
  _has_bits_[0] |= 0x00008000u;
}
inline void MantunData::clear_has_powerth() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void MantunData::clear_powerth() {
  powerth_ = 0u;
  clear_has_powerth();
}
inline ::google::protobuf::uint32 MantunData::powerth() const {
  return powerth_;
}
inline void MantunData::set_powerth(::google::protobuf::uint32 value) {
  set_has_powerth();
  powerth_ = value;
}

// optional uint32 temp1OutsideTh = 17;
inline bool MantunData::has_temp1outsideth() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void MantunData::set_has_temp1outsideth() {
  _has_bits_[0] |= 0x00010000u;
}
inline void MantunData::clear_has_temp1outsideth() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void MantunData::clear_temp1outsideth() {
  temp1outsideth_ = 0u;
  clear_has_temp1outsideth();
}
inline ::google::protobuf::uint32 MantunData::temp1outsideth() const {
  return temp1outsideth_;
}
inline void MantunData::set_temp1outsideth(::google::protobuf::uint32 value) {
  set_has_temp1outsideth();
  temp1outsideth_ = value;
}

// optional uint32 temp2ContactTh = 18;
inline bool MantunData::has_temp2contactth() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void MantunData::set_has_temp2contactth() {
  _has_bits_[0] |= 0x00020000u;
}
inline void MantunData::clear_has_temp2contactth() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void MantunData::clear_temp2contactth() {
  temp2contactth_ = 0u;
  clear_has_temp2contactth();
}
inline ::google::protobuf::uint32 MantunData::temp2contactth() const {
  return temp2contactth_;
}
inline void MantunData::set_temp2contactth(::google::protobuf::uint32 value) {
  set_has_temp2contactth();
  temp2contactth_ = value;
}

// optional uint32 attribute = 19;
inline bool MantunData::has_attribute() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void MantunData::set_has_attribute() {
  _has_bits_[0] |= 0x00040000u;
}
inline void MantunData::clear_has_attribute() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void MantunData::clear_attribute() {
  attribute_ = 0u;
  clear_has_attribute();
}
inline ::google::protobuf::uint32 MantunData::attribute() const {
  return attribute_;
}
inline void MantunData::set_attribute(::google::protobuf::uint32 value) {
  set_has_attribute();
  attribute_ = value;
}

// optional uint32 cmd = 20;
inline bool MantunData::has_cmd() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void MantunData::set_has_cmd() {
  _has_bits_[0] |= 0x00080000u;
}
inline void MantunData::clear_has_cmd() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void MantunData::clear_cmd() {
  cmd_ = 0u;
  clear_has_cmd();
}
inline ::google::protobuf::uint32 MantunData::cmd() const {
  return cmd_;
}
inline void MantunData::set_cmd(::google::protobuf::uint32 value) {
  set_has_cmd();
  cmd_ = value;
}

// optional uint32 warning = 21;
inline bool MantunData::has_warning() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void MantunData::set_has_warning() {
  _has_bits_[0] |= 0x00100000u;
}
inline void MantunData::clear_has_warning() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void MantunData::clear_warning() {
  warning_ = 0u;
  clear_has_warning();
}
inline ::google::protobuf::uint32 MantunData::warning() const {
  return warning_;
}
inline void MantunData::set_warning(::google::protobuf::uint32 value) {
  set_has_warning();
  warning_ = value;
}

// -------------------------------------------------------------------

// Cayman

// optional uint32 isSmoke = 1;
inline bool Cayman::has_issmoke() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Cayman::set_has_issmoke() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Cayman::clear_has_issmoke() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Cayman::clear_issmoke() {
  issmoke_ = 0u;
  clear_has_issmoke();
}
inline ::google::protobuf::uint32 Cayman::issmoke() const {
  return issmoke_;
}
inline void Cayman::set_issmoke(::google::protobuf::uint32 value) {
  set_has_issmoke();
  issmoke_ = value;
}

// optional uint32 isMoved = 2;
inline bool Cayman::has_ismoved() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Cayman::set_has_ismoved() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Cayman::clear_has_ismoved() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Cayman::clear_ismoved() {
  ismoved_ = 0u;
  clear_has_ismoved();
}
inline ::google::protobuf::uint32 Cayman::ismoved() const {
  return ismoved_;
}
inline void Cayman::set_ismoved(::google::protobuf::uint32 value) {
  set_has_ismoved();
  ismoved_ = value;
}

// optional sint32 valueOfTem = 3;
inline bool Cayman::has_valueoftem() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Cayman::set_has_valueoftem() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Cayman::clear_has_valueoftem() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Cayman::clear_valueoftem() {
  valueoftem_ = 0;
  clear_has_valueoftem();
}
inline ::google::protobuf::int32 Cayman::valueoftem() const {
  return valueoftem_;
}
inline void Cayman::set_valueoftem(::google::protobuf::int32 value) {
  set_has_valueoftem();
  valueoftem_ = value;
}

// optional uint32 valueOfHum = 4;
inline bool Cayman::has_valueofhum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Cayman::set_has_valueofhum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Cayman::clear_has_valueofhum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Cayman::clear_valueofhum() {
  valueofhum_ = 0u;
  clear_has_valueofhum();
}
inline ::google::protobuf::uint32 Cayman::valueofhum() const {
  return valueofhum_;
}
inline void Cayman::set_valueofhum(::google::protobuf::uint32 value) {
  set_has_valueofhum();
  valueofhum_ = value;
}

// optional uint32 valueOfSmoke = 5;
inline bool Cayman::has_valueofsmoke() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Cayman::set_has_valueofsmoke() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Cayman::clear_has_valueofsmoke() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Cayman::clear_valueofsmoke() {
  valueofsmoke_ = 0u;
  clear_has_valueofsmoke();
}
inline ::google::protobuf::uint32 Cayman::valueofsmoke() const {
  return valueofsmoke_;
}
inline void Cayman::set_valueofsmoke(::google::protobuf::uint32 value) {
  set_has_valueofsmoke();
  valueofsmoke_ = value;
}

// optional uint32 standarOfSmoke = 6;
inline bool Cayman::has_standarofsmoke() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Cayman::set_has_standarofsmoke() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Cayman::clear_has_standarofsmoke() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Cayman::clear_standarofsmoke() {
  standarofsmoke_ = 0u;
  clear_has_standarofsmoke();
}
inline ::google::protobuf::uint32 Cayman::standarofsmoke() const {
  return standarofsmoke_;
}
inline void Cayman::set_standarofsmoke(::google::protobuf::uint32 value) {
  set_has_standarofsmoke();
  standarofsmoke_ = value;
}

// optional sint32 alarmOfHighTem = 7;
inline bool Cayman::has_alarmofhightem() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Cayman::set_has_alarmofhightem() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Cayman::clear_has_alarmofhightem() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Cayman::clear_alarmofhightem() {
  alarmofhightem_ = 0;
  clear_has_alarmofhightem();
}
inline ::google::protobuf::int32 Cayman::alarmofhightem() const {
  return alarmofhightem_;
}
inline void Cayman::set_alarmofhightem(::google::protobuf::int32 value) {
  set_has_alarmofhightem();
  alarmofhightem_ = value;
}

// optional sint32 alarmOfLowTem = 8;
inline bool Cayman::has_alarmoflowtem() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Cayman::set_has_alarmoflowtem() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Cayman::clear_has_alarmoflowtem() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Cayman::clear_alarmoflowtem() {
  alarmoflowtem_ = 0;
  clear_has_alarmoflowtem();
}
inline ::google::protobuf::int32 Cayman::alarmoflowtem() const {
  return alarmoflowtem_;
}
inline void Cayman::set_alarmoflowtem(::google::protobuf::int32 value) {
  set_has_alarmoflowtem();
  alarmoflowtem_ = value;
}

// optional uint32 alarmOfHighHum = 9;
inline bool Cayman::has_alarmofhighhum() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Cayman::set_has_alarmofhighhum() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Cayman::clear_has_alarmofhighhum() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Cayman::clear_alarmofhighhum() {
  alarmofhighhum_ = 0u;
  clear_has_alarmofhighhum();
}
inline ::google::protobuf::uint32 Cayman::alarmofhighhum() const {
  return alarmofhighhum_;
}
inline void Cayman::set_alarmofhighhum(::google::protobuf::uint32 value) {
  set_has_alarmofhighhum();
  alarmofhighhum_ = value;
}

// optional uint32 alarmOfLowHum = 10;
inline bool Cayman::has_alarmoflowhum() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Cayman::set_has_alarmoflowhum() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Cayman::clear_has_alarmoflowhum() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Cayman::clear_alarmoflowhum() {
  alarmoflowhum_ = 0u;
  clear_has_alarmoflowhum();
}
inline ::google::protobuf::uint32 Cayman::alarmoflowhum() const {
  return alarmoflowhum_;
}
inline void Cayman::set_alarmoflowhum(::google::protobuf::uint32 value) {
  set_has_alarmoflowhum();
  alarmoflowhum_ = value;
}

// optional uint32 cmd = 11;
inline bool Cayman::has_cmd() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Cayman::set_has_cmd() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Cayman::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Cayman::clear_cmd() {
  cmd_ = 0u;
  clear_has_cmd();
}
inline ::google::protobuf::uint32 Cayman::cmd() const {
  return cmd_;
}
inline void Cayman::set_cmd(::google::protobuf::uint32 value) {
  set_has_cmd();
  cmd_ = value;
}

// -------------------------------------------------------------------

// AcrelData

// optional uint32 channelType = 1;
inline bool AcrelData::has_channeltype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AcrelData::set_has_channeltype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AcrelData::clear_has_channeltype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AcrelData::clear_channeltype() {
  channeltype_ = 0u;
  clear_has_channeltype();
}
inline ::google::protobuf::uint32 AcrelData::channeltype() const {
  return channeltype_;
}
inline void AcrelData::set_channeltype(::google::protobuf::uint32 value) {
  set_has_channeltype();
  channeltype_ = value;
}

// optional uint32 shortCircuit = 2;
inline bool AcrelData::has_shortcircuit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AcrelData::set_has_shortcircuit() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AcrelData::clear_has_shortcircuit() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AcrelData::clear_shortcircuit() {
  shortcircuit_ = 0u;
  clear_has_shortcircuit();
}
inline ::google::protobuf::uint32 AcrelData::shortcircuit() const {
  return shortcircuit_;
}
inline void AcrelData::set_shortcircuit(::google::protobuf::uint32 value) {
  set_has_shortcircuit();
  shortcircuit_ = value;
}

// optional uint32 openCircuit = 3;
inline bool AcrelData::has_opencircuit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AcrelData::set_has_opencircuit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AcrelData::clear_has_opencircuit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AcrelData::clear_opencircuit() {
  opencircuit_ = 0u;
  clear_has_opencircuit();
}
inline ::google::protobuf::uint32 AcrelData::opencircuit() const {
  return opencircuit_;
}
inline void AcrelData::set_opencircuit(::google::protobuf::uint32 value) {
  set_has_opencircuit();
  opencircuit_ = value;
}

// optional uint32 chStatus = 4;
inline bool AcrelData::has_chstatus() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AcrelData::set_has_chstatus() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AcrelData::clear_has_chstatus() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AcrelData::clear_chstatus() {
  chstatus_ = 0u;
  clear_has_chstatus();
}
inline ::google::protobuf::uint32 AcrelData::chstatus() const {
  return chstatus_;
}
inline void AcrelData::set_chstatus(::google::protobuf::uint32 value) {
  set_has_chstatus();
  chstatus_ = value;
}

// optional sint32 leakageVal = 5;
inline bool AcrelData::has_leakageval() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AcrelData::set_has_leakageval() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AcrelData::clear_has_leakageval() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AcrelData::clear_leakageval() {
  leakageval_ = 0;
  clear_has_leakageval();
}
inline ::google::protobuf::int32 AcrelData::leakageval() const {
  return leakageval_;
}
inline void AcrelData::set_leakageval(::google::protobuf::int32 value) {
  set_has_leakageval();
  leakageval_ = value;
}

// optional sint32 t1Val = 6;
inline bool AcrelData::has_t1val() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AcrelData::set_has_t1val() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AcrelData::clear_has_t1val() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AcrelData::clear_t1val() {
  t1val_ = 0;
  clear_has_t1val();
}
inline ::google::protobuf::int32 AcrelData::t1val() const {
  return t1val_;
}
inline void AcrelData::set_t1val(::google::protobuf::int32 value) {
  set_has_t1val();
  t1val_ = value;
}

// optional sint32 t2Val = 7;
inline bool AcrelData::has_t2val() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AcrelData::set_has_t2val() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AcrelData::clear_has_t2val() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AcrelData::clear_t2val() {
  t2val_ = 0;
  clear_has_t2val();
}
inline ::google::protobuf::int32 AcrelData::t2val() const {
  return t2val_;
}
inline void AcrelData::set_t2val(::google::protobuf::int32 value) {
  set_has_t2val();
  t2val_ = value;
}

// optional sint32 t3Val = 8;
inline bool AcrelData::has_t3val() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AcrelData::set_has_t3val() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AcrelData::clear_has_t3val() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AcrelData::clear_t3val() {
  t3val_ = 0;
  clear_has_t3val();
}
inline ::google::protobuf::int32 AcrelData::t3val() const {
  return t3val_;
}
inline void AcrelData::set_t3val(::google::protobuf::int32 value) {
  set_has_t3val();
  t3val_ = value;
}

// optional sint32 t4Val = 9;
inline bool AcrelData::has_t4val() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AcrelData::set_has_t4val() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AcrelData::clear_has_t4val() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AcrelData::clear_t4val() {
  t4val_ = 0;
  clear_has_t4val();
}
inline ::google::protobuf::int32 AcrelData::t4val() const {
  return t4val_;
}
inline void AcrelData::set_t4val(::google::protobuf::int32 value) {
  set_has_t4val();
  t4val_ = value;
}

// optional uint32 connectSw = 10;
inline bool AcrelData::has_connectsw() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AcrelData::set_has_connectsw() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AcrelData::clear_has_connectsw() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AcrelData::clear_connectsw() {
  connectsw_ = 0u;
  clear_has_connectsw();
}
inline ::google::protobuf::uint32 AcrelData::connectsw() const {
  return connectsw_;
}
inline void AcrelData::set_connectsw(::google::protobuf::uint32 value) {
  set_has_connectsw();
  connectsw_ = value;
}

// optional uint32 chEnable = 11;
inline bool AcrelData::has_chenable() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AcrelData::set_has_chenable() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AcrelData::clear_has_chenable() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AcrelData::clear_chenable() {
  chenable_ = 0u;
  clear_has_chenable();
}
inline ::google::protobuf::uint32 AcrelData::chenable() const {
  return chenable_;
}
inline void AcrelData::set_chenable(::google::protobuf::uint32 value) {
  set_has_chenable();
  chenable_ = value;
}

// optional uint32 leakageTh = 12;
inline bool AcrelData::has_leakageth() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void AcrelData::set_has_leakageth() {
  _has_bits_[0] |= 0x00000800u;
}
inline void AcrelData::clear_has_leakageth() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void AcrelData::clear_leakageth() {
  leakageth_ = 0u;
  clear_has_leakageth();
}
inline ::google::protobuf::uint32 AcrelData::leakageth() const {
  return leakageth_;
}
inline void AcrelData::set_leakageth(::google::protobuf::uint32 value) {
  set_has_leakageth();
  leakageth_ = value;
}

// optional uint32 t1Th = 13;
inline bool AcrelData::has_t1th() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void AcrelData::set_has_t1th() {
  _has_bits_[0] |= 0x00001000u;
}
inline void AcrelData::clear_has_t1th() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void AcrelData::clear_t1th() {
  t1th_ = 0u;
  clear_has_t1th();
}
inline ::google::protobuf::uint32 AcrelData::t1th() const {
  return t1th_;
}
inline void AcrelData::set_t1th(::google::protobuf::uint32 value) {
  set_has_t1th();
  t1th_ = value;
}

// optional uint32 t2Th = 14;
inline bool AcrelData::has_t2th() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void AcrelData::set_has_t2th() {
  _has_bits_[0] |= 0x00002000u;
}
inline void AcrelData::clear_has_t2th() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void AcrelData::clear_t2th() {
  t2th_ = 0u;
  clear_has_t2th();
}
inline ::google::protobuf::uint32 AcrelData::t2th() const {
  return t2th_;
}
inline void AcrelData::set_t2th(::google::protobuf::uint32 value) {
  set_has_t2th();
  t2th_ = value;
}

// optional uint32 t3Th = 15;
inline bool AcrelData::has_t3th() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void AcrelData::set_has_t3th() {
  _has_bits_[0] |= 0x00004000u;
}
inline void AcrelData::clear_has_t3th() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void AcrelData::clear_t3th() {
  t3th_ = 0u;
  clear_has_t3th();
}
inline ::google::protobuf::uint32 AcrelData::t3th() const {
  return t3th_;
}
inline void AcrelData::set_t3th(::google::protobuf::uint32 value) {
  set_has_t3th();
  t3th_ = value;
}

// optional uint32 t4Th = 16;
inline bool AcrelData::has_t4th() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void AcrelData::set_has_t4th() {
  _has_bits_[0] |= 0x00008000u;
}
inline void AcrelData::clear_has_t4th() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void AcrelData::clear_t4th() {
  t4th_ = 0u;
  clear_has_t4th();
}
inline ::google::protobuf::uint32 AcrelData::t4th() const {
  return t4th_;
}
inline void AcrelData::set_t4th(::google::protobuf::uint32 value) {
  set_has_t4th();
  t4th_ = value;
}

// optional uint32 passwd = 17;
inline bool AcrelData::has_passwd() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void AcrelData::set_has_passwd() {
  _has_bits_[0] |= 0x00010000u;
}
inline void AcrelData::clear_has_passwd() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void AcrelData::clear_passwd() {
  passwd_ = 0u;
  clear_has_passwd();
}
inline ::google::protobuf::uint32 AcrelData::passwd() const {
  return passwd_;
}
inline void AcrelData::set_passwd(::google::protobuf::uint32 value) {
  set_has_passwd();
  passwd_ = value;
}

// optional uint32 aVal = 18;
inline bool AcrelData::has_aval() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void AcrelData::set_has_aval() {
  _has_bits_[0] |= 0x00020000u;
}
inline void AcrelData::clear_has_aval() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void AcrelData::clear_aval() {
  aval_ = 0u;
  clear_has_aval();
}
inline ::google::protobuf::uint32 AcrelData::aval() const {
  return aval_;
}
inline void AcrelData::set_aval(::google::protobuf::uint32 value) {
  set_has_aval();
  aval_ = value;
}

// optional uint32 bVal = 19;
inline bool AcrelData::has_bval() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void AcrelData::set_has_bval() {
  _has_bits_[0] |= 0x00040000u;
}
inline void AcrelData::clear_has_bval() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void AcrelData::clear_bval() {
  bval_ = 0u;
  clear_has_bval();
}
inline ::google::protobuf::uint32 AcrelData::bval() const {
  return bval_;
}
inline void AcrelData::set_bval(::google::protobuf::uint32 value) {
  set_has_bval();
  bval_ = value;
}

// optional uint32 cVal = 20;
inline bool AcrelData::has_cval() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void AcrelData::set_has_cval() {
  _has_bits_[0] |= 0x00080000u;
}
inline void AcrelData::clear_has_cval() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void AcrelData::clear_cval() {
  cval_ = 0u;
  clear_has_cval();
}
inline ::google::protobuf::uint32 AcrelData::cval() const {
  return cval_;
}
inline void AcrelData::set_cval(::google::protobuf::uint32 value) {
  set_has_cval();
  cval_ = value;
}

// optional uint32 valStatus = 21;
inline bool AcrelData::has_valstatus() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void AcrelData::set_has_valstatus() {
  _has_bits_[0] |= 0x00100000u;
}
inline void AcrelData::clear_has_valstatus() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void AcrelData::clear_valstatus() {
  valstatus_ = 0u;
  clear_has_valstatus();
}
inline ::google::protobuf::uint32 AcrelData::valstatus() const {
  return valstatus_;
}
inline void AcrelData::set_valstatus(::google::protobuf::uint32 value) {
  set_has_valstatus();
  valstatus_ = value;
}

// optional uint32 aCurr = 22;
inline bool AcrelData::has_acurr() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void AcrelData::set_has_acurr() {
  _has_bits_[0] |= 0x00200000u;
}
inline void AcrelData::clear_has_acurr() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void AcrelData::clear_acurr() {
  acurr_ = 0u;
  clear_has_acurr();
}
inline ::google::protobuf::uint32 AcrelData::acurr() const {
  return acurr_;
}
inline void AcrelData::set_acurr(::google::protobuf::uint32 value) {
  set_has_acurr();
  acurr_ = value;
}

// optional uint32 bCurr = 23;
inline bool AcrelData::has_bcurr() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void AcrelData::set_has_bcurr() {
  _has_bits_[0] |= 0x00400000u;
}
inline void AcrelData::clear_has_bcurr() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void AcrelData::clear_bcurr() {
  bcurr_ = 0u;
  clear_has_bcurr();
}
inline ::google::protobuf::uint32 AcrelData::bcurr() const {
  return bcurr_;
}
inline void AcrelData::set_bcurr(::google::protobuf::uint32 value) {
  set_has_bcurr();
  bcurr_ = value;
}

// optional uint32 cCurr = 24;
inline bool AcrelData::has_ccurr() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void AcrelData::set_has_ccurr() {
  _has_bits_[0] |= 0x00800000u;
}
inline void AcrelData::clear_has_ccurr() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void AcrelData::clear_ccurr() {
  ccurr_ = 0u;
  clear_has_ccurr();
}
inline ::google::protobuf::uint32 AcrelData::ccurr() const {
  return ccurr_;
}
inline void AcrelData::set_ccurr(::google::protobuf::uint32 value) {
  set_has_ccurr();
  ccurr_ = value;
}

// optional uint32 currStatus = 25;
inline bool AcrelData::has_currstatus() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void AcrelData::set_has_currstatus() {
  _has_bits_[0] |= 0x01000000u;
}
inline void AcrelData::clear_has_currstatus() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void AcrelData::clear_currstatus() {
  currstatus_ = 0u;
  clear_has_currstatus();
}
inline ::google::protobuf::uint32 AcrelData::currstatus() const {
  return currstatus_;
}
inline void AcrelData::set_currstatus(::google::protobuf::uint32 value) {
  set_has_currstatus();
  currstatus_ = value;
}

// optional uint32 totalYg = 26;
inline bool AcrelData::has_totalyg() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void AcrelData::set_has_totalyg() {
  _has_bits_[0] |= 0x02000000u;
}
inline void AcrelData::clear_has_totalyg() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void AcrelData::clear_totalyg() {
  totalyg_ = 0u;
  clear_has_totalyg();
}
inline ::google::protobuf::uint32 AcrelData::totalyg() const {
  return totalyg_;
}
inline void AcrelData::set_totalyg(::google::protobuf::uint32 value) {
  set_has_totalyg();
  totalyg_ = value;
}

// optional uint32 totalWg = 27;
inline bool AcrelData::has_totalwg() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void AcrelData::set_has_totalwg() {
  _has_bits_[0] |= 0x04000000u;
}
inline void AcrelData::clear_has_totalwg() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void AcrelData::clear_totalwg() {
  totalwg_ = 0u;
  clear_has_totalwg();
}
inline ::google::protobuf::uint32 AcrelData::totalwg() const {
  return totalwg_;
}
inline void AcrelData::set_totalwg(::google::protobuf::uint32 value) {
  set_has_totalwg();
  totalwg_ = value;
}

// optional uint32 totalSz = 28;
inline bool AcrelData::has_totalsz() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void AcrelData::set_has_totalsz() {
  _has_bits_[0] |= 0x08000000u;
}
inline void AcrelData::clear_has_totalsz() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void AcrelData::clear_totalsz() {
  totalsz_ = 0u;
  clear_has_totalsz();
}
inline ::google::protobuf::uint32 AcrelData::totalsz() const {
  return totalsz_;
}
inline void AcrelData::set_totalsz(::google::protobuf::uint32 value) {
  set_has_totalsz();
  totalsz_ = value;
}

// optional uint32 totalFactor = 29;
inline bool AcrelData::has_totalfactor() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void AcrelData::set_has_totalfactor() {
  _has_bits_[0] |= 0x10000000u;
}
inline void AcrelData::clear_has_totalfactor() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void AcrelData::clear_totalfactor() {
  totalfactor_ = 0u;
  clear_has_totalfactor();
}
inline ::google::protobuf::uint32 AcrelData::totalfactor() const {
  return totalfactor_;
}
inline void AcrelData::set_totalfactor(::google::protobuf::uint32 value) {
  set_has_totalfactor();
  totalfactor_ = value;
}

// optional uint32 valHighSet = 30;
inline bool AcrelData::has_valhighset() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void AcrelData::set_has_valhighset() {
  _has_bits_[0] |= 0x20000000u;
}
inline void AcrelData::clear_has_valhighset() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void AcrelData::clear_valhighset() {
  valhighset_ = 0u;
  clear_has_valhighset();
}
inline ::google::protobuf::uint32 AcrelData::valhighset() const {
  return valhighset_;
}
inline void AcrelData::set_valhighset(::google::protobuf::uint32 value) {
  set_has_valhighset();
  valhighset_ = value;
}

// optional uint32 valLowSet = 31;
inline bool AcrelData::has_vallowset() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void AcrelData::set_has_vallowset() {
  _has_bits_[0] |= 0x40000000u;
}
inline void AcrelData::clear_has_vallowset() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void AcrelData::clear_vallowset() {
  vallowset_ = 0u;
  clear_has_vallowset();
}
inline ::google::protobuf::uint32 AcrelData::vallowset() const {
  return vallowset_;
}
inline void AcrelData::set_vallowset(::google::protobuf::uint32 value) {
  set_has_vallowset();
  vallowset_ = value;
}

// optional uint32 currHighSet = 32;
inline bool AcrelData::has_currhighset() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void AcrelData::set_has_currhighset() {
  _has_bits_[0] |= 0x80000000u;
}
inline void AcrelData::clear_has_currhighset() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void AcrelData::clear_currhighset() {
  currhighset_ = 0u;
  clear_has_currhighset();
}
inline ::google::protobuf::uint32 AcrelData::currhighset() const {
  return currhighset_;
}
inline void AcrelData::set_currhighset(::google::protobuf::uint32 value) {
  set_has_currhighset();
  currhighset_ = value;
}

// optional uint32 energyKwh = 33;
inline bool AcrelData::has_energykwh() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void AcrelData::set_has_energykwh() {
  _has_bits_[1] |= 0x00000001u;
}
inline void AcrelData::clear_has_energykwh() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void AcrelData::clear_energykwh() {
  energykwh_ = 0u;
  clear_has_energykwh();
}
inline ::google::protobuf::uint32 AcrelData::energykwh() const {
  return energykwh_;
}
inline void AcrelData::set_energykwh(::google::protobuf::uint32 value) {
  set_has_energykwh();
  energykwh_ = value;
}

// optional uint32 currentTh = 34;
inline bool AcrelData::has_currentth() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void AcrelData::set_has_currentth() {
  _has_bits_[1] |= 0x00000002u;
}
inline void AcrelData::clear_has_currentth() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void AcrelData::clear_currentth() {
  currentth_ = 0u;
  clear_has_currentth();
}
inline ::google::protobuf::uint32 AcrelData::currentth() const {
  return currentth_;
}
inline void AcrelData::set_currentth(::google::protobuf::uint32 value) {
  set_has_currentth();
  currentth_ = value;
}

// optional uint32 cmd = 35;
inline bool AcrelData::has_cmd() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void AcrelData::set_has_cmd() {
  _has_bits_[1] |= 0x00000004u;
}
inline void AcrelData::clear_has_cmd() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void AcrelData::clear_cmd() {
  cmd_ = 0u;
  clear_has_cmd();
}
inline ::google::protobuf::uint32 AcrelData::cmd() const {
  return cmd_;
}
inline void AcrelData::set_cmd(::google::protobuf::uint32 value) {
  set_has_cmd();
  cmd_ = value;
}

// optional uint32 devError = 36;
inline bool AcrelData::has_deverror() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void AcrelData::set_has_deverror() {
  _has_bits_[1] |= 0x00000008u;
}
inline void AcrelData::clear_has_deverror() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void AcrelData::clear_deverror() {
  deverror_ = 0u;
  clear_has_deverror();
}
inline ::google::protobuf::uint32 AcrelData::deverror() const {
  return deverror_;
}
inline void AcrelData::set_deverror(::google::protobuf::uint32 value) {
  set_has_deverror();
  deverror_ = value;
}

// optional uint32 ct = 37;
inline bool AcrelData::has_ct() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void AcrelData::set_has_ct() {
  _has_bits_[1] |= 0x00000010u;
}
inline void AcrelData::clear_has_ct() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void AcrelData::clear_ct() {
  ct_ = 0u;
  clear_has_ct();
}
inline ::google::protobuf::uint32 AcrelData::ct() const {
  return ct_;
}
inline void AcrelData::set_ct(::google::protobuf::uint32 value) {
  set_has_ct();
  ct_ = value;
}

// optional uint32 outputSw = 38;
inline bool AcrelData::has_outputsw() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void AcrelData::set_has_outputsw() {
  _has_bits_[1] |= 0x00000020u;
}
inline void AcrelData::clear_has_outputsw() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void AcrelData::clear_outputsw() {
  outputsw_ = 0u;
  clear_has_outputsw();
}
inline ::google::protobuf::uint32 AcrelData::outputsw() const {
  return outputsw_;
}
inline void AcrelData::set_outputsw(::google::protobuf::uint32 value) {
  set_has_outputsw();
  outputsw_ = value;
}

// -------------------------------------------------------------------

// MsgNode

// optional uint32 id = 1;
inline bool MsgNode::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgNode::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgNode::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgNode::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 MsgNode::id() const {
  return id_;
}
inline void MsgNode::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional uint32 cmd = 2;
inline bool MsgNode::has_cmd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgNode::set_has_cmd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgNode::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgNode::clear_cmd() {
  cmd_ = 0u;
  clear_has_cmd();
}
inline ::google::protobuf::uint32 MsgNode::cmd() const {
  return cmd_;
}
inline void MsgNode::set_cmd(::google::protobuf::uint32 value) {
  set_has_cmd();
  cmd_ = value;
}

// optional uint32 cmdRet = 3;
inline bool MsgNode::has_cmdret() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgNode::set_has_cmdret() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgNode::clear_has_cmdret() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgNode::clear_cmdret() {
  cmdret_ = 0u;
  clear_has_cmdret();
}
inline ::google::protobuf::uint32 MsgNode::cmdret() const {
  return cmdret_;
}
inline void MsgNode::set_cmdret(::google::protobuf::uint32 value) {
  set_has_cmdret();
  cmdret_ = value;
}

// optional .LpwanParam lpwanParam = 4;
inline bool MsgNode::has_lpwanparam() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgNode::set_has_lpwanparam() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgNode::clear_has_lpwanparam() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgNode::clear_lpwanparam() {
  if (lpwanparam_ != NULL) lpwanparam_->::LpwanParam::Clear();
  clear_has_lpwanparam();
}
inline const ::LpwanParam& MsgNode::lpwanparam() const {
  return lpwanparam_ != NULL ? *lpwanparam_ : *default_instance_->lpwanparam_;
}
inline ::LpwanParam* MsgNode::mutable_lpwanparam() {
  set_has_lpwanparam();
  if (lpwanparam_ == NULL) lpwanparam_ = new ::LpwanParam;
  return lpwanparam_;
}
inline ::LpwanParam* MsgNode::release_lpwanparam() {
  clear_has_lpwanparam();
  ::LpwanParam* temp = lpwanparam_;
  lpwanparam_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_lpwanparam(::LpwanParam* lpwanparam) {
  delete lpwanparam_;
  lpwanparam_ = lpwanparam;
  if (lpwanparam) {
    set_has_lpwanparam();
  } else {
    clear_has_lpwanparam();
  }
}

// optional .BleParam bleParam = 5;
inline bool MsgNode::has_bleparam() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MsgNode::set_has_bleparam() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MsgNode::clear_has_bleparam() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MsgNode::clear_bleparam() {
  if (bleparam_ != NULL) bleparam_->::BleParam::Clear();
  clear_has_bleparam();
}
inline const ::BleParam& MsgNode::bleparam() const {
  return bleparam_ != NULL ? *bleparam_ : *default_instance_->bleparam_;
}
inline ::BleParam* MsgNode::mutable_bleparam() {
  set_has_bleparam();
  if (bleparam_ == NULL) bleparam_ = new ::BleParam;
  return bleparam_;
}
inline ::BleParam* MsgNode::release_bleparam() {
  clear_has_bleparam();
  ::BleParam* temp = bleparam_;
  bleparam_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_bleparam(::BleParam* bleparam) {
  delete bleparam_;
  bleparam_ = bleparam;
  if (bleparam) {
    set_has_bleparam();
  } else {
    clear_has_bleparam();
  }
}

// optional .AppParam appParam = 6;
inline bool MsgNode::has_appparam() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MsgNode::set_has_appparam() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MsgNode::clear_has_appparam() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MsgNode::clear_appparam() {
  if (appparam_ != NULL) appparam_->::AppParam::Clear();
  clear_has_appparam();
}
inline const ::AppParam& MsgNode::appparam() const {
  return appparam_ != NULL ? *appparam_ : *default_instance_->appparam_;
}
inline ::AppParam* MsgNode::mutable_appparam() {
  set_has_appparam();
  if (appparam_ == NULL) appparam_ = new ::AppParam;
  return appparam_;
}
inline ::AppParam* MsgNode::release_appparam() {
  clear_has_appparam();
  ::AppParam* temp = appparam_;
  appparam_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_appparam(::AppParam* appparam) {
  delete appparam_;
  appparam_ = appparam;
  if (appparam) {
    set_has_appparam();
  } else {
    clear_has_appparam();
  }
}

// optional sint32 battery = 7;
inline bool MsgNode::has_battery() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MsgNode::set_has_battery() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MsgNode::clear_has_battery() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MsgNode::clear_battery() {
  battery_ = 0;
  clear_has_battery();
}
inline ::google::protobuf::int32 MsgNode::battery() const {
  return battery_;
}
inline void MsgNode::set_battery(::google::protobuf::int32 value) {
  set_has_battery();
  battery_ = value;
}

// optional .GpsData gps = 8;
inline bool MsgNode::has_gps() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MsgNode::set_has_gps() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MsgNode::clear_has_gps() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MsgNode::clear_gps() {
  if (gps_ != NULL) gps_->::GpsData::Clear();
  clear_has_gps();
}
inline const ::GpsData& MsgNode::gps() const {
  return gps_ != NULL ? *gps_ : *default_instance_->gps_;
}
inline ::GpsData* MsgNode::mutable_gps() {
  set_has_gps();
  if (gps_ == NULL) gps_ = new ::GpsData;
  return gps_;
}
inline ::GpsData* MsgNode::release_gps() {
  clear_has_gps();
  ::GpsData* temp = gps_;
  gps_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_gps(::GpsData* gps) {
  delete gps_;
  gps_ = gps;
  if (gps) {
    set_has_gps();
  } else {
    clear_has_gps();
  }
}

// optional .AxisData acceleration = 9;
inline bool MsgNode::has_acceleration() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MsgNode::set_has_acceleration() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MsgNode::clear_has_acceleration() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MsgNode::clear_acceleration() {
  if (acceleration_ != NULL) acceleration_->::AxisData::Clear();
  clear_has_acceleration();
}
inline const ::AxisData& MsgNode::acceleration() const {
  return acceleration_ != NULL ? *acceleration_ : *default_instance_->acceleration_;
}
inline ::AxisData* MsgNode::mutable_acceleration() {
  set_has_acceleration();
  if (acceleration_ == NULL) acceleration_ = new ::AxisData;
  return acceleration_;
}
inline ::AxisData* MsgNode::release_acceleration() {
  clear_has_acceleration();
  ::AxisData* temp = acceleration_;
  acceleration_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_acceleration(::AxisData* acceleration) {
  delete acceleration_;
  acceleration_ = acceleration;
  if (acceleration) {
    set_has_acceleration();
  } else {
    clear_has_acceleration();
  }
}

// optional .AxisData magnetism = 10;
inline bool MsgNode::has_magnetism() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MsgNode::set_has_magnetism() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MsgNode::clear_has_magnetism() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MsgNode::clear_magnetism() {
  if (magnetism_ != NULL) magnetism_->::AxisData::Clear();
  clear_has_magnetism();
}
inline const ::AxisData& MsgNode::magnetism() const {
  return magnetism_ != NULL ? *magnetism_ : *default_instance_->magnetism_;
}
inline ::AxisData* MsgNode::mutable_magnetism() {
  set_has_magnetism();
  if (magnetism_ == NULL) magnetism_ = new ::AxisData;
  return magnetism_;
}
inline ::AxisData* MsgNode::release_magnetism() {
  clear_has_magnetism();
  ::AxisData* temp = magnetism_;
  magnetism_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_magnetism(::AxisData* magnetism) {
  delete magnetism_;
  magnetism_ = magnetism;
  if (magnetism) {
    set_has_magnetism();
  } else {
    clear_has_magnetism();
  }
}

// optional .AxisData gyroscope = 11;
inline bool MsgNode::has_gyroscope() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MsgNode::set_has_gyroscope() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MsgNode::clear_has_gyroscope() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MsgNode::clear_gyroscope() {
  if (gyroscope_ != NULL) gyroscope_->::AxisData::Clear();
  clear_has_gyroscope();
}
inline const ::AxisData& MsgNode::gyroscope() const {
  return gyroscope_ != NULL ? *gyroscope_ : *default_instance_->gyroscope_;
}
inline ::AxisData* MsgNode::mutable_gyroscope() {
  set_has_gyroscope();
  if (gyroscope_ == NULL) gyroscope_ = new ::AxisData;
  return gyroscope_;
}
inline ::AxisData* MsgNode::release_gyroscope() {
  clear_has_gyroscope();
  ::AxisData* temp = gyroscope_;
  gyroscope_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_gyroscope(::AxisData* gyroscope) {
  delete gyroscope_;
  gyroscope_ = gyroscope;
  if (gyroscope) {
    set_has_gyroscope();
  } else {
    clear_has_gyroscope();
  }
}

// optional .SensorData temperature = 12;
inline bool MsgNode::has_temperature() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MsgNode::set_has_temperature() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MsgNode::clear_has_temperature() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MsgNode::clear_temperature() {
  if (temperature_ != NULL) temperature_->::SensorData::Clear();
  clear_has_temperature();
}
inline const ::SensorData& MsgNode::temperature() const {
  return temperature_ != NULL ? *temperature_ : *default_instance_->temperature_;
}
inline ::SensorData* MsgNode::mutable_temperature() {
  set_has_temperature();
  if (temperature_ == NULL) temperature_ = new ::SensorData;
  return temperature_;
}
inline ::SensorData* MsgNode::release_temperature() {
  clear_has_temperature();
  ::SensorData* temp = temperature_;
  temperature_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_temperature(::SensorData* temperature) {
  delete temperature_;
  temperature_ = temperature;
  if (temperature) {
    set_has_temperature();
  } else {
    clear_has_temperature();
  }
}

// optional .SensorData humidity = 13;
inline bool MsgNode::has_humidity() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MsgNode::set_has_humidity() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MsgNode::clear_has_humidity() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MsgNode::clear_humidity() {
  if (humidity_ != NULL) humidity_->::SensorData::Clear();
  clear_has_humidity();
}
inline const ::SensorData& MsgNode::humidity() const {
  return humidity_ != NULL ? *humidity_ : *default_instance_->humidity_;
}
inline ::SensorData* MsgNode::mutable_humidity() {
  set_has_humidity();
  if (humidity_ == NULL) humidity_ = new ::SensorData;
  return humidity_;
}
inline ::SensorData* MsgNode::release_humidity() {
  clear_has_humidity();
  ::SensorData* temp = humidity_;
  humidity_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_humidity(::SensorData* humidity) {
  delete humidity_;
  humidity_ = humidity;
  if (humidity) {
    set_has_humidity();
  } else {
    clear_has_humidity();
  }
}

// optional .SensorData light = 14;
inline bool MsgNode::has_light() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MsgNode::set_has_light() {
  _has_bits_[0] |= 0x00002000u;
}
inline void MsgNode::clear_has_light() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void MsgNode::clear_light() {
  if (light_ != NULL) light_->::SensorData::Clear();
  clear_has_light();
}
inline const ::SensorData& MsgNode::light() const {
  return light_ != NULL ? *light_ : *default_instance_->light_;
}
inline ::SensorData* MsgNode::mutable_light() {
  set_has_light();
  if (light_ == NULL) light_ = new ::SensorData;
  return light_;
}
inline ::SensorData* MsgNode::release_light() {
  clear_has_light();
  ::SensorData* temp = light_;
  light_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_light(::SensorData* light) {
  delete light_;
  light_ = light;
  if (light) {
    set_has_light();
  } else {
    clear_has_light();
  }
}

// optional .SensorData leak = 15;
inline bool MsgNode::has_leak() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void MsgNode::set_has_leak() {
  _has_bits_[0] |= 0x00004000u;
}
inline void MsgNode::clear_has_leak() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void MsgNode::clear_leak() {
  if (leak_ != NULL) leak_->::SensorData::Clear();
  clear_has_leak();
}
inline const ::SensorData& MsgNode::leak() const {
  return leak_ != NULL ? *leak_ : *default_instance_->leak_;
}
inline ::SensorData* MsgNode::mutable_leak() {
  set_has_leak();
  if (leak_ == NULL) leak_ = new ::SensorData;
  return leak_;
}
inline ::SensorData* MsgNode::release_leak() {
  clear_has_leak();
  ::SensorData* temp = leak_;
  leak_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_leak(::SensorData* leak) {
  delete leak_;
  leak_ = leak;
  if (leak) {
    set_has_leak();
  } else {
    clear_has_leak();
  }
}

// optional .SensorData co = 16;
inline bool MsgNode::has_co() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void MsgNode::set_has_co() {
  _has_bits_[0] |= 0x00008000u;
}
inline void MsgNode::clear_has_co() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void MsgNode::clear_co() {
  if (co_ != NULL) co_->::SensorData::Clear();
  clear_has_co();
}
inline const ::SensorData& MsgNode::co() const {
  return co_ != NULL ? *co_ : *default_instance_->co_;
}
inline ::SensorData* MsgNode::mutable_co() {
  set_has_co();
  if (co_ == NULL) co_ = new ::SensorData;
  return co_;
}
inline ::SensorData* MsgNode::release_co() {
  clear_has_co();
  ::SensorData* temp = co_;
  co_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_co(::SensorData* co) {
  delete co_;
  co_ = co;
  if (co) {
    set_has_co();
  } else {
    clear_has_co();
  }
}

// optional .SensorData co2 = 17;
inline bool MsgNode::has_co2() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void MsgNode::set_has_co2() {
  _has_bits_[0] |= 0x00010000u;
}
inline void MsgNode::clear_has_co2() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void MsgNode::clear_co2() {
  if (co2_ != NULL) co2_->::SensorData::Clear();
  clear_has_co2();
}
inline const ::SensorData& MsgNode::co2() const {
  return co2_ != NULL ? *co2_ : *default_instance_->co2_;
}
inline ::SensorData* MsgNode::mutable_co2() {
  set_has_co2();
  if (co2_ == NULL) co2_ = new ::SensorData;
  return co2_;
}
inline ::SensorData* MsgNode::release_co2() {
  clear_has_co2();
  ::SensorData* temp = co2_;
  co2_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_co2(::SensorData* co2) {
  delete co2_;
  co2_ = co2;
  if (co2) {
    set_has_co2();
  } else {
    clear_has_co2();
  }
}

// optional .SensorData so2 = 18;
inline bool MsgNode::has_so2() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void MsgNode::set_has_so2() {
  _has_bits_[0] |= 0x00020000u;
}
inline void MsgNode::clear_has_so2() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void MsgNode::clear_so2() {
  if (so2_ != NULL) so2_->::SensorData::Clear();
  clear_has_so2();
}
inline const ::SensorData& MsgNode::so2() const {
  return so2_ != NULL ? *so2_ : *default_instance_->so2_;
}
inline ::SensorData* MsgNode::mutable_so2() {
  set_has_so2();
  if (so2_ == NULL) so2_ = new ::SensorData;
  return so2_;
}
inline ::SensorData* MsgNode::release_so2() {
  clear_has_so2();
  ::SensorData* temp = so2_;
  so2_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_so2(::SensorData* so2) {
  delete so2_;
  so2_ = so2;
  if (so2) {
    set_has_so2();
  } else {
    clear_has_so2();
  }
}

// optional .SensorData no2 = 19;
inline bool MsgNode::has_no2() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void MsgNode::set_has_no2() {
  _has_bits_[0] |= 0x00040000u;
}
inline void MsgNode::clear_has_no2() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void MsgNode::clear_no2() {
  if (no2_ != NULL) no2_->::SensorData::Clear();
  clear_has_no2();
}
inline const ::SensorData& MsgNode::no2() const {
  return no2_ != NULL ? *no2_ : *default_instance_->no2_;
}
inline ::SensorData* MsgNode::mutable_no2() {
  set_has_no2();
  if (no2_ == NULL) no2_ = new ::SensorData;
  return no2_;
}
inline ::SensorData* MsgNode::release_no2() {
  clear_has_no2();
  ::SensorData* temp = no2_;
  no2_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_no2(::SensorData* no2) {
  delete no2_;
  no2_ = no2;
  if (no2) {
    set_has_no2();
  } else {
    clear_has_no2();
  }
}

// optional .SensorData ch4 = 20;
inline bool MsgNode::has_ch4() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void MsgNode::set_has_ch4() {
  _has_bits_[0] |= 0x00080000u;
}
inline void MsgNode::clear_has_ch4() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void MsgNode::clear_ch4() {
  if (ch4_ != NULL) ch4_->::SensorData::Clear();
  clear_has_ch4();
}
inline const ::SensorData& MsgNode::ch4() const {
  return ch4_ != NULL ? *ch4_ : *default_instance_->ch4_;
}
inline ::SensorData* MsgNode::mutable_ch4() {
  set_has_ch4();
  if (ch4_ == NULL) ch4_ = new ::SensorData;
  return ch4_;
}
inline ::SensorData* MsgNode::release_ch4() {
  clear_has_ch4();
  ::SensorData* temp = ch4_;
  ch4_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_ch4(::SensorData* ch4) {
  delete ch4_;
  ch4_ = ch4;
  if (ch4) {
    set_has_ch4();
  } else {
    clear_has_ch4();
  }
}

// optional .SensorData ch2o = 21;
inline bool MsgNode::has_ch2o() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void MsgNode::set_has_ch2o() {
  _has_bits_[0] |= 0x00100000u;
}
inline void MsgNode::clear_has_ch2o() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void MsgNode::clear_ch2o() {
  if (ch2o_ != NULL) ch2o_->::SensorData::Clear();
  clear_has_ch2o();
}
inline const ::SensorData& MsgNode::ch2o() const {
  return ch2o_ != NULL ? *ch2o_ : *default_instance_->ch2o_;
}
inline ::SensorData* MsgNode::mutable_ch2o() {
  set_has_ch2o();
  if (ch2o_ == NULL) ch2o_ = new ::SensorData;
  return ch2o_;
}
inline ::SensorData* MsgNode::release_ch2o() {
  clear_has_ch2o();
  ::SensorData* temp = ch2o_;
  ch2o_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_ch2o(::SensorData* ch2o) {
  delete ch2o_;
  ch2o_ = ch2o;
  if (ch2o) {
    set_has_ch2o();
  } else {
    clear_has_ch2o();
  }
}

// optional .SensorData lpg = 22;
inline bool MsgNode::has_lpg() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void MsgNode::set_has_lpg() {
  _has_bits_[0] |= 0x00200000u;
}
inline void MsgNode::clear_has_lpg() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void MsgNode::clear_lpg() {
  if (lpg_ != NULL) lpg_->::SensorData::Clear();
  clear_has_lpg();
}
inline const ::SensorData& MsgNode::lpg() const {
  return lpg_ != NULL ? *lpg_ : *default_instance_->lpg_;
}
inline ::SensorData* MsgNode::mutable_lpg() {
  set_has_lpg();
  if (lpg_ == NULL) lpg_ = new ::SensorData;
  return lpg_;
}
inline ::SensorData* MsgNode::release_lpg() {
  clear_has_lpg();
  ::SensorData* temp = lpg_;
  lpg_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_lpg(::SensorData* lpg) {
  delete lpg_;
  lpg_ = lpg;
  if (lpg) {
    set_has_lpg();
  } else {
    clear_has_lpg();
  }
}

// optional .SensorData o3 = 23;
inline bool MsgNode::has_o3() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void MsgNode::set_has_o3() {
  _has_bits_[0] |= 0x00400000u;
}
inline void MsgNode::clear_has_o3() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void MsgNode::clear_o3() {
  if (o3_ != NULL) o3_->::SensorData::Clear();
  clear_has_o3();
}
inline const ::SensorData& MsgNode::o3() const {
  return o3_ != NULL ? *o3_ : *default_instance_->o3_;
}
inline ::SensorData* MsgNode::mutable_o3() {
  set_has_o3();
  if (o3_ == NULL) o3_ = new ::SensorData;
  return o3_;
}
inline ::SensorData* MsgNode::release_o3() {
  clear_has_o3();
  ::SensorData* temp = o3_;
  o3_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_o3(::SensorData* o3) {
  delete o3_;
  o3_ = o3;
  if (o3) {
    set_has_o3();
  } else {
    clear_has_o3();
  }
}

// optional .SensorData pm1 = 24;
inline bool MsgNode::has_pm1() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void MsgNode::set_has_pm1() {
  _has_bits_[0] |= 0x00800000u;
}
inline void MsgNode::clear_has_pm1() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void MsgNode::clear_pm1() {
  if (pm1_ != NULL) pm1_->::SensorData::Clear();
  clear_has_pm1();
}
inline const ::SensorData& MsgNode::pm1() const {
  return pm1_ != NULL ? *pm1_ : *default_instance_->pm1_;
}
inline ::SensorData* MsgNode::mutable_pm1() {
  set_has_pm1();
  if (pm1_ == NULL) pm1_ = new ::SensorData;
  return pm1_;
}
inline ::SensorData* MsgNode::release_pm1() {
  clear_has_pm1();
  ::SensorData* temp = pm1_;
  pm1_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_pm1(::SensorData* pm1) {
  delete pm1_;
  pm1_ = pm1;
  if (pm1) {
    set_has_pm1();
  } else {
    clear_has_pm1();
  }
}

// optional .SensorData pm2_5 = 25;
inline bool MsgNode::has_pm2_5() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void MsgNode::set_has_pm2_5() {
  _has_bits_[0] |= 0x01000000u;
}
inline void MsgNode::clear_has_pm2_5() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void MsgNode::clear_pm2_5() {
  if (pm2_5_ != NULL) pm2_5_->::SensorData::Clear();
  clear_has_pm2_5();
}
inline const ::SensorData& MsgNode::pm2_5() const {
  return pm2_5_ != NULL ? *pm2_5_ : *default_instance_->pm2_5_;
}
inline ::SensorData* MsgNode::mutable_pm2_5() {
  set_has_pm2_5();
  if (pm2_5_ == NULL) pm2_5_ = new ::SensorData;
  return pm2_5_;
}
inline ::SensorData* MsgNode::release_pm2_5() {
  clear_has_pm2_5();
  ::SensorData* temp = pm2_5_;
  pm2_5_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_pm2_5(::SensorData* pm2_5) {
  delete pm2_5_;
  pm2_5_ = pm2_5;
  if (pm2_5) {
    set_has_pm2_5();
  } else {
    clear_has_pm2_5();
  }
}

// optional .SensorData pm10 = 26;
inline bool MsgNode::has_pm10() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void MsgNode::set_has_pm10() {
  _has_bits_[0] |= 0x02000000u;
}
inline void MsgNode::clear_has_pm10() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void MsgNode::clear_pm10() {
  if (pm10_ != NULL) pm10_->::SensorData::Clear();
  clear_has_pm10();
}
inline const ::SensorData& MsgNode::pm10() const {
  return pm10_ != NULL ? *pm10_ : *default_instance_->pm10_;
}
inline ::SensorData* MsgNode::mutable_pm10() {
  set_has_pm10();
  if (pm10_ == NULL) pm10_ = new ::SensorData;
  return pm10_;
}
inline ::SensorData* MsgNode::release_pm10() {
  clear_has_pm10();
  ::SensorData* temp = pm10_;
  pm10_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_pm10(::SensorData* pm10) {
  delete pm10_;
  pm10_ = pm10;
  if (pm10) {
    set_has_pm10();
  } else {
    clear_has_pm10();
  }
}

// optional .SensorData angle = 27;
inline bool MsgNode::has_angle() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void MsgNode::set_has_angle() {
  _has_bits_[0] |= 0x04000000u;
}
inline void MsgNode::clear_has_angle() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void MsgNode::clear_angle() {
  if (angle_ != NULL) angle_->::SensorData::Clear();
  clear_has_angle();
}
inline const ::SensorData& MsgNode::angle() const {
  return angle_ != NULL ? *angle_ : *default_instance_->angle_;
}
inline ::SensorData* MsgNode::mutable_angle() {
  set_has_angle();
  if (angle_ == NULL) angle_ = new ::SensorData;
  return angle_;
}
inline ::SensorData* MsgNode::release_angle() {
  clear_has_angle();
  ::SensorData* temp = angle_;
  angle_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_angle(::SensorData* angle) {
  delete angle_;
  angle_ = angle;
  if (angle) {
    set_has_angle();
  } else {
    clear_has_angle();
  }
}

// optional .SensorData cover = 28;
inline bool MsgNode::has_cover() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void MsgNode::set_has_cover() {
  _has_bits_[0] |= 0x08000000u;
}
inline void MsgNode::clear_has_cover() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void MsgNode::clear_cover() {
  if (cover_ != NULL) cover_->::SensorData::Clear();
  clear_has_cover();
}
inline const ::SensorData& MsgNode::cover() const {
  return cover_ != NULL ? *cover_ : *default_instance_->cover_;
}
inline ::SensorData* MsgNode::mutable_cover() {
  set_has_cover();
  if (cover_ == NULL) cover_ = new ::SensorData;
  return cover_;
}
inline ::SensorData* MsgNode::release_cover() {
  clear_has_cover();
  ::SensorData* temp = cover_;
  cover_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_cover(::SensorData* cover) {
  delete cover_;
  cover_ = cover;
  if (cover) {
    set_has_cover();
  } else {
    clear_has_cover();
  }
}

// optional .SensorData level = 29;
inline bool MsgNode::has_level() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void MsgNode::set_has_level() {
  _has_bits_[0] |= 0x10000000u;
}
inline void MsgNode::clear_has_level() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void MsgNode::clear_level() {
  if (level_ != NULL) level_->::SensorData::Clear();
  clear_has_level();
}
inline const ::SensorData& MsgNode::level() const {
  return level_ != NULL ? *level_ : *default_instance_->level_;
}
inline ::SensorData* MsgNode::mutable_level() {
  set_has_level();
  if (level_ == NULL) level_ = new ::SensorData;
  return level_;
}
inline ::SensorData* MsgNode::release_level() {
  clear_has_level();
  ::SensorData* temp = level_;
  level_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_level(::SensorData* level) {
  delete level_;
  level_ = level;
  if (level) {
    set_has_level();
  } else {
    clear_has_level();
  }
}

// optional .SensorData smoke = 30;
inline bool MsgNode::has_smoke() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void MsgNode::set_has_smoke() {
  _has_bits_[0] |= 0x20000000u;
}
inline void MsgNode::clear_has_smoke() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void MsgNode::clear_smoke() {
  if (smoke_ != NULL) smoke_->::SensorData::Clear();
  clear_has_smoke();
}
inline const ::SensorData& MsgNode::smoke() const {
  return smoke_ != NULL ? *smoke_ : *default_instance_->smoke_;
}
inline ::SensorData* MsgNode::mutable_smoke() {
  set_has_smoke();
  if (smoke_ == NULL) smoke_ = new ::SensorData;
  return smoke_;
}
inline ::SensorData* MsgNode::release_smoke() {
  clear_has_smoke();
  ::SensorData* temp = smoke_;
  smoke_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_smoke(::SensorData* smoke) {
  delete smoke_;
  smoke_ = smoke;
  if (smoke) {
    set_has_smoke();
  } else {
    clear_has_smoke();
  }
}

// optional .SensorData pitch = 31;
inline bool MsgNode::has_pitch() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void MsgNode::set_has_pitch() {
  _has_bits_[0] |= 0x40000000u;
}
inline void MsgNode::clear_has_pitch() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void MsgNode::clear_pitch() {
  if (pitch_ != NULL) pitch_->::SensorData::Clear();
  clear_has_pitch();
}
inline const ::SensorData& MsgNode::pitch() const {
  return pitch_ != NULL ? *pitch_ : *default_instance_->pitch_;
}
inline ::SensorData* MsgNode::mutable_pitch() {
  set_has_pitch();
  if (pitch_ == NULL) pitch_ = new ::SensorData;
  return pitch_;
}
inline ::SensorData* MsgNode::release_pitch() {
  clear_has_pitch();
  ::SensorData* temp = pitch_;
  pitch_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_pitch(::SensorData* pitch) {
  delete pitch_;
  pitch_ = pitch;
  if (pitch) {
    set_has_pitch();
  } else {
    clear_has_pitch();
  }
}

// optional .SensorData roll = 32;
inline bool MsgNode::has_roll() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void MsgNode::set_has_roll() {
  _has_bits_[0] |= 0x80000000u;
}
inline void MsgNode::clear_has_roll() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void MsgNode::clear_roll() {
  if (roll_ != NULL) roll_->::SensorData::Clear();
  clear_has_roll();
}
inline const ::SensorData& MsgNode::roll() const {
  return roll_ != NULL ? *roll_ : *default_instance_->roll_;
}
inline ::SensorData* MsgNode::mutable_roll() {
  set_has_roll();
  if (roll_ == NULL) roll_ = new ::SensorData;
  return roll_;
}
inline ::SensorData* MsgNode::release_roll() {
  clear_has_roll();
  ::SensorData* temp = roll_;
  roll_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_roll(::SensorData* roll) {
  delete roll_;
  roll_ = roll;
  if (roll) {
    set_has_roll();
  } else {
    clear_has_roll();
  }
}

// optional .SensorData yaw = 33;
inline bool MsgNode::has_yaw() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void MsgNode::set_has_yaw() {
  _has_bits_[1] |= 0x00000001u;
}
inline void MsgNode::clear_has_yaw() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void MsgNode::clear_yaw() {
  if (yaw_ != NULL) yaw_->::SensorData::Clear();
  clear_has_yaw();
}
inline const ::SensorData& MsgNode::yaw() const {
  return yaw_ != NULL ? *yaw_ : *default_instance_->yaw_;
}
inline ::SensorData* MsgNode::mutable_yaw() {
  set_has_yaw();
  if (yaw_ == NULL) yaw_ = new ::SensorData;
  return yaw_;
}
inline ::SensorData* MsgNode::release_yaw() {
  clear_has_yaw();
  ::SensorData* temp = yaw_;
  yaw_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_yaw(::SensorData* yaw) {
  delete yaw_;
  yaw_ = yaw;
  if (yaw) {
    set_has_yaw();
  } else {
    clear_has_yaw();
  }
}

// optional .SensorDataInt flame = 34;
inline bool MsgNode::has_flame() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void MsgNode::set_has_flame() {
  _has_bits_[1] |= 0x00000002u;
}
inline void MsgNode::clear_has_flame() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void MsgNode::clear_flame() {
  if (flame_ != NULL) flame_->::SensorDataInt::Clear();
  clear_has_flame();
}
inline const ::SensorDataInt& MsgNode::flame() const {
  return flame_ != NULL ? *flame_ : *default_instance_->flame_;
}
inline ::SensorDataInt* MsgNode::mutable_flame() {
  set_has_flame();
  if (flame_ == NULL) flame_ = new ::SensorDataInt;
  return flame_;
}
inline ::SensorDataInt* MsgNode::release_flame() {
  clear_has_flame();
  ::SensorDataInt* temp = flame_;
  flame_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_flame(::SensorDataInt* flame) {
  delete flame_;
  flame_ = flame;
  if (flame) {
    set_has_flame();
  } else {
    clear_has_flame();
  }
}

// optional .SensorData artificialGas = 35;
inline bool MsgNode::has_artificialgas() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void MsgNode::set_has_artificialgas() {
  _has_bits_[1] |= 0x00000004u;
}
inline void MsgNode::clear_has_artificialgas() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void MsgNode::clear_artificialgas() {
  if (artificialgas_ != NULL) artificialgas_->::SensorData::Clear();
  clear_has_artificialgas();
}
inline const ::SensorData& MsgNode::artificialgas() const {
  return artificialgas_ != NULL ? *artificialgas_ : *default_instance_->artificialgas_;
}
inline ::SensorData* MsgNode::mutable_artificialgas() {
  set_has_artificialgas();
  if (artificialgas_ == NULL) artificialgas_ = new ::SensorData;
  return artificialgas_;
}
inline ::SensorData* MsgNode::release_artificialgas() {
  clear_has_artificialgas();
  ::SensorData* temp = artificialgas_;
  artificialgas_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_artificialgas(::SensorData* artificialgas) {
  delete artificialgas_;
  artificialgas_ = artificialgas;
  if (artificialgas) {
    set_has_artificialgas();
  } else {
    clear_has_artificialgas();
  }
}

// optional .MultiSensorDataInt multiTemp = 36;
inline bool MsgNode::has_multitemp() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void MsgNode::set_has_multitemp() {
  _has_bits_[1] |= 0x00000008u;
}
inline void MsgNode::clear_has_multitemp() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void MsgNode::clear_multitemp() {
  if (multitemp_ != NULL) multitemp_->::MultiSensorDataInt::Clear();
  clear_has_multitemp();
}
inline const ::MultiSensorDataInt& MsgNode::multitemp() const {
  return multitemp_ != NULL ? *multitemp_ : *default_instance_->multitemp_;
}
inline ::MultiSensorDataInt* MsgNode::mutable_multitemp() {
  set_has_multitemp();
  if (multitemp_ == NULL) multitemp_ = new ::MultiSensorDataInt;
  return multitemp_;
}
inline ::MultiSensorDataInt* MsgNode::release_multitemp() {
  clear_has_multitemp();
  ::MultiSensorDataInt* temp = multitemp_;
  multitemp_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_multitemp(::MultiSensorDataInt* multitemp) {
  delete multitemp_;
  multitemp_ = multitemp;
  if (multitemp) {
    set_has_multitemp();
  } else {
    clear_has_multitemp();
  }
}

// optional .SensorData waterPressure = 37;
inline bool MsgNode::has_waterpressure() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void MsgNode::set_has_waterpressure() {
  _has_bits_[1] |= 0x00000010u;
}
inline void MsgNode::clear_has_waterpressure() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void MsgNode::clear_waterpressure() {
  if (waterpressure_ != NULL) waterpressure_->::SensorData::Clear();
  clear_has_waterpressure();
}
inline const ::SensorData& MsgNode::waterpressure() const {
  return waterpressure_ != NULL ? *waterpressure_ : *default_instance_->waterpressure_;
}
inline ::SensorData* MsgNode::mutable_waterpressure() {
  set_has_waterpressure();
  if (waterpressure_ == NULL) waterpressure_ = new ::SensorData;
  return waterpressure_;
}
inline ::SensorData* MsgNode::release_waterpressure() {
  clear_has_waterpressure();
  ::SensorData* temp = waterpressure_;
  waterpressure_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_waterpressure(::SensorData* waterpressure) {
  delete waterpressure_;
  waterpressure_ = waterpressure;
  if (waterpressure) {
    set_has_waterpressure();
  } else {
    clear_has_waterpressure();
  }
}

// optional .iBeacon ibeacon = 38;
inline bool MsgNode::has_ibeacon() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void MsgNode::set_has_ibeacon() {
  _has_bits_[1] |= 0x00000020u;
}
inline void MsgNode::clear_has_ibeacon() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void MsgNode::clear_ibeacon() {
  if (ibeacon_ != NULL) ibeacon_->::iBeacon::Clear();
  clear_has_ibeacon();
}
inline const ::iBeacon& MsgNode::ibeacon() const {
  return ibeacon_ != NULL ? *ibeacon_ : *default_instance_->ibeacon_;
}
inline ::iBeacon* MsgNode::mutable_ibeacon() {
  set_has_ibeacon();
  if (ibeacon_ == NULL) ibeacon_ = new ::iBeacon;
  return ibeacon_;
}
inline ::iBeacon* MsgNode::release_ibeacon() {
  clear_has_ibeacon();
  ::iBeacon* temp = ibeacon_;
  ibeacon_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_ibeacon(::iBeacon* ibeacon) {
  delete ibeacon_;
  ibeacon_ = ibeacon;
  if (ibeacon) {
    set_has_ibeacon();
  } else {
    clear_has_ibeacon();
  }
}

// repeated .SensorData sensors = 39;
inline int MsgNode::sensors_size() const {
  return sensors_.size();
}
inline void MsgNode::clear_sensors() {
  sensors_.Clear();
}
inline const ::SensorData& MsgNode::sensors(int index) const {
  return sensors_.Get(index);
}
inline ::SensorData* MsgNode::mutable_sensors(int index) {
  return sensors_.Mutable(index);
}
inline ::SensorData* MsgNode::add_sensors() {
  return sensors_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SensorData >&
MsgNode::sensors() const {
  return sensors_;
}
inline ::google::protobuf::RepeatedPtrField< ::SensorData >*
MsgNode::mutable_sensors() {
  return &sensors_;
}

// optional bool installed = 40;
inline bool MsgNode::has_installed() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void MsgNode::set_has_installed() {
  _has_bits_[1] |= 0x00000080u;
}
inline void MsgNode::clear_has_installed() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void MsgNode::clear_installed() {
  installed_ = false;
  clear_has_installed();
}
inline bool MsgNode::installed() const {
  return installed_;
}
inline void MsgNode::set_installed(bool value) {
  set_has_installed();
  installed_ = value;
}

// optional .ExtSmoke extSmoke = 41;
inline bool MsgNode::has_extsmoke() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void MsgNode::set_has_extsmoke() {
  _has_bits_[1] |= 0x00000100u;
}
inline void MsgNode::clear_has_extsmoke() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void MsgNode::clear_extsmoke() {
  if (extsmoke_ != NULL) extsmoke_->::ExtSmoke::Clear();
  clear_has_extsmoke();
}
inline const ::ExtSmoke& MsgNode::extsmoke() const {
  return extsmoke_ != NULL ? *extsmoke_ : *default_instance_->extsmoke_;
}
inline ::ExtSmoke* MsgNode::mutable_extsmoke() {
  set_has_extsmoke();
  if (extsmoke_ == NULL) extsmoke_ = new ::ExtSmoke;
  return extsmoke_;
}
inline ::ExtSmoke* MsgNode::release_extsmoke() {
  clear_has_extsmoke();
  ::ExtSmoke* temp = extsmoke_;
  extsmoke_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_extsmoke(::ExtSmoke* extsmoke) {
  delete extsmoke_;
  extsmoke_ = extsmoke;
  if (extsmoke) {
    set_has_extsmoke();
  } else {
    clear_has_extsmoke();
  }
}

// optional .ElecFireData fireData = 42;
inline bool MsgNode::has_firedata() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void MsgNode::set_has_firedata() {
  _has_bits_[1] |= 0x00000200u;
}
inline void MsgNode::clear_has_firedata() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void MsgNode::clear_firedata() {
  if (firedata_ != NULL) firedata_->::ElecFireData::Clear();
  clear_has_firedata();
}
inline const ::ElecFireData& MsgNode::firedata() const {
  return firedata_ != NULL ? *firedata_ : *default_instance_->firedata_;
}
inline ::ElecFireData* MsgNode::mutable_firedata() {
  set_has_firedata();
  if (firedata_ == NULL) firedata_ = new ::ElecFireData;
  return firedata_;
}
inline ::ElecFireData* MsgNode::release_firedata() {
  clear_has_firedata();
  ::ElecFireData* temp = firedata_;
  firedata_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_firedata(::ElecFireData* firedata) {
  delete firedata_;
  firedata_ = firedata;
  if (firedata) {
    set_has_firedata();
  } else {
    clear_has_firedata();
  }
}

// optional .MantunData mtunData = 43;
inline bool MsgNode::has_mtundata() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void MsgNode::set_has_mtundata() {
  _has_bits_[1] |= 0x00000400u;
}
inline void MsgNode::clear_has_mtundata() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void MsgNode::clear_mtundata() {
  if (mtundata_ != NULL) mtundata_->::MantunData::Clear();
  clear_has_mtundata();
}
inline const ::MantunData& MsgNode::mtundata() const {
  return mtundata_ != NULL ? *mtundata_ : *default_instance_->mtundata_;
}
inline ::MantunData* MsgNode::mutable_mtundata() {
  set_has_mtundata();
  if (mtundata_ == NULL) mtundata_ = new ::MantunData;
  return mtundata_;
}
inline ::MantunData* MsgNode::release_mtundata() {
  clear_has_mtundata();
  ::MantunData* temp = mtundata_;
  mtundata_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_mtundata(::MantunData* mtundata) {
  delete mtundata_;
  mtundata_ = mtundata;
  if (mtundata) {
    set_has_mtundata();
  } else {
    clear_has_mtundata();
  }
}

// optional .AcrelData acrelData = 44;
inline bool MsgNode::has_acreldata() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void MsgNode::set_has_acreldata() {
  _has_bits_[1] |= 0x00000800u;
}
inline void MsgNode::clear_has_acreldata() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void MsgNode::clear_acreldata() {
  if (acreldata_ != NULL) acreldata_->::AcrelData::Clear();
  clear_has_acreldata();
}
inline const ::AcrelData& MsgNode::acreldata() const {
  return acreldata_ != NULL ? *acreldata_ : *default_instance_->acreldata_;
}
inline ::AcrelData* MsgNode::mutable_acreldata() {
  set_has_acreldata();
  if (acreldata_ == NULL) acreldata_ = new ::AcrelData;
  return acreldata_;
}
inline ::AcrelData* MsgNode::release_acreldata() {
  clear_has_acreldata();
  ::AcrelData* temp = acreldata_;
  acreldata_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_acreldata(::AcrelData* acreldata) {
  delete acreldata_;
  acreldata_ = acreldata;
  if (acreldata) {
    set_has_acreldata();
  } else {
    clear_has_acreldata();
  }
}

// optional .Cayman caymanData = 45;
inline bool MsgNode::has_caymandata() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void MsgNode::set_has_caymandata() {
  _has_bits_[1] |= 0x00001000u;
}
inline void MsgNode::clear_has_caymandata() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void MsgNode::clear_caymandata() {
  if (caymandata_ != NULL) caymandata_->::Cayman::Clear();
  clear_has_caymandata();
}
inline const ::Cayman& MsgNode::caymandata() const {
  return caymandata_ != NULL ? *caymandata_ : *default_instance_->caymandata_;
}
inline ::Cayman* MsgNode::mutable_caymandata() {
  set_has_caymandata();
  if (caymandata_ == NULL) caymandata_ = new ::Cayman;
  return caymandata_;
}
inline ::Cayman* MsgNode::release_caymandata() {
  clear_has_caymandata();
  ::Cayman* temp = caymandata_;
  caymandata_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_caymandata(::Cayman* caymandata) {
  delete caymandata_;
  caymandata_ = caymandata;
  if (caymandata) {
    set_has_caymandata();
  } else {
    clear_has_caymandata();
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Activtion>() {
  return ::Activtion_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ClassType>() {
  return ::ClassType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SensorError>() {
  return ::SensorError_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SensorType>() {
  return ::SensorType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SensorStatus>() {
  return ::SensorStatus_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AppCmd>() {
  return ::AppCmd_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NodeState>() {
  return ::NodeState_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NodeAlarm>() {
  return ::NodeAlarm_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SmokeCtrl>() {
  return ::SmokeCtrl_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TrackerCtrl>() {
  return ::TrackerCtrl_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_MsgNode_5f1v1_5fm13_2eproto__INCLUDED
