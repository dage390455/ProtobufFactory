// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MsgNode_1v1_m8.proto

#ifndef PROTOBUF_MsgNode_5f1v1_5fm8_2eproto__INCLUDED
#define PROTOBUF_MsgNode_5f1v1_5fm8_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_MsgNode_5f1v1_5fm8_2eproto();
void protobuf_AssignDesc_MsgNode_5f1v1_5fm8_2eproto();
void protobuf_ShutdownFile_MsgNode_5f1v1_5fm8_2eproto();

class LoraParam;
class BleParam;
class SensorData;
class SensorDataInt;
class SensorDataFloat;
class MultiSensorData;
class MultiSensorDataInt;
class GpsData;
class AxisData;
class iBeacon;
class AppParam;
class MsgNode;

enum Activtion {
  ABP = 0,
  OTA = 1
};
bool Activtion_IsValid(int value);
const Activtion Activtion_MIN = ABP;
const Activtion Activtion_MAX = OTA;
const int Activtion_ARRAYSIZE = Activtion_MAX + 1;

const ::google::protobuf::EnumDescriptor* Activtion_descriptor();
inline const ::std::string& Activtion_Name(Activtion value) {
  return ::google::protobuf::internal::NameOfEnum(
    Activtion_descriptor(), value);
}
inline bool Activtion_Parse(
    const ::std::string& name, Activtion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Activtion>(
    Activtion_descriptor(), name, value);
}
enum ClassType {
  CLASS_A = 0,
  CLASS_B = 1,
  CLASS_C = 2
};
bool ClassType_IsValid(int value);
const ClassType ClassType_MIN = CLASS_A;
const ClassType ClassType_MAX = CLASS_C;
const int ClassType_ARRAYSIZE = ClassType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ClassType_descriptor();
inline const ::std::string& ClassType_Name(ClassType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ClassType_descriptor(), value);
}
inline bool ClassType_Parse(
    const ::std::string& name, ClassType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ClassType>(
    ClassType_descriptor(), name, value);
}
enum SensorError {
  SENSOR_ERR_NONE = 0,
  SENSOR_ERR_NO_DATA = 1,
  SENSOR_ERR_CRC = 2,
  SENSOR_ERR_DATA = 3,
  SENSOR_ERR_FAULT = 4,
  SENSOR_ERR_ALARM = 5,
  SENSOR_ERR_ALARM_HIGH = 6,
  SENSOR_ERR_ALARM_LOW = 7,
  SENSOR_ERR_UNKNOWN = 127
};
bool SensorError_IsValid(int value);
const SensorError SensorError_MIN = SENSOR_ERR_NONE;
const SensorError SensorError_MAX = SENSOR_ERR_UNKNOWN;
const int SensorError_ARRAYSIZE = SensorError_MAX + 1;

const ::google::protobuf::EnumDescriptor* SensorError_descriptor();
inline const ::std::string& SensorError_Name(SensorError value) {
  return ::google::protobuf::internal::NameOfEnum(
    SensorError_descriptor(), value);
}
inline bool SensorError_Parse(
    const ::std::string& name, SensorError* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SensorError>(
    SensorError_descriptor(), name, value);
}
enum SensorType {
  SENSOR_TYPE_TEMP = 0,
  SENSOR_TYPE_HUMI = 1,
  SENSOR_TYPE_LIGHT = 2,
  SENSOR_TYPE_GPS = 3,
  SENSOR_TYPE_ANGLE = 4,
  SENSOR_TYPE_PM2_5 = 5,
  SENSOR_TYPE_PM10 = 6,
  SENSOR_TYPE_LEAK = 7,
  SENSOR_TYPE_CO = 8,
  SENSOR_TYPE_CO2 = 9,
  SENSOR_TYPE_NO2 = 10,
  SENSOR_TYPE_CH4 = 11,
  SENSOR_TYPE_LPG = 12,
  SENSOR_TYPE_FLAME = 13,
  SENSOR_TYPE_ARTIFICIAL_GAS = 14,
  SENSOR_TYPE_WATER_GAGE = 15,
  SENSOR_TYPE_TRACKER = 16
};
bool SensorType_IsValid(int value);
const SensorType SensorType_MIN = SENSOR_TYPE_TEMP;
const SensorType SensorType_MAX = SENSOR_TYPE_TRACKER;
const int SensorType_ARRAYSIZE = SensorType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SensorType_descriptor();
inline const ::std::string& SensorType_Name(SensorType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SensorType_descriptor(), value);
}
inline bool SensorType_Parse(
    const ::std::string& name, SensorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SensorType>(
    SensorType_descriptor(), name, value);
}
enum SensorStatus {
  SENSORO_STATUS_NONE = 0,
  SENSORO_STATUS_SELF_INSPECTION = 1,
  SENSORO_STATUS_ALARM = 2
};
bool SensorStatus_IsValid(int value);
const SensorStatus SensorStatus_MIN = SENSORO_STATUS_NONE;
const SensorStatus SensorStatus_MAX = SENSORO_STATUS_ALARM;
const int SensorStatus_ARRAYSIZE = SensorStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* SensorStatus_descriptor();
inline const ::std::string& SensorStatus_Name(SensorStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    SensorStatus_descriptor(), value);
}
inline bool SensorStatus_Parse(
    const ::std::string& name, SensorStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SensorStatus>(
    SensorStatus_descriptor(), name, value);
}
enum AppCmd {
  APP_CMD_NONE = 0,
  APP_CMD_RESET = 1,
  APP_CMD_FAC_RESET = 2,
  APP_CMD_DFU = 3
};
bool AppCmd_IsValid(int value);
const AppCmd AppCmd_MIN = APP_CMD_NONE;
const AppCmd AppCmd_MAX = APP_CMD_DFU;
const int AppCmd_ARRAYSIZE = AppCmd_MAX + 1;

const ::google::protobuf::EnumDescriptor* AppCmd_descriptor();
inline const ::std::string& AppCmd_Name(AppCmd value) {
  return ::google::protobuf::internal::NameOfEnum(
    AppCmd_descriptor(), value);
}
inline bool AppCmd_Parse(
    const ::std::string& name, AppCmd* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AppCmd>(
    AppCmd_descriptor(), name, value);
}
enum NodeState {
  NODE_STATE_UNKNOWN = 0,
  NODE_STATE_STATIC = 1,
  NODE_STATE_MOVE = 2
};
bool NodeState_IsValid(int value);
const NodeState NodeState_MIN = NODE_STATE_UNKNOWN;
const NodeState NodeState_MAX = NODE_STATE_MOVE;
const int NodeState_ARRAYSIZE = NodeState_MAX + 1;

const ::google::protobuf::EnumDescriptor* NodeState_descriptor();
inline const ::std::string& NodeState_Name(NodeState value) {
  return ::google::protobuf::internal::NameOfEnum(
    NodeState_descriptor(), value);
}
inline bool NodeState_Parse(
    const ::std::string& name, NodeState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NodeState>(
    NodeState_descriptor(), name, value);
}
enum NodeAlarm {
  NODE_ALARM_NONE = 0,
  NODE_ALARM_STATIC = 1,
  NODE_ALARM_MOVE = 2,
  NODE_ALARM_COLLISION = 3,
  NODE_ALARM_ROLL = 4,
  NODE_ALARM_INVERTED = 5,
  NODE_ALARM_FALL = 6
};
bool NodeAlarm_IsValid(int value);
const NodeAlarm NodeAlarm_MIN = NODE_ALARM_NONE;
const NodeAlarm NodeAlarm_MAX = NODE_ALARM_FALL;
const int NodeAlarm_ARRAYSIZE = NodeAlarm_MAX + 1;

const ::google::protobuf::EnumDescriptor* NodeAlarm_descriptor();
inline const ::std::string& NodeAlarm_Name(NodeAlarm value) {
  return ::google::protobuf::internal::NameOfEnum(
    NodeAlarm_descriptor(), value);
}
inline bool NodeAlarm_Parse(
    const ::std::string& name, NodeAlarm* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NodeAlarm>(
    NodeAlarm_descriptor(), name, value);
}
enum SmokeCtrl {
  SMOKE_CTRL_NONE = 0,
  SMOKE_ERASURE = 1,
  SMOKE_INSPECTION_TEST = 2,
  SMOKE_INSPECTION_OVER = 3
};
bool SmokeCtrl_IsValid(int value);
const SmokeCtrl SmokeCtrl_MIN = SMOKE_CTRL_NONE;
const SmokeCtrl SmokeCtrl_MAX = SMOKE_INSPECTION_OVER;
const int SmokeCtrl_ARRAYSIZE = SmokeCtrl_MAX + 1;

const ::google::protobuf::EnumDescriptor* SmokeCtrl_descriptor();
inline const ::std::string& SmokeCtrl_Name(SmokeCtrl value) {
  return ::google::protobuf::internal::NameOfEnum(
    SmokeCtrl_descriptor(), value);
}
inline bool SmokeCtrl_Parse(
    const ::std::string& name, SmokeCtrl* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SmokeCtrl>(
    SmokeCtrl_descriptor(), name, value);
}
enum TrackerCtrl {
  TRACKER_Ctrl = 0,
  TRACKER_BOOT = 1,
  TRACKER_SHUTDOWN = 2,
  TRACKER_CALL_START = 3,
  TRACKER_CALL_END = 4,
  TRACKER_EMERGENCE_START = 5,
  TRACKER_EMERGENCE_END = 6
};
bool TrackerCtrl_IsValid(int value);
const TrackerCtrl TrackerCtrl_MIN = TRACKER_Ctrl;
const TrackerCtrl TrackerCtrl_MAX = TRACKER_EMERGENCE_END;
const int TrackerCtrl_ARRAYSIZE = TrackerCtrl_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrackerCtrl_descriptor();
inline const ::std::string& TrackerCtrl_Name(TrackerCtrl value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrackerCtrl_descriptor(), value);
}
inline bool TrackerCtrl_Parse(
    const ::std::string& name, TrackerCtrl* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrackerCtrl>(
    TrackerCtrl_descriptor(), name, value);
}
// ===================================================================

class LoraParam : public ::google::protobuf::Message {
 public:
  LoraParam();
  virtual ~LoraParam();

  LoraParam(const LoraParam& from);

  inline LoraParam& operator=(const LoraParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoraParam& default_instance();

  void Swap(LoraParam* other);

  // implements Message ----------------------------------------------

  LoraParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoraParam& from);
  void MergeFrom(const LoraParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes devEui = 1;
  inline bool has_deveui() const;
  inline void clear_deveui();
  static const int kDevEuiFieldNumber = 1;
  inline const ::std::string& deveui() const;
  inline void set_deveui(const ::std::string& value);
  inline void set_deveui(const char* value);
  inline void set_deveui(const void* value, size_t size);
  inline ::std::string* mutable_deveui();
  inline ::std::string* release_deveui();
  inline void set_allocated_deveui(::std::string* deveui);

  // optional bytes appEui = 2;
  inline bool has_appeui() const;
  inline void clear_appeui();
  static const int kAppEuiFieldNumber = 2;
  inline const ::std::string& appeui() const;
  inline void set_appeui(const ::std::string& value);
  inline void set_appeui(const char* value);
  inline void set_appeui(const void* value, size_t size);
  inline ::std::string* mutable_appeui();
  inline ::std::string* release_appeui();
  inline void set_allocated_appeui(::std::string* appeui);

  // optional bytes appKey = 3;
  inline bool has_appkey() const;
  inline void clear_appkey();
  static const int kAppKeyFieldNumber = 3;
  inline const ::std::string& appkey() const;
  inline void set_appkey(const ::std::string& value);
  inline void set_appkey(const char* value);
  inline void set_appkey(const void* value, size_t size);
  inline ::std::string* mutable_appkey();
  inline ::std::string* release_appkey();
  inline void set_allocated_appkey(::std::string* appkey);

  // optional bytes appSkey = 4;
  inline bool has_appskey() const;
  inline void clear_appskey();
  static const int kAppSkeyFieldNumber = 4;
  inline const ::std::string& appskey() const;
  inline void set_appskey(const ::std::string& value);
  inline void set_appskey(const char* value);
  inline void set_appskey(const void* value, size_t size);
  inline ::std::string* mutable_appskey();
  inline ::std::string* release_appskey();
  inline void set_allocated_appskey(::std::string* appskey);

  // optional bytes nwkSkey = 5;
  inline bool has_nwkskey() const;
  inline void clear_nwkskey();
  static const int kNwkSkeyFieldNumber = 5;
  inline const ::std::string& nwkskey() const;
  inline void set_nwkskey(const ::std::string& value);
  inline void set_nwkskey(const char* value);
  inline void set_nwkskey(const void* value, size_t size);
  inline ::std::string* mutable_nwkskey();
  inline ::std::string* release_nwkskey();
  inline void set_allocated_nwkskey(::std::string* nwkskey);

  // optional uint32 devAddr = 6;
  inline bool has_devaddr() const;
  inline void clear_devaddr();
  static const int kDevAddrFieldNumber = 6;
  inline ::google::protobuf::uint32 devaddr() const;
  inline void set_devaddr(::google::protobuf::uint32 value);

  // optional uint32 datarate = 7;
  inline bool has_datarate() const;
  inline void clear_datarate();
  static const int kDatarateFieldNumber = 7;
  inline ::google::protobuf::uint32 datarate() const;
  inline void set_datarate(::google::protobuf::uint32 value);

  // optional sint32 txPower = 8;
  inline bool has_txpower() const;
  inline void clear_txpower();
  static const int kTxPowerFieldNumber = 8;
  inline ::google::protobuf::int32 txpower() const;
  inline void set_txpower(::google::protobuf::int32 value);

  // optional uint32 adr = 9;
  inline bool has_adr() const;
  inline void clear_adr();
  static const int kAdrFieldNumber = 9;
  inline ::google::protobuf::uint32 adr() const;
  inline void set_adr(::google::protobuf::uint32 value);

  // optional .Activtion activition = 10;
  inline bool has_activition() const;
  inline void clear_activition();
  static const int kActivitionFieldNumber = 10;
  inline ::Activtion activition() const;
  inline void set_activition(::Activtion value);

  // optional .ClassType classType = 11;
  inline bool has_classtype() const;
  inline void clear_classtype();
  static const int kClassTypeFieldNumber = 11;
  inline ::ClassType classtype() const;
  inline void set_classtype(::ClassType value);

  // optional uint32 delay = 12;
  inline bool has_delay() const;
  inline void clear_delay();
  static const int kDelayFieldNumber = 12;
  inline ::google::protobuf::uint32 delay() const;
  inline void set_delay(::google::protobuf::uint32 value);

  // repeated uint32 channelMask = 13;
  inline int channelmask_size() const;
  inline void clear_channelmask();
  static const int kChannelMaskFieldNumber = 13;
  inline ::google::protobuf::uint32 channelmask(int index) const;
  inline void set_channelmask(int index, ::google::protobuf::uint32 value);
  inline void add_channelmask(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      channelmask() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_channelmask();

  // optional uint32 maxEIRP = 14;
  inline bool has_maxeirp() const;
  inline void clear_maxeirp();
  static const int kMaxEIRPFieldNumber = 14;
  inline ::google::protobuf::uint32 maxeirp() const;
  inline void set_maxeirp(::google::protobuf::uint32 value);

  // optional uint32 sglStatus = 15;
  inline bool has_sglstatus() const;
  inline void clear_sglstatus();
  static const int kSglStatusFieldNumber = 15;
  inline ::google::protobuf::uint32 sglstatus() const;
  inline void set_sglstatus(::google::protobuf::uint32 value);

  // optional uint32 sglFrequency = 16;
  inline bool has_sglfrequency() const;
  inline void clear_sglfrequency();
  static const int kSglFrequencyFieldNumber = 16;
  inline ::google::protobuf::uint32 sglfrequency() const;
  inline void set_sglfrequency(::google::protobuf::uint32 value);

  // optional uint32 sglDatarate = 17;
  inline bool has_sgldatarate() const;
  inline void clear_sgldatarate();
  static const int kSglDatarateFieldNumber = 17;
  inline ::google::protobuf::uint32 sgldatarate() const;
  inline void set_sgldatarate(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:LoraParam)
 private:
  inline void set_has_deveui();
  inline void clear_has_deveui();
  inline void set_has_appeui();
  inline void clear_has_appeui();
  inline void set_has_appkey();
  inline void clear_has_appkey();
  inline void set_has_appskey();
  inline void clear_has_appskey();
  inline void set_has_nwkskey();
  inline void clear_has_nwkskey();
  inline void set_has_devaddr();
  inline void clear_has_devaddr();
  inline void set_has_datarate();
  inline void clear_has_datarate();
  inline void set_has_txpower();
  inline void clear_has_txpower();
  inline void set_has_adr();
  inline void clear_has_adr();
  inline void set_has_activition();
  inline void clear_has_activition();
  inline void set_has_classtype();
  inline void clear_has_classtype();
  inline void set_has_delay();
  inline void clear_has_delay();
  inline void set_has_maxeirp();
  inline void clear_has_maxeirp();
  inline void set_has_sglstatus();
  inline void clear_has_sglstatus();
  inline void set_has_sglfrequency();
  inline void clear_has_sglfrequency();
  inline void set_has_sgldatarate();
  inline void clear_has_sgldatarate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* deveui_;
  ::std::string* appeui_;
  ::std::string* appkey_;
  ::std::string* appskey_;
  ::std::string* nwkskey_;
  ::google::protobuf::uint32 devaddr_;
  ::google::protobuf::uint32 datarate_;
  ::google::protobuf::int32 txpower_;
  ::google::protobuf::uint32 adr_;
  int activition_;
  int classtype_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > channelmask_;
  ::google::protobuf::uint32 delay_;
  ::google::protobuf::uint32 maxeirp_;
  ::google::protobuf::uint32 sglstatus_;
  ::google::protobuf::uint32 sglfrequency_;
  ::google::protobuf::uint32 sgldatarate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(17 + 31) / 32];

  friend void  protobuf_AddDesc_MsgNode_5f1v1_5fm8_2eproto();
  friend void protobuf_AssignDesc_MsgNode_5f1v1_5fm8_2eproto();
  friend void protobuf_ShutdownFile_MsgNode_5f1v1_5fm8_2eproto();

  void InitAsDefaultInstance();
  static LoraParam* default_instance_;
};
// -------------------------------------------------------------------

class BleParam : public ::google::protobuf::Message {
 public:
  BleParam();
  virtual ~BleParam();

  BleParam(const BleParam& from);

  inline BleParam& operator=(const BleParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BleParam& default_instance();

  void Swap(BleParam* other);

  // implements Message ----------------------------------------------

  BleParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BleParam& from);
  void MergeFrom(const BleParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float bleInterval = 1;
  inline bool has_bleinterval() const;
  inline void clear_bleinterval();
  static const int kBleIntervalFieldNumber = 1;
  inline float bleinterval() const;
  inline void set_bleinterval(float value);

  // optional sint32 bleTxp = 2;
  inline bool has_bletxp() const;
  inline void clear_bletxp();
  static const int kBleTxpFieldNumber = 2;
  inline ::google::protobuf::int32 bletxp() const;
  inline void set_bletxp(::google::protobuf::int32 value);

  // optional uint32 bleOnTime = 3;
  inline bool has_bleontime() const;
  inline void clear_bleontime();
  static const int kBleOnTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 bleontime() const;
  inline void set_bleontime(::google::protobuf::uint32 value);

  // optional uint32 bleOffTime = 4;
  inline bool has_bleofftime() const;
  inline void clear_bleofftime();
  static const int kBleOffTimeFieldNumber = 4;
  inline ::google::protobuf::uint32 bleofftime() const;
  inline void set_bleofftime(::google::protobuf::uint32 value);

  // optional uint32 bleOnOff = 5;
  inline bool has_bleonoff() const;
  inline void clear_bleonoff();
  static const int kBleOnOffFieldNumber = 5;
  inline ::google::protobuf::uint32 bleonoff() const;
  inline void set_bleonoff(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:BleParam)
 private:
  inline void set_has_bleinterval();
  inline void clear_has_bleinterval();
  inline void set_has_bletxp();
  inline void clear_has_bletxp();
  inline void set_has_bleontime();
  inline void clear_has_bleontime();
  inline void set_has_bleofftime();
  inline void clear_has_bleofftime();
  inline void set_has_bleonoff();
  inline void clear_has_bleonoff();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float bleinterval_;
  ::google::protobuf::int32 bletxp_;
  ::google::protobuf::uint32 bleontime_;
  ::google::protobuf::uint32 bleofftime_;
  ::google::protobuf::uint32 bleonoff_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_MsgNode_5f1v1_5fm8_2eproto();
  friend void protobuf_AssignDesc_MsgNode_5f1v1_5fm8_2eproto();
  friend void protobuf_ShutdownFile_MsgNode_5f1v1_5fm8_2eproto();

  void InitAsDefaultInstance();
  static BleParam* default_instance_;
};
// -------------------------------------------------------------------

class SensorData : public ::google::protobuf::Message {
 public:
  SensorData();
  virtual ~SensorData();

  SensorData(const SensorData& from);

  inline SensorData& operator=(const SensorData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SensorData& default_instance();

  void Swap(SensorData* other);

  // implements Message ----------------------------------------------

  SensorData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SensorData& from);
  void MergeFrom(const SensorData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float data = 1;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline float data() const;
  inline void set_data(float value);

  // optional float alarmHigh = 2;
  inline bool has_alarmhigh() const;
  inline void clear_alarmhigh();
  static const int kAlarmHighFieldNumber = 2;
  inline float alarmhigh() const;
  inline void set_alarmhigh(float value);

  // optional float alarmLow = 3;
  inline bool has_alarmlow() const;
  inline void clear_alarmlow();
  static const int kAlarmLowFieldNumber = 3;
  inline float alarmlow() const;
  inline void set_alarmlow(float value);

  // optional uint32 calibration = 4;
  inline bool has_calibration() const;
  inline void clear_calibration();
  static const int kCalibrationFieldNumber = 4;
  inline ::google::protobuf::uint32 calibration() const;
  inline void set_calibration(::google::protobuf::uint32 value);

  // optional .SensorError error = 5;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 5;
  inline ::SensorError error() const;
  inline void set_error(::SensorError value);

  // optional uint32 status = 6;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 6;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // optional float alarmStepHigh = 7;
  inline bool has_alarmstephigh() const;
  inline void clear_alarmstephigh();
  static const int kAlarmStepHighFieldNumber = 7;
  inline float alarmstephigh() const;
  inline void set_alarmstephigh(float value);

  // optional float alarmStepLow = 8;
  inline bool has_alarmsteplow() const;
  inline void clear_alarmsteplow();
  static const int kAlarmStepLowFieldNumber = 8;
  inline float alarmsteplow() const;
  inline void set_alarmsteplow(float value);

  // @@protoc_insertion_point(class_scope:SensorData)
 private:
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_alarmhigh();
  inline void clear_has_alarmhigh();
  inline void set_has_alarmlow();
  inline void clear_has_alarmlow();
  inline void set_has_calibration();
  inline void clear_has_calibration();
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_alarmstephigh();
  inline void clear_has_alarmstephigh();
  inline void set_has_alarmsteplow();
  inline void clear_has_alarmsteplow();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float data_;
  float alarmhigh_;
  float alarmlow_;
  ::google::protobuf::uint32 calibration_;
  int error_;
  ::google::protobuf::uint32 status_;
  float alarmstephigh_;
  float alarmsteplow_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_MsgNode_5f1v1_5fm8_2eproto();
  friend void protobuf_AssignDesc_MsgNode_5f1v1_5fm8_2eproto();
  friend void protobuf_ShutdownFile_MsgNode_5f1v1_5fm8_2eproto();

  void InitAsDefaultInstance();
  static SensorData* default_instance_;
};
// -------------------------------------------------------------------

class SensorDataInt : public ::google::protobuf::Message {
 public:
  SensorDataInt();
  virtual ~SensorDataInt();

  SensorDataInt(const SensorDataInt& from);

  inline SensorDataInt& operator=(const SensorDataInt& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SensorDataInt& default_instance();

  void Swap(SensorDataInt* other);

  // implements Message ----------------------------------------------

  SensorDataInt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SensorDataInt& from);
  void MergeFrom(const SensorDataInt& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SensorType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::SensorType type() const;
  inline void set_type(::SensorType value);

  // optional sint32 data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline ::google::protobuf::int32 data() const;
  inline void set_data(::google::protobuf::int32 value);

  // optional sint32 alarmHigh = 3;
  inline bool has_alarmhigh() const;
  inline void clear_alarmhigh();
  static const int kAlarmHighFieldNumber = 3;
  inline ::google::protobuf::int32 alarmhigh() const;
  inline void set_alarmhigh(::google::protobuf::int32 value);

  // optional sint32 alarmLow = 4;
  inline bool has_alarmlow() const;
  inline void clear_alarmlow();
  static const int kAlarmLowFieldNumber = 4;
  inline ::google::protobuf::int32 alarmlow() const;
  inline void set_alarmlow(::google::protobuf::int32 value);

  // optional sint32 calibration = 5;
  inline bool has_calibration() const;
  inline void clear_calibration();
  static const int kCalibrationFieldNumber = 5;
  inline ::google::protobuf::int32 calibration() const;
  inline void set_calibration(::google::protobuf::int32 value);

  // optional .SensorError error = 6;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 6;
  inline ::SensorError error() const;
  inline void set_error(::SensorError value);

  // optional uint32 status = 7;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 7;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // optional sint32 alarmStepHigh = 8;
  inline bool has_alarmstephigh() const;
  inline void clear_alarmstephigh();
  static const int kAlarmStepHighFieldNumber = 8;
  inline ::google::protobuf::int32 alarmstephigh() const;
  inline void set_alarmstephigh(::google::protobuf::int32 value);

  // optional sint32 alarmStepLow = 9;
  inline bool has_alarmsteplow() const;
  inline void clear_alarmsteplow();
  static const int kAlarmStepLowFieldNumber = 9;
  inline ::google::protobuf::int32 alarmsteplow() const;
  inline void set_alarmsteplow(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SensorDataInt)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_alarmhigh();
  inline void clear_has_alarmhigh();
  inline void set_has_alarmlow();
  inline void clear_has_alarmlow();
  inline void set_has_calibration();
  inline void clear_has_calibration();
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_alarmstephigh();
  inline void clear_has_alarmstephigh();
  inline void set_has_alarmsteplow();
  inline void clear_has_alarmsteplow();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  ::google::protobuf::int32 data_;
  ::google::protobuf::int32 alarmhigh_;
  ::google::protobuf::int32 alarmlow_;
  ::google::protobuf::int32 calibration_;
  int error_;
  ::google::protobuf::uint32 status_;
  ::google::protobuf::int32 alarmstephigh_;
  ::google::protobuf::int32 alarmsteplow_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_MsgNode_5f1v1_5fm8_2eproto();
  friend void protobuf_AssignDesc_MsgNode_5f1v1_5fm8_2eproto();
  friend void protobuf_ShutdownFile_MsgNode_5f1v1_5fm8_2eproto();

  void InitAsDefaultInstance();
  static SensorDataInt* default_instance_;
};
// -------------------------------------------------------------------

class SensorDataFloat : public ::google::protobuf::Message {
 public:
  SensorDataFloat();
  virtual ~SensorDataFloat();

  SensorDataFloat(const SensorDataFloat& from);

  inline SensorDataFloat& operator=(const SensorDataFloat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SensorDataFloat& default_instance();

  void Swap(SensorDataFloat* other);

  // implements Message ----------------------------------------------

  SensorDataFloat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SensorDataFloat& from);
  void MergeFrom(const SensorDataFloat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SensorType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::SensorType type() const;
  inline void set_type(::SensorType value);

  // optional float data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline float data() const;
  inline void set_data(float value);

  // optional float alarmHigh = 3;
  inline bool has_alarmhigh() const;
  inline void clear_alarmhigh();
  static const int kAlarmHighFieldNumber = 3;
  inline float alarmhigh() const;
  inline void set_alarmhigh(float value);

  // optional float alarmLow = 4;
  inline bool has_alarmlow() const;
  inline void clear_alarmlow();
  static const int kAlarmLowFieldNumber = 4;
  inline float alarmlow() const;
  inline void set_alarmlow(float value);

  // optional sint32 calibration = 5;
  inline bool has_calibration() const;
  inline void clear_calibration();
  static const int kCalibrationFieldNumber = 5;
  inline ::google::protobuf::int32 calibration() const;
  inline void set_calibration(::google::protobuf::int32 value);

  // optional .SensorError error = 6;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 6;
  inline ::SensorError error() const;
  inline void set_error(::SensorError value);

  // optional uint32 status = 7;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 7;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // optional float alarmStepHigh = 8;
  inline bool has_alarmstephigh() const;
  inline void clear_alarmstephigh();
  static const int kAlarmStepHighFieldNumber = 8;
  inline float alarmstephigh() const;
  inline void set_alarmstephigh(float value);

  // optional float alarmStepLow = 9;
  inline bool has_alarmsteplow() const;
  inline void clear_alarmsteplow();
  static const int kAlarmStepLowFieldNumber = 9;
  inline float alarmsteplow() const;
  inline void set_alarmsteplow(float value);

  // @@protoc_insertion_point(class_scope:SensorDataFloat)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_alarmhigh();
  inline void clear_has_alarmhigh();
  inline void set_has_alarmlow();
  inline void clear_has_alarmlow();
  inline void set_has_calibration();
  inline void clear_has_calibration();
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_alarmstephigh();
  inline void clear_has_alarmstephigh();
  inline void set_has_alarmsteplow();
  inline void clear_has_alarmsteplow();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  float data_;
  float alarmhigh_;
  float alarmlow_;
  ::google::protobuf::int32 calibration_;
  int error_;
  ::google::protobuf::uint32 status_;
  float alarmstephigh_;
  float alarmsteplow_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_MsgNode_5f1v1_5fm8_2eproto();
  friend void protobuf_AssignDesc_MsgNode_5f1v1_5fm8_2eproto();
  friend void protobuf_ShutdownFile_MsgNode_5f1v1_5fm8_2eproto();

  void InitAsDefaultInstance();
  static SensorDataFloat* default_instance_;
};
// -------------------------------------------------------------------

class MultiSensorData : public ::google::protobuf::Message {
 public:
  MultiSensorData();
  virtual ~MultiSensorData();

  MultiSensorData(const MultiSensorData& from);

  inline MultiSensorData& operator=(const MultiSensorData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MultiSensorData& default_instance();

  void Swap(MultiSensorData* other);

  // implements Message ----------------------------------------------

  MultiSensorData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MultiSensorData& from);
  void MergeFrom(const MultiSensorData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float data = 1;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline float data(int index) const;
  inline void set_data(int index, float value);
  inline void add_data(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      data() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_data();

  // optional float alarmHigh = 2;
  inline bool has_alarmhigh() const;
  inline void clear_alarmhigh();
  static const int kAlarmHighFieldNumber = 2;
  inline float alarmhigh() const;
  inline void set_alarmhigh(float value);

  // optional float alarmLow = 3;
  inline bool has_alarmlow() const;
  inline void clear_alarmlow();
  static const int kAlarmLowFieldNumber = 3;
  inline float alarmlow() const;
  inline void set_alarmlow(float value);

  // optional uint32 calibration = 4;
  inline bool has_calibration() const;
  inline void clear_calibration();
  static const int kCalibrationFieldNumber = 4;
  inline ::google::protobuf::uint32 calibration() const;
  inline void set_calibration(::google::protobuf::uint32 value);

  // optional .SensorError error = 5;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 5;
  inline ::SensorError error() const;
  inline void set_error(::SensorError value);

  // optional uint32 status = 6;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 6;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // optional float alarmStepHigh = 7;
  inline bool has_alarmstephigh() const;
  inline void clear_alarmstephigh();
  static const int kAlarmStepHighFieldNumber = 7;
  inline float alarmstephigh() const;
  inline void set_alarmstephigh(float value);

  // optional float alarmStepLow = 8;
  inline bool has_alarmsteplow() const;
  inline void clear_alarmsteplow();
  static const int kAlarmStepLowFieldNumber = 8;
  inline float alarmsteplow() const;
  inline void set_alarmsteplow(float value);

  // @@protoc_insertion_point(class_scope:MultiSensorData)
 private:
  inline void set_has_alarmhigh();
  inline void clear_has_alarmhigh();
  inline void set_has_alarmlow();
  inline void clear_has_alarmlow();
  inline void set_has_calibration();
  inline void clear_has_calibration();
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_alarmstephigh();
  inline void clear_has_alarmstephigh();
  inline void set_has_alarmsteplow();
  inline void clear_has_alarmsteplow();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< float > data_;
  float alarmhigh_;
  float alarmlow_;
  ::google::protobuf::uint32 calibration_;
  int error_;
  ::google::protobuf::uint32 status_;
  float alarmstephigh_;
  float alarmsteplow_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_MsgNode_5f1v1_5fm8_2eproto();
  friend void protobuf_AssignDesc_MsgNode_5f1v1_5fm8_2eproto();
  friend void protobuf_ShutdownFile_MsgNode_5f1v1_5fm8_2eproto();

  void InitAsDefaultInstance();
  static MultiSensorData* default_instance_;
};
// -------------------------------------------------------------------

class MultiSensorDataInt : public ::google::protobuf::Message {
 public:
  MultiSensorDataInt();
  virtual ~MultiSensorDataInt();

  MultiSensorDataInt(const MultiSensorDataInt& from);

  inline MultiSensorDataInt& operator=(const MultiSensorDataInt& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MultiSensorDataInt& default_instance();

  void Swap(MultiSensorDataInt* other);

  // implements Message ----------------------------------------------

  MultiSensorDataInt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MultiSensorDataInt& from);
  void MergeFrom(const MultiSensorDataInt& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated sint32 data = 1;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline ::google::protobuf::int32 data(int index) const;
  inline void set_data(int index, ::google::protobuf::int32 value);
  inline void add_data(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      data() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_data();

  // optional sint32 alarmHigh = 2;
  inline bool has_alarmhigh() const;
  inline void clear_alarmhigh();
  static const int kAlarmHighFieldNumber = 2;
  inline ::google::protobuf::int32 alarmhigh() const;
  inline void set_alarmhigh(::google::protobuf::int32 value);

  // optional sint32 alarmLow = 3;
  inline bool has_alarmlow() const;
  inline void clear_alarmlow();
  static const int kAlarmLowFieldNumber = 3;
  inline ::google::protobuf::int32 alarmlow() const;
  inline void set_alarmlow(::google::protobuf::int32 value);

  // optional uint32 calibration = 4;
  inline bool has_calibration() const;
  inline void clear_calibration();
  static const int kCalibrationFieldNumber = 4;
  inline ::google::protobuf::uint32 calibration() const;
  inline void set_calibration(::google::protobuf::uint32 value);

  // optional .SensorError error = 5;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 5;
  inline ::SensorError error() const;
  inline void set_error(::SensorError value);

  // optional uint32 status = 6;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 6;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // optional sint32 alarmStepHigh = 7;
  inline bool has_alarmstephigh() const;
  inline void clear_alarmstephigh();
  static const int kAlarmStepHighFieldNumber = 7;
  inline ::google::protobuf::int32 alarmstephigh() const;
  inline void set_alarmstephigh(::google::protobuf::int32 value);

  // optional sint32 alarmStepLow = 8;
  inline bool has_alarmsteplow() const;
  inline void clear_alarmsteplow();
  static const int kAlarmStepLowFieldNumber = 8;
  inline ::google::protobuf::int32 alarmsteplow() const;
  inline void set_alarmsteplow(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:MultiSensorDataInt)
 private:
  inline void set_has_alarmhigh();
  inline void clear_has_alarmhigh();
  inline void set_has_alarmlow();
  inline void clear_has_alarmlow();
  inline void set_has_calibration();
  inline void clear_has_calibration();
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_alarmstephigh();
  inline void clear_has_alarmstephigh();
  inline void set_has_alarmsteplow();
  inline void clear_has_alarmsteplow();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > data_;
  ::google::protobuf::int32 alarmhigh_;
  ::google::protobuf::int32 alarmlow_;
  ::google::protobuf::uint32 calibration_;
  int error_;
  ::google::protobuf::uint32 status_;
  ::google::protobuf::int32 alarmstephigh_;
  ::google::protobuf::int32 alarmsteplow_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_MsgNode_5f1v1_5fm8_2eproto();
  friend void protobuf_AssignDesc_MsgNode_5f1v1_5fm8_2eproto();
  friend void protobuf_ShutdownFile_MsgNode_5f1v1_5fm8_2eproto();

  void InitAsDefaultInstance();
  static MultiSensorDataInt* default_instance_;
};
// -------------------------------------------------------------------

class GpsData : public ::google::protobuf::Message {
 public:
  GpsData();
  virtual ~GpsData();

  GpsData(const GpsData& from);

  inline GpsData& operator=(const GpsData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GpsData& default_instance();

  void Swap(GpsData* other);

  // implements Message ----------------------------------------------

  GpsData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GpsData& from);
  void MergeFrom(const GpsData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double latitude = 1;
  inline bool has_latitude() const;
  inline void clear_latitude();
  static const int kLatitudeFieldNumber = 1;
  inline double latitude() const;
  inline void set_latitude(double value);

  // optional double longitude = 2;
  inline bool has_longitude() const;
  inline void clear_longitude();
  static const int kLongitudeFieldNumber = 2;
  inline double longitude() const;
  inline void set_longitude(double value);

  // optional double altitude = 3;
  inline bool has_altitude() const;
  inline void clear_altitude();
  static const int kAltitudeFieldNumber = 3;
  inline double altitude() const;
  inline void set_altitude(double value);

  // @@protoc_insertion_point(class_scope:GpsData)
 private:
  inline void set_has_latitude();
  inline void clear_has_latitude();
  inline void set_has_longitude();
  inline void clear_has_longitude();
  inline void set_has_altitude();
  inline void clear_has_altitude();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double latitude_;
  double longitude_;
  double altitude_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_MsgNode_5f1v1_5fm8_2eproto();
  friend void protobuf_AssignDesc_MsgNode_5f1v1_5fm8_2eproto();
  friend void protobuf_ShutdownFile_MsgNode_5f1v1_5fm8_2eproto();

  void InitAsDefaultInstance();
  static GpsData* default_instance_;
};
// -------------------------------------------------------------------

class AxisData : public ::google::protobuf::Message {
 public:
  AxisData();
  virtual ~AxisData();

  AxisData(const AxisData& from);

  inline AxisData& operator=(const AxisData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AxisData& default_instance();

  void Swap(AxisData* other);

  // implements Message ----------------------------------------------

  AxisData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AxisData& from);
  void MergeFrom(const AxisData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // optional float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);

  // optional float z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline float z() const;
  inline void set_z(float value);

  // @@protoc_insertion_point(class_scope:AxisData)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float x_;
  float y_;
  float z_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_MsgNode_5f1v1_5fm8_2eproto();
  friend void protobuf_AssignDesc_MsgNode_5f1v1_5fm8_2eproto();
  friend void protobuf_ShutdownFile_MsgNode_5f1v1_5fm8_2eproto();

  void InitAsDefaultInstance();
  static AxisData* default_instance_;
};
// -------------------------------------------------------------------

class iBeacon : public ::google::protobuf::Message {
 public:
  iBeacon();
  virtual ~iBeacon();

  iBeacon(const iBeacon& from);

  inline iBeacon& operator=(const iBeacon& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const iBeacon& default_instance();

  void Swap(iBeacon* other);

  // implements Message ----------------------------------------------

  iBeacon* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const iBeacon& from);
  void MergeFrom(const iBeacon& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes addr = 1;
  inline bool has_addr() const;
  inline void clear_addr();
  static const int kAddrFieldNumber = 1;
  inline const ::std::string& addr() const;
  inline void set_addr(const ::std::string& value);
  inline void set_addr(const char* value);
  inline void set_addr(const void* value, size_t size);
  inline ::std::string* mutable_addr();
  inline ::std::string* release_addr();
  inline void set_allocated_addr(::std::string* addr);

  // optional bytes umm = 2;
  inline bool has_umm() const;
  inline void clear_umm();
  static const int kUmmFieldNumber = 2;
  inline const ::std::string& umm() const;
  inline void set_umm(const ::std::string& value);
  inline void set_umm(const char* value);
  inline void set_umm(const void* value, size_t size);
  inline ::std::string* mutable_umm();
  inline ::std::string* release_umm();
  inline void set_allocated_umm(::std::string* umm);

  // optional sint32 rssi = 3;
  inline bool has_rssi() const;
  inline void clear_rssi();
  static const int kRssiFieldNumber = 3;
  inline ::google::protobuf::int32 rssi() const;
  inline void set_rssi(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:iBeacon)
 private:
  inline void set_has_addr();
  inline void clear_has_addr();
  inline void set_has_umm();
  inline void clear_has_umm();
  inline void set_has_rssi();
  inline void clear_has_rssi();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* addr_;
  ::std::string* umm_;
  ::google::protobuf::int32 rssi_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_MsgNode_5f1v1_5fm8_2eproto();
  friend void protobuf_AssignDesc_MsgNode_5f1v1_5fm8_2eproto();
  friend void protobuf_ShutdownFile_MsgNode_5f1v1_5fm8_2eproto();

  void InitAsDefaultInstance();
  static iBeacon* default_instance_;
};
// -------------------------------------------------------------------

class AppParam : public ::google::protobuf::Message {
 public:
  AppParam();
  virtual ~AppParam();

  AppParam(const AppParam& from);

  inline AppParam& operator=(const AppParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AppParam& default_instance();

  void Swap(AppParam* other);

  // implements Message ----------------------------------------------

  AppParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AppParam& from);
  void MergeFrom(const AppParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .AppCmd cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::AppCmd cmd() const;
  inline void set_cmd(::AppCmd value);

  // optional uint32 uploadInterval = 2;
  inline bool has_uploadinterval() const;
  inline void clear_uploadinterval();
  static const int kUploadIntervalFieldNumber = 2;
  inline ::google::protobuf::uint32 uploadinterval() const;
  inline void set_uploadinterval(::google::protobuf::uint32 value);

  // optional uint32 syncTime = 3;
  inline bool has_synctime() const;
  inline void clear_synctime();
  static const int kSyncTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 synctime() const;
  inline void set_synctime(::google::protobuf::uint32 value);

  // optional .NodeState nodeState = 4;
  inline bool has_nodestate() const;
  inline void clear_nodestate();
  static const int kNodeStateFieldNumber = 4;
  inline ::NodeState nodestate() const;
  inline void set_nodestate(::NodeState value);

  // optional .NodeAlarm nodeAlarm = 5;
  inline bool has_nodealarm() const;
  inline void clear_nodealarm();
  static const int kNodeAlarmFieldNumber = 5;
  inline ::NodeAlarm nodealarm() const;
  inline void set_nodealarm(::NodeAlarm value);

  // optional uint32 nodeAlarmSet = 6;
  inline bool has_nodealarmset() const;
  inline void clear_nodealarmset();
  static const int kNodeAlarmSetFieldNumber = 6;
  inline ::google::protobuf::uint32 nodealarmset() const;
  inline void set_nodealarmset(::google::protobuf::uint32 value);

  // optional uint32 confirm = 7;
  inline bool has_confirm() const;
  inline void clear_confirm();
  static const int kConfirmFieldNumber = 7;
  inline ::google::protobuf::uint32 confirm() const;
  inline void set_confirm(::google::protobuf::uint32 value);

  // optional .SmokeCtrl smokeCtrl = 8;
  inline bool has_smokectrl() const;
  inline void clear_smokectrl();
  static const int kSmokeCtrlFieldNumber = 8;
  inline ::SmokeCtrl smokectrl() const;
  inline void set_smokectrl(::SmokeCtrl value);

  // optional uint32 uploadRepeat = 9;
  inline bool has_uploadrepeat() const;
  inline void clear_uploadrepeat();
  static const int kUploadRepeatFieldNumber = 9;
  inline ::google::protobuf::uint32 uploadrepeat() const;
  inline void set_uploadrepeat(::google::protobuf::uint32 value);

  // optional uint32 alarmUploadInterval = 10;
  inline bool has_alarmuploadinterval() const;
  inline void clear_alarmuploadinterval();
  static const int kAlarmUploadIntervalFieldNumber = 10;
  inline ::google::protobuf::uint32 alarmuploadinterval() const;
  inline void set_alarmuploadinterval(::google::protobuf::uint32 value);

  // optional uint32 alarmUploadNb = 11;
  inline bool has_alarmuploadnb() const;
  inline void clear_alarmuploadnb();
  static const int kAlarmUploadNbFieldNumber = 11;
  inline ::google::protobuf::uint32 alarmuploadnb() const;
  inline void set_alarmuploadnb(::google::protobuf::uint32 value);

  // optional .TrackerCtrl trackerCtrl = 12;
  inline bool has_trackerctrl() const;
  inline void clear_trackerctrl();
  static const int kTrackerCtrlFieldNumber = 12;
  inline ::TrackerCtrl trackerctrl() const;
  inline void set_trackerctrl(::TrackerCtrl value);

  // optional uint32 trackerEmergencyTime = 13;
  inline bool has_trackeremergencytime() const;
  inline void clear_trackeremergencytime();
  static const int kTrackerEmergencyTimeFieldNumber = 13;
  inline ::google::protobuf::uint32 trackeremergencytime() const;
  inline void set_trackeremergencytime(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:AppParam)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_uploadinterval();
  inline void clear_has_uploadinterval();
  inline void set_has_synctime();
  inline void clear_has_synctime();
  inline void set_has_nodestate();
  inline void clear_has_nodestate();
  inline void set_has_nodealarm();
  inline void clear_has_nodealarm();
  inline void set_has_nodealarmset();
  inline void clear_has_nodealarmset();
  inline void set_has_confirm();
  inline void clear_has_confirm();
  inline void set_has_smokectrl();
  inline void clear_has_smokectrl();
  inline void set_has_uploadrepeat();
  inline void clear_has_uploadrepeat();
  inline void set_has_alarmuploadinterval();
  inline void clear_has_alarmuploadinterval();
  inline void set_has_alarmuploadnb();
  inline void clear_has_alarmuploadnb();
  inline void set_has_trackerctrl();
  inline void clear_has_trackerctrl();
  inline void set_has_trackeremergencytime();
  inline void clear_has_trackeremergencytime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int cmd_;
  ::google::protobuf::uint32 uploadinterval_;
  ::google::protobuf::uint32 synctime_;
  int nodestate_;
  int nodealarm_;
  ::google::protobuf::uint32 nodealarmset_;
  ::google::protobuf::uint32 confirm_;
  int smokectrl_;
  ::google::protobuf::uint32 uploadrepeat_;
  ::google::protobuf::uint32 alarmuploadinterval_;
  ::google::protobuf::uint32 alarmuploadnb_;
  int trackerctrl_;
  ::google::protobuf::uint32 trackeremergencytime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_MsgNode_5f1v1_5fm8_2eproto();
  friend void protobuf_AssignDesc_MsgNode_5f1v1_5fm8_2eproto();
  friend void protobuf_ShutdownFile_MsgNode_5f1v1_5fm8_2eproto();

  void InitAsDefaultInstance();
  static AppParam* default_instance_;
};
// -------------------------------------------------------------------

class MsgNode : public ::google::protobuf::Message {
 public:
  MsgNode();
  virtual ~MsgNode();

  MsgNode(const MsgNode& from);

  inline MsgNode& operator=(const MsgNode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgNode& default_instance();

  void Swap(MsgNode* other);

  // implements Message ----------------------------------------------

  MsgNode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgNode& from);
  void MergeFrom(const MsgNode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional uint32 cmd = 2;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 2;
  inline ::google::protobuf::uint32 cmd() const;
  inline void set_cmd(::google::protobuf::uint32 value);

  // optional uint32 cmdRet = 3;
  inline bool has_cmdret() const;
  inline void clear_cmdret();
  static const int kCmdRetFieldNumber = 3;
  inline ::google::protobuf::uint32 cmdret() const;
  inline void set_cmdret(::google::protobuf::uint32 value);

  // optional .LoraParam loraParam = 4;
  inline bool has_loraparam() const;
  inline void clear_loraparam();
  static const int kLoraParamFieldNumber = 4;
  inline const ::LoraParam& loraparam() const;
  inline ::LoraParam* mutable_loraparam();
  inline ::LoraParam* release_loraparam();
  inline void set_allocated_loraparam(::LoraParam* loraparam);

  // optional .BleParam bleParam = 5;
  inline bool has_bleparam() const;
  inline void clear_bleparam();
  static const int kBleParamFieldNumber = 5;
  inline const ::BleParam& bleparam() const;
  inline ::BleParam* mutable_bleparam();
  inline ::BleParam* release_bleparam();
  inline void set_allocated_bleparam(::BleParam* bleparam);

  // optional .AppParam appParam = 6;
  inline bool has_appparam() const;
  inline void clear_appparam();
  static const int kAppParamFieldNumber = 6;
  inline const ::AppParam& appparam() const;
  inline ::AppParam* mutable_appparam();
  inline ::AppParam* release_appparam();
  inline void set_allocated_appparam(::AppParam* appparam);

  // optional sint32 battery = 7;
  inline bool has_battery() const;
  inline void clear_battery();
  static const int kBatteryFieldNumber = 7;
  inline ::google::protobuf::int32 battery() const;
  inline void set_battery(::google::protobuf::int32 value);

  // optional .GpsData gps = 8;
  inline bool has_gps() const;
  inline void clear_gps();
  static const int kGpsFieldNumber = 8;
  inline const ::GpsData& gps() const;
  inline ::GpsData* mutable_gps();
  inline ::GpsData* release_gps();
  inline void set_allocated_gps(::GpsData* gps);

  // optional .AxisData acceleration = 9;
  inline bool has_acceleration() const;
  inline void clear_acceleration();
  static const int kAccelerationFieldNumber = 9;
  inline const ::AxisData& acceleration() const;
  inline ::AxisData* mutable_acceleration();
  inline ::AxisData* release_acceleration();
  inline void set_allocated_acceleration(::AxisData* acceleration);

  // optional .AxisData magnetism = 10;
  inline bool has_magnetism() const;
  inline void clear_magnetism();
  static const int kMagnetismFieldNumber = 10;
  inline const ::AxisData& magnetism() const;
  inline ::AxisData* mutable_magnetism();
  inline ::AxisData* release_magnetism();
  inline void set_allocated_magnetism(::AxisData* magnetism);

  // optional .AxisData gyroscope = 11;
  inline bool has_gyroscope() const;
  inline void clear_gyroscope();
  static const int kGyroscopeFieldNumber = 11;
  inline const ::AxisData& gyroscope() const;
  inline ::AxisData* mutable_gyroscope();
  inline ::AxisData* release_gyroscope();
  inline void set_allocated_gyroscope(::AxisData* gyroscope);

  // optional .SensorData temperature = 12;
  inline bool has_temperature() const;
  inline void clear_temperature();
  static const int kTemperatureFieldNumber = 12;
  inline const ::SensorData& temperature() const;
  inline ::SensorData* mutable_temperature();
  inline ::SensorData* release_temperature();
  inline void set_allocated_temperature(::SensorData* temperature);

  // optional .SensorData humidity = 13;
  inline bool has_humidity() const;
  inline void clear_humidity();
  static const int kHumidityFieldNumber = 13;
  inline const ::SensorData& humidity() const;
  inline ::SensorData* mutable_humidity();
  inline ::SensorData* release_humidity();
  inline void set_allocated_humidity(::SensorData* humidity);

  // optional .SensorData light = 14;
  inline bool has_light() const;
  inline void clear_light();
  static const int kLightFieldNumber = 14;
  inline const ::SensorData& light() const;
  inline ::SensorData* mutable_light();
  inline ::SensorData* release_light();
  inline void set_allocated_light(::SensorData* light);

  // optional .SensorData leak = 15;
  inline bool has_leak() const;
  inline void clear_leak();
  static const int kLeakFieldNumber = 15;
  inline const ::SensorData& leak() const;
  inline ::SensorData* mutable_leak();
  inline ::SensorData* release_leak();
  inline void set_allocated_leak(::SensorData* leak);

  // optional .SensorData co = 16;
  inline bool has_co() const;
  inline void clear_co();
  static const int kCoFieldNumber = 16;
  inline const ::SensorData& co() const;
  inline ::SensorData* mutable_co();
  inline ::SensorData* release_co();
  inline void set_allocated_co(::SensorData* co);

  // optional .SensorData co2 = 17;
  inline bool has_co2() const;
  inline void clear_co2();
  static const int kCo2FieldNumber = 17;
  inline const ::SensorData& co2() const;
  inline ::SensorData* mutable_co2();
  inline ::SensorData* release_co2();
  inline void set_allocated_co2(::SensorData* co2);

  // optional .SensorData so2 = 18;
  inline bool has_so2() const;
  inline void clear_so2();
  static const int kSo2FieldNumber = 18;
  inline const ::SensorData& so2() const;
  inline ::SensorData* mutable_so2();
  inline ::SensorData* release_so2();
  inline void set_allocated_so2(::SensorData* so2);

  // optional .SensorData no2 = 19;
  inline bool has_no2() const;
  inline void clear_no2();
  static const int kNo2FieldNumber = 19;
  inline const ::SensorData& no2() const;
  inline ::SensorData* mutable_no2();
  inline ::SensorData* release_no2();
  inline void set_allocated_no2(::SensorData* no2);

  // optional .SensorData ch4 = 20;
  inline bool has_ch4() const;
  inline void clear_ch4();
  static const int kCh4FieldNumber = 20;
  inline const ::SensorData& ch4() const;
  inline ::SensorData* mutable_ch4();
  inline ::SensorData* release_ch4();
  inline void set_allocated_ch4(::SensorData* ch4);

  // optional .SensorData ch2o = 21;
  inline bool has_ch2o() const;
  inline void clear_ch2o();
  static const int kCh2OFieldNumber = 21;
  inline const ::SensorData& ch2o() const;
  inline ::SensorData* mutable_ch2o();
  inline ::SensorData* release_ch2o();
  inline void set_allocated_ch2o(::SensorData* ch2o);

  // optional .SensorData lpg = 22;
  inline bool has_lpg() const;
  inline void clear_lpg();
  static const int kLpgFieldNumber = 22;
  inline const ::SensorData& lpg() const;
  inline ::SensorData* mutable_lpg();
  inline ::SensorData* release_lpg();
  inline void set_allocated_lpg(::SensorData* lpg);

  // optional .SensorData o3 = 23;
  inline bool has_o3() const;
  inline void clear_o3();
  static const int kO3FieldNumber = 23;
  inline const ::SensorData& o3() const;
  inline ::SensorData* mutable_o3();
  inline ::SensorData* release_o3();
  inline void set_allocated_o3(::SensorData* o3);

  // optional .SensorData pm1 = 24;
  inline bool has_pm1() const;
  inline void clear_pm1();
  static const int kPm1FieldNumber = 24;
  inline const ::SensorData& pm1() const;
  inline ::SensorData* mutable_pm1();
  inline ::SensorData* release_pm1();
  inline void set_allocated_pm1(::SensorData* pm1);

  // optional .SensorData pm2_5 = 25;
  inline bool has_pm2_5() const;
  inline void clear_pm2_5();
  static const int kPm25FieldNumber = 25;
  inline const ::SensorData& pm2_5() const;
  inline ::SensorData* mutable_pm2_5();
  inline ::SensorData* release_pm2_5();
  inline void set_allocated_pm2_5(::SensorData* pm2_5);

  // optional .SensorData pm10 = 26;
  inline bool has_pm10() const;
  inline void clear_pm10();
  static const int kPm10FieldNumber = 26;
  inline const ::SensorData& pm10() const;
  inline ::SensorData* mutable_pm10();
  inline ::SensorData* release_pm10();
  inline void set_allocated_pm10(::SensorData* pm10);

  // optional .SensorData angle = 27;
  inline bool has_angle() const;
  inline void clear_angle();
  static const int kAngleFieldNumber = 27;
  inline const ::SensorData& angle() const;
  inline ::SensorData* mutable_angle();
  inline ::SensorData* release_angle();
  inline void set_allocated_angle(::SensorData* angle);

  // optional .SensorData cover = 28;
  inline bool has_cover() const;
  inline void clear_cover();
  static const int kCoverFieldNumber = 28;
  inline const ::SensorData& cover() const;
  inline ::SensorData* mutable_cover();
  inline ::SensorData* release_cover();
  inline void set_allocated_cover(::SensorData* cover);

  // optional .SensorData level = 29;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 29;
  inline const ::SensorData& level() const;
  inline ::SensorData* mutable_level();
  inline ::SensorData* release_level();
  inline void set_allocated_level(::SensorData* level);

  // optional .SensorData smoke = 30;
  inline bool has_smoke() const;
  inline void clear_smoke();
  static const int kSmokeFieldNumber = 30;
  inline const ::SensorData& smoke() const;
  inline ::SensorData* mutable_smoke();
  inline ::SensorData* release_smoke();
  inline void set_allocated_smoke(::SensorData* smoke);

  // optional .SensorData pitch = 31;
  inline bool has_pitch() const;
  inline void clear_pitch();
  static const int kPitchFieldNumber = 31;
  inline const ::SensorData& pitch() const;
  inline ::SensorData* mutable_pitch();
  inline ::SensorData* release_pitch();
  inline void set_allocated_pitch(::SensorData* pitch);

  // optional .SensorData roll = 32;
  inline bool has_roll() const;
  inline void clear_roll();
  static const int kRollFieldNumber = 32;
  inline const ::SensorData& roll() const;
  inline ::SensorData* mutable_roll();
  inline ::SensorData* release_roll();
  inline void set_allocated_roll(::SensorData* roll);

  // optional .SensorData yaw = 33;
  inline bool has_yaw() const;
  inline void clear_yaw();
  static const int kYawFieldNumber = 33;
  inline const ::SensorData& yaw() const;
  inline ::SensorData* mutable_yaw();
  inline ::SensorData* release_yaw();
  inline void set_allocated_yaw(::SensorData* yaw);

  // optional .SensorDataInt flame = 34;
  inline bool has_flame() const;
  inline void clear_flame();
  static const int kFlameFieldNumber = 34;
  inline const ::SensorDataInt& flame() const;
  inline ::SensorDataInt* mutable_flame();
  inline ::SensorDataInt* release_flame();
  inline void set_allocated_flame(::SensorDataInt* flame);

  // optional .SensorData artificialGas = 35;
  inline bool has_artificialgas() const;
  inline void clear_artificialgas();
  static const int kArtificialGasFieldNumber = 35;
  inline const ::SensorData& artificialgas() const;
  inline ::SensorData* mutable_artificialgas();
  inline ::SensorData* release_artificialgas();
  inline void set_allocated_artificialgas(::SensorData* artificialgas);

  // optional .MultiSensorDataInt multiTemp = 36;
  inline bool has_multitemp() const;
  inline void clear_multitemp();
  static const int kMultiTempFieldNumber = 36;
  inline const ::MultiSensorDataInt& multitemp() const;
  inline ::MultiSensorDataInt* mutable_multitemp();
  inline ::MultiSensorDataInt* release_multitemp();
  inline void set_allocated_multitemp(::MultiSensorDataInt* multitemp);

  // optional .SensorData waterPressure = 37;
  inline bool has_waterpressure() const;
  inline void clear_waterpressure();
  static const int kWaterPressureFieldNumber = 37;
  inline const ::SensorData& waterpressure() const;
  inline ::SensorData* mutable_waterpressure();
  inline ::SensorData* release_waterpressure();
  inline void set_allocated_waterpressure(::SensorData* waterpressure);

  // optional .iBeacon ibeacon = 38;
  inline bool has_ibeacon() const;
  inline void clear_ibeacon();
  static const int kIbeaconFieldNumber = 38;
  inline const ::iBeacon& ibeacon() const;
  inline ::iBeacon* mutable_ibeacon();
  inline ::iBeacon* release_ibeacon();
  inline void set_allocated_ibeacon(::iBeacon* ibeacon);

  // @@protoc_insertion_point(class_scope:MsgNode)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_cmdret();
  inline void clear_has_cmdret();
  inline void set_has_loraparam();
  inline void clear_has_loraparam();
  inline void set_has_bleparam();
  inline void clear_has_bleparam();
  inline void set_has_appparam();
  inline void clear_has_appparam();
  inline void set_has_battery();
  inline void clear_has_battery();
  inline void set_has_gps();
  inline void clear_has_gps();
  inline void set_has_acceleration();
  inline void clear_has_acceleration();
  inline void set_has_magnetism();
  inline void clear_has_magnetism();
  inline void set_has_gyroscope();
  inline void clear_has_gyroscope();
  inline void set_has_temperature();
  inline void clear_has_temperature();
  inline void set_has_humidity();
  inline void clear_has_humidity();
  inline void set_has_light();
  inline void clear_has_light();
  inline void set_has_leak();
  inline void clear_has_leak();
  inline void set_has_co();
  inline void clear_has_co();
  inline void set_has_co2();
  inline void clear_has_co2();
  inline void set_has_so2();
  inline void clear_has_so2();
  inline void set_has_no2();
  inline void clear_has_no2();
  inline void set_has_ch4();
  inline void clear_has_ch4();
  inline void set_has_ch2o();
  inline void clear_has_ch2o();
  inline void set_has_lpg();
  inline void clear_has_lpg();
  inline void set_has_o3();
  inline void clear_has_o3();
  inline void set_has_pm1();
  inline void clear_has_pm1();
  inline void set_has_pm2_5();
  inline void clear_has_pm2_5();
  inline void set_has_pm10();
  inline void clear_has_pm10();
  inline void set_has_angle();
  inline void clear_has_angle();
  inline void set_has_cover();
  inline void clear_has_cover();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_smoke();
  inline void clear_has_smoke();
  inline void set_has_pitch();
  inline void clear_has_pitch();
  inline void set_has_roll();
  inline void clear_has_roll();
  inline void set_has_yaw();
  inline void clear_has_yaw();
  inline void set_has_flame();
  inline void clear_has_flame();
  inline void set_has_artificialgas();
  inline void clear_has_artificialgas();
  inline void set_has_multitemp();
  inline void clear_has_multitemp();
  inline void set_has_waterpressure();
  inline void clear_has_waterpressure();
  inline void set_has_ibeacon();
  inline void clear_has_ibeacon();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 cmd_;
  ::LoraParam* loraparam_;
  ::google::protobuf::uint32 cmdret_;
  ::google::protobuf::int32 battery_;
  ::BleParam* bleparam_;
  ::AppParam* appparam_;
  ::GpsData* gps_;
  ::AxisData* acceleration_;
  ::AxisData* magnetism_;
  ::AxisData* gyroscope_;
  ::SensorData* temperature_;
  ::SensorData* humidity_;
  ::SensorData* light_;
  ::SensorData* leak_;
  ::SensorData* co_;
  ::SensorData* co2_;
  ::SensorData* so2_;
  ::SensorData* no2_;
  ::SensorData* ch4_;
  ::SensorData* ch2o_;
  ::SensorData* lpg_;
  ::SensorData* o3_;
  ::SensorData* pm1_;
  ::SensorData* pm2_5_;
  ::SensorData* pm10_;
  ::SensorData* angle_;
  ::SensorData* cover_;
  ::SensorData* level_;
  ::SensorData* smoke_;
  ::SensorData* pitch_;
  ::SensorData* roll_;
  ::SensorData* yaw_;
  ::SensorDataInt* flame_;
  ::SensorData* artificialgas_;
  ::MultiSensorDataInt* multitemp_;
  ::SensorData* waterpressure_;
  ::iBeacon* ibeacon_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(38 + 31) / 32];

  friend void  protobuf_AddDesc_MsgNode_5f1v1_5fm8_2eproto();
  friend void protobuf_AssignDesc_MsgNode_5f1v1_5fm8_2eproto();
  friend void protobuf_ShutdownFile_MsgNode_5f1v1_5fm8_2eproto();

  void InitAsDefaultInstance();
  static MsgNode* default_instance_;
};
// ===================================================================


// ===================================================================

// LoraParam

// optional bytes devEui = 1;
inline bool LoraParam::has_deveui() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoraParam::set_has_deveui() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoraParam::clear_has_deveui() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoraParam::clear_deveui() {
  if (deveui_ != &::google::protobuf::internal::kEmptyString) {
    deveui_->clear();
  }
  clear_has_deveui();
}
inline const ::std::string& LoraParam::deveui() const {
  return *deveui_;
}
inline void LoraParam::set_deveui(const ::std::string& value) {
  set_has_deveui();
  if (deveui_ == &::google::protobuf::internal::kEmptyString) {
    deveui_ = new ::std::string;
  }
  deveui_->assign(value);
}
inline void LoraParam::set_deveui(const char* value) {
  set_has_deveui();
  if (deveui_ == &::google::protobuf::internal::kEmptyString) {
    deveui_ = new ::std::string;
  }
  deveui_->assign(value);
}
inline void LoraParam::set_deveui(const void* value, size_t size) {
  set_has_deveui();
  if (deveui_ == &::google::protobuf::internal::kEmptyString) {
    deveui_ = new ::std::string;
  }
  deveui_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoraParam::mutable_deveui() {
  set_has_deveui();
  if (deveui_ == &::google::protobuf::internal::kEmptyString) {
    deveui_ = new ::std::string;
  }
  return deveui_;
}
inline ::std::string* LoraParam::release_deveui() {
  clear_has_deveui();
  if (deveui_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deveui_;
    deveui_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoraParam::set_allocated_deveui(::std::string* deveui) {
  if (deveui_ != &::google::protobuf::internal::kEmptyString) {
    delete deveui_;
  }
  if (deveui) {
    set_has_deveui();
    deveui_ = deveui;
  } else {
    clear_has_deveui();
    deveui_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes appEui = 2;
inline bool LoraParam::has_appeui() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoraParam::set_has_appeui() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoraParam::clear_has_appeui() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoraParam::clear_appeui() {
  if (appeui_ != &::google::protobuf::internal::kEmptyString) {
    appeui_->clear();
  }
  clear_has_appeui();
}
inline const ::std::string& LoraParam::appeui() const {
  return *appeui_;
}
inline void LoraParam::set_appeui(const ::std::string& value) {
  set_has_appeui();
  if (appeui_ == &::google::protobuf::internal::kEmptyString) {
    appeui_ = new ::std::string;
  }
  appeui_->assign(value);
}
inline void LoraParam::set_appeui(const char* value) {
  set_has_appeui();
  if (appeui_ == &::google::protobuf::internal::kEmptyString) {
    appeui_ = new ::std::string;
  }
  appeui_->assign(value);
}
inline void LoraParam::set_appeui(const void* value, size_t size) {
  set_has_appeui();
  if (appeui_ == &::google::protobuf::internal::kEmptyString) {
    appeui_ = new ::std::string;
  }
  appeui_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoraParam::mutable_appeui() {
  set_has_appeui();
  if (appeui_ == &::google::protobuf::internal::kEmptyString) {
    appeui_ = new ::std::string;
  }
  return appeui_;
}
inline ::std::string* LoraParam::release_appeui() {
  clear_has_appeui();
  if (appeui_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = appeui_;
    appeui_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoraParam::set_allocated_appeui(::std::string* appeui) {
  if (appeui_ != &::google::protobuf::internal::kEmptyString) {
    delete appeui_;
  }
  if (appeui) {
    set_has_appeui();
    appeui_ = appeui;
  } else {
    clear_has_appeui();
    appeui_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes appKey = 3;
inline bool LoraParam::has_appkey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoraParam::set_has_appkey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoraParam::clear_has_appkey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoraParam::clear_appkey() {
  if (appkey_ != &::google::protobuf::internal::kEmptyString) {
    appkey_->clear();
  }
  clear_has_appkey();
}
inline const ::std::string& LoraParam::appkey() const {
  return *appkey_;
}
inline void LoraParam::set_appkey(const ::std::string& value) {
  set_has_appkey();
  if (appkey_ == &::google::protobuf::internal::kEmptyString) {
    appkey_ = new ::std::string;
  }
  appkey_->assign(value);
}
inline void LoraParam::set_appkey(const char* value) {
  set_has_appkey();
  if (appkey_ == &::google::protobuf::internal::kEmptyString) {
    appkey_ = new ::std::string;
  }
  appkey_->assign(value);
}
inline void LoraParam::set_appkey(const void* value, size_t size) {
  set_has_appkey();
  if (appkey_ == &::google::protobuf::internal::kEmptyString) {
    appkey_ = new ::std::string;
  }
  appkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoraParam::mutable_appkey() {
  set_has_appkey();
  if (appkey_ == &::google::protobuf::internal::kEmptyString) {
    appkey_ = new ::std::string;
  }
  return appkey_;
}
inline ::std::string* LoraParam::release_appkey() {
  clear_has_appkey();
  if (appkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = appkey_;
    appkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoraParam::set_allocated_appkey(::std::string* appkey) {
  if (appkey_ != &::google::protobuf::internal::kEmptyString) {
    delete appkey_;
  }
  if (appkey) {
    set_has_appkey();
    appkey_ = appkey;
  } else {
    clear_has_appkey();
    appkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes appSkey = 4;
inline bool LoraParam::has_appskey() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoraParam::set_has_appskey() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoraParam::clear_has_appskey() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoraParam::clear_appskey() {
  if (appskey_ != &::google::protobuf::internal::kEmptyString) {
    appskey_->clear();
  }
  clear_has_appskey();
}
inline const ::std::string& LoraParam::appskey() const {
  return *appskey_;
}
inline void LoraParam::set_appskey(const ::std::string& value) {
  set_has_appskey();
  if (appskey_ == &::google::protobuf::internal::kEmptyString) {
    appskey_ = new ::std::string;
  }
  appskey_->assign(value);
}
inline void LoraParam::set_appskey(const char* value) {
  set_has_appskey();
  if (appskey_ == &::google::protobuf::internal::kEmptyString) {
    appskey_ = new ::std::string;
  }
  appskey_->assign(value);
}
inline void LoraParam::set_appskey(const void* value, size_t size) {
  set_has_appskey();
  if (appskey_ == &::google::protobuf::internal::kEmptyString) {
    appskey_ = new ::std::string;
  }
  appskey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoraParam::mutable_appskey() {
  set_has_appskey();
  if (appskey_ == &::google::protobuf::internal::kEmptyString) {
    appskey_ = new ::std::string;
  }
  return appskey_;
}
inline ::std::string* LoraParam::release_appskey() {
  clear_has_appskey();
  if (appskey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = appskey_;
    appskey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoraParam::set_allocated_appskey(::std::string* appskey) {
  if (appskey_ != &::google::protobuf::internal::kEmptyString) {
    delete appskey_;
  }
  if (appskey) {
    set_has_appskey();
    appskey_ = appskey;
  } else {
    clear_has_appskey();
    appskey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes nwkSkey = 5;
inline bool LoraParam::has_nwkskey() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoraParam::set_has_nwkskey() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoraParam::clear_has_nwkskey() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoraParam::clear_nwkskey() {
  if (nwkskey_ != &::google::protobuf::internal::kEmptyString) {
    nwkskey_->clear();
  }
  clear_has_nwkskey();
}
inline const ::std::string& LoraParam::nwkskey() const {
  return *nwkskey_;
}
inline void LoraParam::set_nwkskey(const ::std::string& value) {
  set_has_nwkskey();
  if (nwkskey_ == &::google::protobuf::internal::kEmptyString) {
    nwkskey_ = new ::std::string;
  }
  nwkskey_->assign(value);
}
inline void LoraParam::set_nwkskey(const char* value) {
  set_has_nwkskey();
  if (nwkskey_ == &::google::protobuf::internal::kEmptyString) {
    nwkskey_ = new ::std::string;
  }
  nwkskey_->assign(value);
}
inline void LoraParam::set_nwkskey(const void* value, size_t size) {
  set_has_nwkskey();
  if (nwkskey_ == &::google::protobuf::internal::kEmptyString) {
    nwkskey_ = new ::std::string;
  }
  nwkskey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoraParam::mutable_nwkskey() {
  set_has_nwkskey();
  if (nwkskey_ == &::google::protobuf::internal::kEmptyString) {
    nwkskey_ = new ::std::string;
  }
  return nwkskey_;
}
inline ::std::string* LoraParam::release_nwkskey() {
  clear_has_nwkskey();
  if (nwkskey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nwkskey_;
    nwkskey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoraParam::set_allocated_nwkskey(::std::string* nwkskey) {
  if (nwkskey_ != &::google::protobuf::internal::kEmptyString) {
    delete nwkskey_;
  }
  if (nwkskey) {
    set_has_nwkskey();
    nwkskey_ = nwkskey;
  } else {
    clear_has_nwkskey();
    nwkskey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 devAddr = 6;
inline bool LoraParam::has_devaddr() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LoraParam::set_has_devaddr() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LoraParam::clear_has_devaddr() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LoraParam::clear_devaddr() {
  devaddr_ = 0u;
  clear_has_devaddr();
}
inline ::google::protobuf::uint32 LoraParam::devaddr() const {
  return devaddr_;
}
inline void LoraParam::set_devaddr(::google::protobuf::uint32 value) {
  set_has_devaddr();
  devaddr_ = value;
}

// optional uint32 datarate = 7;
inline bool LoraParam::has_datarate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LoraParam::set_has_datarate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LoraParam::clear_has_datarate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LoraParam::clear_datarate() {
  datarate_ = 0u;
  clear_has_datarate();
}
inline ::google::protobuf::uint32 LoraParam::datarate() const {
  return datarate_;
}
inline void LoraParam::set_datarate(::google::protobuf::uint32 value) {
  set_has_datarate();
  datarate_ = value;
}

// optional sint32 txPower = 8;
inline bool LoraParam::has_txpower() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LoraParam::set_has_txpower() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LoraParam::clear_has_txpower() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LoraParam::clear_txpower() {
  txpower_ = 0;
  clear_has_txpower();
}
inline ::google::protobuf::int32 LoraParam::txpower() const {
  return txpower_;
}
inline void LoraParam::set_txpower(::google::protobuf::int32 value) {
  set_has_txpower();
  txpower_ = value;
}

// optional uint32 adr = 9;
inline bool LoraParam::has_adr() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LoraParam::set_has_adr() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LoraParam::clear_has_adr() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LoraParam::clear_adr() {
  adr_ = 0u;
  clear_has_adr();
}
inline ::google::protobuf::uint32 LoraParam::adr() const {
  return adr_;
}
inline void LoraParam::set_adr(::google::protobuf::uint32 value) {
  set_has_adr();
  adr_ = value;
}

// optional .Activtion activition = 10;
inline bool LoraParam::has_activition() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LoraParam::set_has_activition() {
  _has_bits_[0] |= 0x00000200u;
}
inline void LoraParam::clear_has_activition() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void LoraParam::clear_activition() {
  activition_ = 0;
  clear_has_activition();
}
inline ::Activtion LoraParam::activition() const {
  return static_cast< ::Activtion >(activition_);
}
inline void LoraParam::set_activition(::Activtion value) {
  assert(::Activtion_IsValid(value));
  set_has_activition();
  activition_ = value;
}

// optional .ClassType classType = 11;
inline bool LoraParam::has_classtype() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void LoraParam::set_has_classtype() {
  _has_bits_[0] |= 0x00000400u;
}
inline void LoraParam::clear_has_classtype() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void LoraParam::clear_classtype() {
  classtype_ = 0;
  clear_has_classtype();
}
inline ::ClassType LoraParam::classtype() const {
  return static_cast< ::ClassType >(classtype_);
}
inline void LoraParam::set_classtype(::ClassType value) {
  assert(::ClassType_IsValid(value));
  set_has_classtype();
  classtype_ = value;
}

// optional uint32 delay = 12;
inline bool LoraParam::has_delay() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void LoraParam::set_has_delay() {
  _has_bits_[0] |= 0x00000800u;
}
inline void LoraParam::clear_has_delay() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void LoraParam::clear_delay() {
  delay_ = 0u;
  clear_has_delay();
}
inline ::google::protobuf::uint32 LoraParam::delay() const {
  return delay_;
}
inline void LoraParam::set_delay(::google::protobuf::uint32 value) {
  set_has_delay();
  delay_ = value;
}

// repeated uint32 channelMask = 13;
inline int LoraParam::channelmask_size() const {
  return channelmask_.size();
}
inline void LoraParam::clear_channelmask() {
  channelmask_.Clear();
}
inline ::google::protobuf::uint32 LoraParam::channelmask(int index) const {
  return channelmask_.Get(index);
}
inline void LoraParam::set_channelmask(int index, ::google::protobuf::uint32 value) {
  channelmask_.Set(index, value);
}
inline void LoraParam::add_channelmask(::google::protobuf::uint32 value) {
  channelmask_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
LoraParam::channelmask() const {
  return channelmask_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
LoraParam::mutable_channelmask() {
  return &channelmask_;
}

// optional uint32 maxEIRP = 14;
inline bool LoraParam::has_maxeirp() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void LoraParam::set_has_maxeirp() {
  _has_bits_[0] |= 0x00002000u;
}
inline void LoraParam::clear_has_maxeirp() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void LoraParam::clear_maxeirp() {
  maxeirp_ = 0u;
  clear_has_maxeirp();
}
inline ::google::protobuf::uint32 LoraParam::maxeirp() const {
  return maxeirp_;
}
inline void LoraParam::set_maxeirp(::google::protobuf::uint32 value) {
  set_has_maxeirp();
  maxeirp_ = value;
}

// optional uint32 sglStatus = 15;
inline bool LoraParam::has_sglstatus() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void LoraParam::set_has_sglstatus() {
  _has_bits_[0] |= 0x00004000u;
}
inline void LoraParam::clear_has_sglstatus() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void LoraParam::clear_sglstatus() {
  sglstatus_ = 0u;
  clear_has_sglstatus();
}
inline ::google::protobuf::uint32 LoraParam::sglstatus() const {
  return sglstatus_;
}
inline void LoraParam::set_sglstatus(::google::protobuf::uint32 value) {
  set_has_sglstatus();
  sglstatus_ = value;
}

// optional uint32 sglFrequency = 16;
inline bool LoraParam::has_sglfrequency() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void LoraParam::set_has_sglfrequency() {
  _has_bits_[0] |= 0x00008000u;
}
inline void LoraParam::clear_has_sglfrequency() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void LoraParam::clear_sglfrequency() {
  sglfrequency_ = 0u;
  clear_has_sglfrequency();
}
inline ::google::protobuf::uint32 LoraParam::sglfrequency() const {
  return sglfrequency_;
}
inline void LoraParam::set_sglfrequency(::google::protobuf::uint32 value) {
  set_has_sglfrequency();
  sglfrequency_ = value;
}

// optional uint32 sglDatarate = 17;
inline bool LoraParam::has_sgldatarate() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void LoraParam::set_has_sgldatarate() {
  _has_bits_[0] |= 0x00010000u;
}
inline void LoraParam::clear_has_sgldatarate() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void LoraParam::clear_sgldatarate() {
  sgldatarate_ = 0u;
  clear_has_sgldatarate();
}
inline ::google::protobuf::uint32 LoraParam::sgldatarate() const {
  return sgldatarate_;
}
inline void LoraParam::set_sgldatarate(::google::protobuf::uint32 value) {
  set_has_sgldatarate();
  sgldatarate_ = value;
}

// -------------------------------------------------------------------

// BleParam

// optional float bleInterval = 1;
inline bool BleParam::has_bleinterval() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BleParam::set_has_bleinterval() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BleParam::clear_has_bleinterval() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BleParam::clear_bleinterval() {
  bleinterval_ = 0;
  clear_has_bleinterval();
}
inline float BleParam::bleinterval() const {
  return bleinterval_;
}
inline void BleParam::set_bleinterval(float value) {
  set_has_bleinterval();
  bleinterval_ = value;
}

// optional sint32 bleTxp = 2;
inline bool BleParam::has_bletxp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BleParam::set_has_bletxp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BleParam::clear_has_bletxp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BleParam::clear_bletxp() {
  bletxp_ = 0;
  clear_has_bletxp();
}
inline ::google::protobuf::int32 BleParam::bletxp() const {
  return bletxp_;
}
inline void BleParam::set_bletxp(::google::protobuf::int32 value) {
  set_has_bletxp();
  bletxp_ = value;
}

// optional uint32 bleOnTime = 3;
inline bool BleParam::has_bleontime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BleParam::set_has_bleontime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BleParam::clear_has_bleontime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BleParam::clear_bleontime() {
  bleontime_ = 0u;
  clear_has_bleontime();
}
inline ::google::protobuf::uint32 BleParam::bleontime() const {
  return bleontime_;
}
inline void BleParam::set_bleontime(::google::protobuf::uint32 value) {
  set_has_bleontime();
  bleontime_ = value;
}

// optional uint32 bleOffTime = 4;
inline bool BleParam::has_bleofftime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BleParam::set_has_bleofftime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BleParam::clear_has_bleofftime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BleParam::clear_bleofftime() {
  bleofftime_ = 0u;
  clear_has_bleofftime();
}
inline ::google::protobuf::uint32 BleParam::bleofftime() const {
  return bleofftime_;
}
inline void BleParam::set_bleofftime(::google::protobuf::uint32 value) {
  set_has_bleofftime();
  bleofftime_ = value;
}

// optional uint32 bleOnOff = 5;
inline bool BleParam::has_bleonoff() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BleParam::set_has_bleonoff() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BleParam::clear_has_bleonoff() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BleParam::clear_bleonoff() {
  bleonoff_ = 0u;
  clear_has_bleonoff();
}
inline ::google::protobuf::uint32 BleParam::bleonoff() const {
  return bleonoff_;
}
inline void BleParam::set_bleonoff(::google::protobuf::uint32 value) {
  set_has_bleonoff();
  bleonoff_ = value;
}

// -------------------------------------------------------------------

// SensorData

// optional float data = 1;
inline bool SensorData::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SensorData::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SensorData::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SensorData::clear_data() {
  data_ = 0;
  clear_has_data();
}
inline float SensorData::data() const {
  return data_;
}
inline void SensorData::set_data(float value) {
  set_has_data();
  data_ = value;
}

// optional float alarmHigh = 2;
inline bool SensorData::has_alarmhigh() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SensorData::set_has_alarmhigh() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SensorData::clear_has_alarmhigh() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SensorData::clear_alarmhigh() {
  alarmhigh_ = 0;
  clear_has_alarmhigh();
}
inline float SensorData::alarmhigh() const {
  return alarmhigh_;
}
inline void SensorData::set_alarmhigh(float value) {
  set_has_alarmhigh();
  alarmhigh_ = value;
}

// optional float alarmLow = 3;
inline bool SensorData::has_alarmlow() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SensorData::set_has_alarmlow() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SensorData::clear_has_alarmlow() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SensorData::clear_alarmlow() {
  alarmlow_ = 0;
  clear_has_alarmlow();
}
inline float SensorData::alarmlow() const {
  return alarmlow_;
}
inline void SensorData::set_alarmlow(float value) {
  set_has_alarmlow();
  alarmlow_ = value;
}

// optional uint32 calibration = 4;
inline bool SensorData::has_calibration() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SensorData::set_has_calibration() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SensorData::clear_has_calibration() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SensorData::clear_calibration() {
  calibration_ = 0u;
  clear_has_calibration();
}
inline ::google::protobuf::uint32 SensorData::calibration() const {
  return calibration_;
}
inline void SensorData::set_calibration(::google::protobuf::uint32 value) {
  set_has_calibration();
  calibration_ = value;
}

// optional .SensorError error = 5;
inline bool SensorData::has_error() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SensorData::set_has_error() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SensorData::clear_has_error() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SensorData::clear_error() {
  error_ = 0;
  clear_has_error();
}
inline ::SensorError SensorData::error() const {
  return static_cast< ::SensorError >(error_);
}
inline void SensorData::set_error(::SensorError value) {
  assert(::SensorError_IsValid(value));
  set_has_error();
  error_ = value;
}

// optional uint32 status = 6;
inline bool SensorData::has_status() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SensorData::set_has_status() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SensorData::clear_has_status() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SensorData::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 SensorData::status() const {
  return status_;
}
inline void SensorData::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// optional float alarmStepHigh = 7;
inline bool SensorData::has_alarmstephigh() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SensorData::set_has_alarmstephigh() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SensorData::clear_has_alarmstephigh() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SensorData::clear_alarmstephigh() {
  alarmstephigh_ = 0;
  clear_has_alarmstephigh();
}
inline float SensorData::alarmstephigh() const {
  return alarmstephigh_;
}
inline void SensorData::set_alarmstephigh(float value) {
  set_has_alarmstephigh();
  alarmstephigh_ = value;
}

// optional float alarmStepLow = 8;
inline bool SensorData::has_alarmsteplow() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SensorData::set_has_alarmsteplow() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SensorData::clear_has_alarmsteplow() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SensorData::clear_alarmsteplow() {
  alarmsteplow_ = 0;
  clear_has_alarmsteplow();
}
inline float SensorData::alarmsteplow() const {
  return alarmsteplow_;
}
inline void SensorData::set_alarmsteplow(float value) {
  set_has_alarmsteplow();
  alarmsteplow_ = value;
}

// -------------------------------------------------------------------

// SensorDataInt

// optional .SensorType type = 1;
inline bool SensorDataInt::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SensorDataInt::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SensorDataInt::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SensorDataInt::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::SensorType SensorDataInt::type() const {
  return static_cast< ::SensorType >(type_);
}
inline void SensorDataInt::set_type(::SensorType value) {
  assert(::SensorType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional sint32 data = 2;
inline bool SensorDataInt::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SensorDataInt::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SensorDataInt::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SensorDataInt::clear_data() {
  data_ = 0;
  clear_has_data();
}
inline ::google::protobuf::int32 SensorDataInt::data() const {
  return data_;
}
inline void SensorDataInt::set_data(::google::protobuf::int32 value) {
  set_has_data();
  data_ = value;
}

// optional sint32 alarmHigh = 3;
inline bool SensorDataInt::has_alarmhigh() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SensorDataInt::set_has_alarmhigh() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SensorDataInt::clear_has_alarmhigh() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SensorDataInt::clear_alarmhigh() {
  alarmhigh_ = 0;
  clear_has_alarmhigh();
}
inline ::google::protobuf::int32 SensorDataInt::alarmhigh() const {
  return alarmhigh_;
}
inline void SensorDataInt::set_alarmhigh(::google::protobuf::int32 value) {
  set_has_alarmhigh();
  alarmhigh_ = value;
}

// optional sint32 alarmLow = 4;
inline bool SensorDataInt::has_alarmlow() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SensorDataInt::set_has_alarmlow() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SensorDataInt::clear_has_alarmlow() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SensorDataInt::clear_alarmlow() {
  alarmlow_ = 0;
  clear_has_alarmlow();
}
inline ::google::protobuf::int32 SensorDataInt::alarmlow() const {
  return alarmlow_;
}
inline void SensorDataInt::set_alarmlow(::google::protobuf::int32 value) {
  set_has_alarmlow();
  alarmlow_ = value;
}

// optional sint32 calibration = 5;
inline bool SensorDataInt::has_calibration() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SensorDataInt::set_has_calibration() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SensorDataInt::clear_has_calibration() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SensorDataInt::clear_calibration() {
  calibration_ = 0;
  clear_has_calibration();
}
inline ::google::protobuf::int32 SensorDataInt::calibration() const {
  return calibration_;
}
inline void SensorDataInt::set_calibration(::google::protobuf::int32 value) {
  set_has_calibration();
  calibration_ = value;
}

// optional .SensorError error = 6;
inline bool SensorDataInt::has_error() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SensorDataInt::set_has_error() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SensorDataInt::clear_has_error() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SensorDataInt::clear_error() {
  error_ = 0;
  clear_has_error();
}
inline ::SensorError SensorDataInt::error() const {
  return static_cast< ::SensorError >(error_);
}
inline void SensorDataInt::set_error(::SensorError value) {
  assert(::SensorError_IsValid(value));
  set_has_error();
  error_ = value;
}

// optional uint32 status = 7;
inline bool SensorDataInt::has_status() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SensorDataInt::set_has_status() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SensorDataInt::clear_has_status() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SensorDataInt::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 SensorDataInt::status() const {
  return status_;
}
inline void SensorDataInt::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// optional sint32 alarmStepHigh = 8;
inline bool SensorDataInt::has_alarmstephigh() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SensorDataInt::set_has_alarmstephigh() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SensorDataInt::clear_has_alarmstephigh() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SensorDataInt::clear_alarmstephigh() {
  alarmstephigh_ = 0;
  clear_has_alarmstephigh();
}
inline ::google::protobuf::int32 SensorDataInt::alarmstephigh() const {
  return alarmstephigh_;
}
inline void SensorDataInt::set_alarmstephigh(::google::protobuf::int32 value) {
  set_has_alarmstephigh();
  alarmstephigh_ = value;
}

// optional sint32 alarmStepLow = 9;
inline bool SensorDataInt::has_alarmsteplow() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SensorDataInt::set_has_alarmsteplow() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SensorDataInt::clear_has_alarmsteplow() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SensorDataInt::clear_alarmsteplow() {
  alarmsteplow_ = 0;
  clear_has_alarmsteplow();
}
inline ::google::protobuf::int32 SensorDataInt::alarmsteplow() const {
  return alarmsteplow_;
}
inline void SensorDataInt::set_alarmsteplow(::google::protobuf::int32 value) {
  set_has_alarmsteplow();
  alarmsteplow_ = value;
}

// -------------------------------------------------------------------

// SensorDataFloat

// optional .SensorType type = 1;
inline bool SensorDataFloat::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SensorDataFloat::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SensorDataFloat::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SensorDataFloat::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::SensorType SensorDataFloat::type() const {
  return static_cast< ::SensorType >(type_);
}
inline void SensorDataFloat::set_type(::SensorType value) {
  assert(::SensorType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional float data = 2;
inline bool SensorDataFloat::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SensorDataFloat::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SensorDataFloat::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SensorDataFloat::clear_data() {
  data_ = 0;
  clear_has_data();
}
inline float SensorDataFloat::data() const {
  return data_;
}
inline void SensorDataFloat::set_data(float value) {
  set_has_data();
  data_ = value;
}

// optional float alarmHigh = 3;
inline bool SensorDataFloat::has_alarmhigh() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SensorDataFloat::set_has_alarmhigh() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SensorDataFloat::clear_has_alarmhigh() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SensorDataFloat::clear_alarmhigh() {
  alarmhigh_ = 0;
  clear_has_alarmhigh();
}
inline float SensorDataFloat::alarmhigh() const {
  return alarmhigh_;
}
inline void SensorDataFloat::set_alarmhigh(float value) {
  set_has_alarmhigh();
  alarmhigh_ = value;
}

// optional float alarmLow = 4;
inline bool SensorDataFloat::has_alarmlow() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SensorDataFloat::set_has_alarmlow() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SensorDataFloat::clear_has_alarmlow() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SensorDataFloat::clear_alarmlow() {
  alarmlow_ = 0;
  clear_has_alarmlow();
}
inline float SensorDataFloat::alarmlow() const {
  return alarmlow_;
}
inline void SensorDataFloat::set_alarmlow(float value) {
  set_has_alarmlow();
  alarmlow_ = value;
}

// optional sint32 calibration = 5;
inline bool SensorDataFloat::has_calibration() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SensorDataFloat::set_has_calibration() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SensorDataFloat::clear_has_calibration() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SensorDataFloat::clear_calibration() {
  calibration_ = 0;
  clear_has_calibration();
}
inline ::google::protobuf::int32 SensorDataFloat::calibration() const {
  return calibration_;
}
inline void SensorDataFloat::set_calibration(::google::protobuf::int32 value) {
  set_has_calibration();
  calibration_ = value;
}

// optional .SensorError error = 6;
inline bool SensorDataFloat::has_error() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SensorDataFloat::set_has_error() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SensorDataFloat::clear_has_error() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SensorDataFloat::clear_error() {
  error_ = 0;
  clear_has_error();
}
inline ::SensorError SensorDataFloat::error() const {
  return static_cast< ::SensorError >(error_);
}
inline void SensorDataFloat::set_error(::SensorError value) {
  assert(::SensorError_IsValid(value));
  set_has_error();
  error_ = value;
}

// optional uint32 status = 7;
inline bool SensorDataFloat::has_status() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SensorDataFloat::set_has_status() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SensorDataFloat::clear_has_status() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SensorDataFloat::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 SensorDataFloat::status() const {
  return status_;
}
inline void SensorDataFloat::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// optional float alarmStepHigh = 8;
inline bool SensorDataFloat::has_alarmstephigh() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SensorDataFloat::set_has_alarmstephigh() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SensorDataFloat::clear_has_alarmstephigh() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SensorDataFloat::clear_alarmstephigh() {
  alarmstephigh_ = 0;
  clear_has_alarmstephigh();
}
inline float SensorDataFloat::alarmstephigh() const {
  return alarmstephigh_;
}
inline void SensorDataFloat::set_alarmstephigh(float value) {
  set_has_alarmstephigh();
  alarmstephigh_ = value;
}

// optional float alarmStepLow = 9;
inline bool SensorDataFloat::has_alarmsteplow() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SensorDataFloat::set_has_alarmsteplow() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SensorDataFloat::clear_has_alarmsteplow() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SensorDataFloat::clear_alarmsteplow() {
  alarmsteplow_ = 0;
  clear_has_alarmsteplow();
}
inline float SensorDataFloat::alarmsteplow() const {
  return alarmsteplow_;
}
inline void SensorDataFloat::set_alarmsteplow(float value) {
  set_has_alarmsteplow();
  alarmsteplow_ = value;
}

// -------------------------------------------------------------------

// MultiSensorData

// repeated float data = 1;
inline int MultiSensorData::data_size() const {
  return data_.size();
}
inline void MultiSensorData::clear_data() {
  data_.Clear();
}
inline float MultiSensorData::data(int index) const {
  return data_.Get(index);
}
inline void MultiSensorData::set_data(int index, float value) {
  data_.Set(index, value);
}
inline void MultiSensorData::add_data(float value) {
  data_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
MultiSensorData::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedField< float >*
MultiSensorData::mutable_data() {
  return &data_;
}

// optional float alarmHigh = 2;
inline bool MultiSensorData::has_alarmhigh() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MultiSensorData::set_has_alarmhigh() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MultiSensorData::clear_has_alarmhigh() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MultiSensorData::clear_alarmhigh() {
  alarmhigh_ = 0;
  clear_has_alarmhigh();
}
inline float MultiSensorData::alarmhigh() const {
  return alarmhigh_;
}
inline void MultiSensorData::set_alarmhigh(float value) {
  set_has_alarmhigh();
  alarmhigh_ = value;
}

// optional float alarmLow = 3;
inline bool MultiSensorData::has_alarmlow() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MultiSensorData::set_has_alarmlow() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MultiSensorData::clear_has_alarmlow() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MultiSensorData::clear_alarmlow() {
  alarmlow_ = 0;
  clear_has_alarmlow();
}
inline float MultiSensorData::alarmlow() const {
  return alarmlow_;
}
inline void MultiSensorData::set_alarmlow(float value) {
  set_has_alarmlow();
  alarmlow_ = value;
}

// optional uint32 calibration = 4;
inline bool MultiSensorData::has_calibration() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MultiSensorData::set_has_calibration() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MultiSensorData::clear_has_calibration() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MultiSensorData::clear_calibration() {
  calibration_ = 0u;
  clear_has_calibration();
}
inline ::google::protobuf::uint32 MultiSensorData::calibration() const {
  return calibration_;
}
inline void MultiSensorData::set_calibration(::google::protobuf::uint32 value) {
  set_has_calibration();
  calibration_ = value;
}

// optional .SensorError error = 5;
inline bool MultiSensorData::has_error() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MultiSensorData::set_has_error() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MultiSensorData::clear_has_error() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MultiSensorData::clear_error() {
  error_ = 0;
  clear_has_error();
}
inline ::SensorError MultiSensorData::error() const {
  return static_cast< ::SensorError >(error_);
}
inline void MultiSensorData::set_error(::SensorError value) {
  assert(::SensorError_IsValid(value));
  set_has_error();
  error_ = value;
}

// optional uint32 status = 6;
inline bool MultiSensorData::has_status() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MultiSensorData::set_has_status() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MultiSensorData::clear_has_status() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MultiSensorData::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 MultiSensorData::status() const {
  return status_;
}
inline void MultiSensorData::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// optional float alarmStepHigh = 7;
inline bool MultiSensorData::has_alarmstephigh() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MultiSensorData::set_has_alarmstephigh() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MultiSensorData::clear_has_alarmstephigh() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MultiSensorData::clear_alarmstephigh() {
  alarmstephigh_ = 0;
  clear_has_alarmstephigh();
}
inline float MultiSensorData::alarmstephigh() const {
  return alarmstephigh_;
}
inline void MultiSensorData::set_alarmstephigh(float value) {
  set_has_alarmstephigh();
  alarmstephigh_ = value;
}

// optional float alarmStepLow = 8;
inline bool MultiSensorData::has_alarmsteplow() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MultiSensorData::set_has_alarmsteplow() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MultiSensorData::clear_has_alarmsteplow() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MultiSensorData::clear_alarmsteplow() {
  alarmsteplow_ = 0;
  clear_has_alarmsteplow();
}
inline float MultiSensorData::alarmsteplow() const {
  return alarmsteplow_;
}
inline void MultiSensorData::set_alarmsteplow(float value) {
  set_has_alarmsteplow();
  alarmsteplow_ = value;
}

// -------------------------------------------------------------------

// MultiSensorDataInt

// repeated sint32 data = 1;
inline int MultiSensorDataInt::data_size() const {
  return data_.size();
}
inline void MultiSensorDataInt::clear_data() {
  data_.Clear();
}
inline ::google::protobuf::int32 MultiSensorDataInt::data(int index) const {
  return data_.Get(index);
}
inline void MultiSensorDataInt::set_data(int index, ::google::protobuf::int32 value) {
  data_.Set(index, value);
}
inline void MultiSensorDataInt::add_data(::google::protobuf::int32 value) {
  data_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
MultiSensorDataInt::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
MultiSensorDataInt::mutable_data() {
  return &data_;
}

// optional sint32 alarmHigh = 2;
inline bool MultiSensorDataInt::has_alarmhigh() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MultiSensorDataInt::set_has_alarmhigh() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MultiSensorDataInt::clear_has_alarmhigh() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MultiSensorDataInt::clear_alarmhigh() {
  alarmhigh_ = 0;
  clear_has_alarmhigh();
}
inline ::google::protobuf::int32 MultiSensorDataInt::alarmhigh() const {
  return alarmhigh_;
}
inline void MultiSensorDataInt::set_alarmhigh(::google::protobuf::int32 value) {
  set_has_alarmhigh();
  alarmhigh_ = value;
}

// optional sint32 alarmLow = 3;
inline bool MultiSensorDataInt::has_alarmlow() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MultiSensorDataInt::set_has_alarmlow() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MultiSensorDataInt::clear_has_alarmlow() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MultiSensorDataInt::clear_alarmlow() {
  alarmlow_ = 0;
  clear_has_alarmlow();
}
inline ::google::protobuf::int32 MultiSensorDataInt::alarmlow() const {
  return alarmlow_;
}
inline void MultiSensorDataInt::set_alarmlow(::google::protobuf::int32 value) {
  set_has_alarmlow();
  alarmlow_ = value;
}

// optional uint32 calibration = 4;
inline bool MultiSensorDataInt::has_calibration() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MultiSensorDataInt::set_has_calibration() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MultiSensorDataInt::clear_has_calibration() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MultiSensorDataInt::clear_calibration() {
  calibration_ = 0u;
  clear_has_calibration();
}
inline ::google::protobuf::uint32 MultiSensorDataInt::calibration() const {
  return calibration_;
}
inline void MultiSensorDataInt::set_calibration(::google::protobuf::uint32 value) {
  set_has_calibration();
  calibration_ = value;
}

// optional .SensorError error = 5;
inline bool MultiSensorDataInt::has_error() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MultiSensorDataInt::set_has_error() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MultiSensorDataInt::clear_has_error() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MultiSensorDataInt::clear_error() {
  error_ = 0;
  clear_has_error();
}
inline ::SensorError MultiSensorDataInt::error() const {
  return static_cast< ::SensorError >(error_);
}
inline void MultiSensorDataInt::set_error(::SensorError value) {
  assert(::SensorError_IsValid(value));
  set_has_error();
  error_ = value;
}

// optional uint32 status = 6;
inline bool MultiSensorDataInt::has_status() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MultiSensorDataInt::set_has_status() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MultiSensorDataInt::clear_has_status() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MultiSensorDataInt::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 MultiSensorDataInt::status() const {
  return status_;
}
inline void MultiSensorDataInt::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// optional sint32 alarmStepHigh = 7;
inline bool MultiSensorDataInt::has_alarmstephigh() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MultiSensorDataInt::set_has_alarmstephigh() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MultiSensorDataInt::clear_has_alarmstephigh() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MultiSensorDataInt::clear_alarmstephigh() {
  alarmstephigh_ = 0;
  clear_has_alarmstephigh();
}
inline ::google::protobuf::int32 MultiSensorDataInt::alarmstephigh() const {
  return alarmstephigh_;
}
inline void MultiSensorDataInt::set_alarmstephigh(::google::protobuf::int32 value) {
  set_has_alarmstephigh();
  alarmstephigh_ = value;
}

// optional sint32 alarmStepLow = 8;
inline bool MultiSensorDataInt::has_alarmsteplow() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MultiSensorDataInt::set_has_alarmsteplow() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MultiSensorDataInt::clear_has_alarmsteplow() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MultiSensorDataInt::clear_alarmsteplow() {
  alarmsteplow_ = 0;
  clear_has_alarmsteplow();
}
inline ::google::protobuf::int32 MultiSensorDataInt::alarmsteplow() const {
  return alarmsteplow_;
}
inline void MultiSensorDataInt::set_alarmsteplow(::google::protobuf::int32 value) {
  set_has_alarmsteplow();
  alarmsteplow_ = value;
}

// -------------------------------------------------------------------

// GpsData

// optional double latitude = 1;
inline bool GpsData::has_latitude() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GpsData::set_has_latitude() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GpsData::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GpsData::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline double GpsData::latitude() const {
  return latitude_;
}
inline void GpsData::set_latitude(double value) {
  set_has_latitude();
  latitude_ = value;
}

// optional double longitude = 2;
inline bool GpsData::has_longitude() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GpsData::set_has_longitude() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GpsData::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GpsData::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline double GpsData::longitude() const {
  return longitude_;
}
inline void GpsData::set_longitude(double value) {
  set_has_longitude();
  longitude_ = value;
}

// optional double altitude = 3;
inline bool GpsData::has_altitude() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GpsData::set_has_altitude() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GpsData::clear_has_altitude() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GpsData::clear_altitude() {
  altitude_ = 0;
  clear_has_altitude();
}
inline double GpsData::altitude() const {
  return altitude_;
}
inline void GpsData::set_altitude(double value) {
  set_has_altitude();
  altitude_ = value;
}

// -------------------------------------------------------------------

// AxisData

// optional float x = 1;
inline bool AxisData::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AxisData::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AxisData::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AxisData::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float AxisData::x() const {
  return x_;
}
inline void AxisData::set_x(float value) {
  set_has_x();
  x_ = value;
}

// optional float y = 2;
inline bool AxisData::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AxisData::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AxisData::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AxisData::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float AxisData::y() const {
  return y_;
}
inline void AxisData::set_y(float value) {
  set_has_y();
  y_ = value;
}

// optional float z = 3;
inline bool AxisData::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AxisData::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AxisData::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AxisData::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float AxisData::z() const {
  return z_;
}
inline void AxisData::set_z(float value) {
  set_has_z();
  z_ = value;
}

// -------------------------------------------------------------------

// iBeacon

// optional bytes addr = 1;
inline bool iBeacon::has_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void iBeacon::set_has_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void iBeacon::clear_has_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void iBeacon::clear_addr() {
  if (addr_ != &::google::protobuf::internal::kEmptyString) {
    addr_->clear();
  }
  clear_has_addr();
}
inline const ::std::string& iBeacon::addr() const {
  return *addr_;
}
inline void iBeacon::set_addr(const ::std::string& value) {
  set_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    addr_ = new ::std::string;
  }
  addr_->assign(value);
}
inline void iBeacon::set_addr(const char* value) {
  set_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    addr_ = new ::std::string;
  }
  addr_->assign(value);
}
inline void iBeacon::set_addr(const void* value, size_t size) {
  set_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    addr_ = new ::std::string;
  }
  addr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* iBeacon::mutable_addr() {
  set_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    addr_ = new ::std::string;
  }
  return addr_;
}
inline ::std::string* iBeacon::release_addr() {
  clear_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = addr_;
    addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void iBeacon::set_allocated_addr(::std::string* addr) {
  if (addr_ != &::google::protobuf::internal::kEmptyString) {
    delete addr_;
  }
  if (addr) {
    set_has_addr();
    addr_ = addr;
  } else {
    clear_has_addr();
    addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes umm = 2;
inline bool iBeacon::has_umm() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void iBeacon::set_has_umm() {
  _has_bits_[0] |= 0x00000002u;
}
inline void iBeacon::clear_has_umm() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void iBeacon::clear_umm() {
  if (umm_ != &::google::protobuf::internal::kEmptyString) {
    umm_->clear();
  }
  clear_has_umm();
}
inline const ::std::string& iBeacon::umm() const {
  return *umm_;
}
inline void iBeacon::set_umm(const ::std::string& value) {
  set_has_umm();
  if (umm_ == &::google::protobuf::internal::kEmptyString) {
    umm_ = new ::std::string;
  }
  umm_->assign(value);
}
inline void iBeacon::set_umm(const char* value) {
  set_has_umm();
  if (umm_ == &::google::protobuf::internal::kEmptyString) {
    umm_ = new ::std::string;
  }
  umm_->assign(value);
}
inline void iBeacon::set_umm(const void* value, size_t size) {
  set_has_umm();
  if (umm_ == &::google::protobuf::internal::kEmptyString) {
    umm_ = new ::std::string;
  }
  umm_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* iBeacon::mutable_umm() {
  set_has_umm();
  if (umm_ == &::google::protobuf::internal::kEmptyString) {
    umm_ = new ::std::string;
  }
  return umm_;
}
inline ::std::string* iBeacon::release_umm() {
  clear_has_umm();
  if (umm_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = umm_;
    umm_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void iBeacon::set_allocated_umm(::std::string* umm) {
  if (umm_ != &::google::protobuf::internal::kEmptyString) {
    delete umm_;
  }
  if (umm) {
    set_has_umm();
    umm_ = umm;
  } else {
    clear_has_umm();
    umm_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sint32 rssi = 3;
inline bool iBeacon::has_rssi() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void iBeacon::set_has_rssi() {
  _has_bits_[0] |= 0x00000004u;
}
inline void iBeacon::clear_has_rssi() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void iBeacon::clear_rssi() {
  rssi_ = 0;
  clear_has_rssi();
}
inline ::google::protobuf::int32 iBeacon::rssi() const {
  return rssi_;
}
inline void iBeacon::set_rssi(::google::protobuf::int32 value) {
  set_has_rssi();
  rssi_ = value;
}

// -------------------------------------------------------------------

// AppParam

// optional .AppCmd cmd = 1;
inline bool AppParam::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AppParam::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AppParam::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AppParam::clear_cmd() {
  cmd_ = 0;
  clear_has_cmd();
}
inline ::AppCmd AppParam::cmd() const {
  return static_cast< ::AppCmd >(cmd_);
}
inline void AppParam::set_cmd(::AppCmd value) {
  assert(::AppCmd_IsValid(value));
  set_has_cmd();
  cmd_ = value;
}

// optional uint32 uploadInterval = 2;
inline bool AppParam::has_uploadinterval() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AppParam::set_has_uploadinterval() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AppParam::clear_has_uploadinterval() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AppParam::clear_uploadinterval() {
  uploadinterval_ = 0u;
  clear_has_uploadinterval();
}
inline ::google::protobuf::uint32 AppParam::uploadinterval() const {
  return uploadinterval_;
}
inline void AppParam::set_uploadinterval(::google::protobuf::uint32 value) {
  set_has_uploadinterval();
  uploadinterval_ = value;
}

// optional uint32 syncTime = 3;
inline bool AppParam::has_synctime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AppParam::set_has_synctime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AppParam::clear_has_synctime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AppParam::clear_synctime() {
  synctime_ = 0u;
  clear_has_synctime();
}
inline ::google::protobuf::uint32 AppParam::synctime() const {
  return synctime_;
}
inline void AppParam::set_synctime(::google::protobuf::uint32 value) {
  set_has_synctime();
  synctime_ = value;
}

// optional .NodeState nodeState = 4;
inline bool AppParam::has_nodestate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AppParam::set_has_nodestate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AppParam::clear_has_nodestate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AppParam::clear_nodestate() {
  nodestate_ = 0;
  clear_has_nodestate();
}
inline ::NodeState AppParam::nodestate() const {
  return static_cast< ::NodeState >(nodestate_);
}
inline void AppParam::set_nodestate(::NodeState value) {
  assert(::NodeState_IsValid(value));
  set_has_nodestate();
  nodestate_ = value;
}

// optional .NodeAlarm nodeAlarm = 5;
inline bool AppParam::has_nodealarm() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AppParam::set_has_nodealarm() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AppParam::clear_has_nodealarm() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AppParam::clear_nodealarm() {
  nodealarm_ = 0;
  clear_has_nodealarm();
}
inline ::NodeAlarm AppParam::nodealarm() const {
  return static_cast< ::NodeAlarm >(nodealarm_);
}
inline void AppParam::set_nodealarm(::NodeAlarm value) {
  assert(::NodeAlarm_IsValid(value));
  set_has_nodealarm();
  nodealarm_ = value;
}

// optional uint32 nodeAlarmSet = 6;
inline bool AppParam::has_nodealarmset() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AppParam::set_has_nodealarmset() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AppParam::clear_has_nodealarmset() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AppParam::clear_nodealarmset() {
  nodealarmset_ = 0u;
  clear_has_nodealarmset();
}
inline ::google::protobuf::uint32 AppParam::nodealarmset() const {
  return nodealarmset_;
}
inline void AppParam::set_nodealarmset(::google::protobuf::uint32 value) {
  set_has_nodealarmset();
  nodealarmset_ = value;
}

// optional uint32 confirm = 7;
inline bool AppParam::has_confirm() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AppParam::set_has_confirm() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AppParam::clear_has_confirm() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AppParam::clear_confirm() {
  confirm_ = 0u;
  clear_has_confirm();
}
inline ::google::protobuf::uint32 AppParam::confirm() const {
  return confirm_;
}
inline void AppParam::set_confirm(::google::protobuf::uint32 value) {
  set_has_confirm();
  confirm_ = value;
}

// optional .SmokeCtrl smokeCtrl = 8;
inline bool AppParam::has_smokectrl() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AppParam::set_has_smokectrl() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AppParam::clear_has_smokectrl() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AppParam::clear_smokectrl() {
  smokectrl_ = 0;
  clear_has_smokectrl();
}
inline ::SmokeCtrl AppParam::smokectrl() const {
  return static_cast< ::SmokeCtrl >(smokectrl_);
}
inline void AppParam::set_smokectrl(::SmokeCtrl value) {
  assert(::SmokeCtrl_IsValid(value));
  set_has_smokectrl();
  smokectrl_ = value;
}

// optional uint32 uploadRepeat = 9;
inline bool AppParam::has_uploadrepeat() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AppParam::set_has_uploadrepeat() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AppParam::clear_has_uploadrepeat() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AppParam::clear_uploadrepeat() {
  uploadrepeat_ = 0u;
  clear_has_uploadrepeat();
}
inline ::google::protobuf::uint32 AppParam::uploadrepeat() const {
  return uploadrepeat_;
}
inline void AppParam::set_uploadrepeat(::google::protobuf::uint32 value) {
  set_has_uploadrepeat();
  uploadrepeat_ = value;
}

// optional uint32 alarmUploadInterval = 10;
inline bool AppParam::has_alarmuploadinterval() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AppParam::set_has_alarmuploadinterval() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AppParam::clear_has_alarmuploadinterval() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AppParam::clear_alarmuploadinterval() {
  alarmuploadinterval_ = 0u;
  clear_has_alarmuploadinterval();
}
inline ::google::protobuf::uint32 AppParam::alarmuploadinterval() const {
  return alarmuploadinterval_;
}
inline void AppParam::set_alarmuploadinterval(::google::protobuf::uint32 value) {
  set_has_alarmuploadinterval();
  alarmuploadinterval_ = value;
}

// optional uint32 alarmUploadNb = 11;
inline bool AppParam::has_alarmuploadnb() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AppParam::set_has_alarmuploadnb() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AppParam::clear_has_alarmuploadnb() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AppParam::clear_alarmuploadnb() {
  alarmuploadnb_ = 0u;
  clear_has_alarmuploadnb();
}
inline ::google::protobuf::uint32 AppParam::alarmuploadnb() const {
  return alarmuploadnb_;
}
inline void AppParam::set_alarmuploadnb(::google::protobuf::uint32 value) {
  set_has_alarmuploadnb();
  alarmuploadnb_ = value;
}

// optional .TrackerCtrl trackerCtrl = 12;
inline bool AppParam::has_trackerctrl() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void AppParam::set_has_trackerctrl() {
  _has_bits_[0] |= 0x00000800u;
}
inline void AppParam::clear_has_trackerctrl() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void AppParam::clear_trackerctrl() {
  trackerctrl_ = 0;
  clear_has_trackerctrl();
}
inline ::TrackerCtrl AppParam::trackerctrl() const {
  return static_cast< ::TrackerCtrl >(trackerctrl_);
}
inline void AppParam::set_trackerctrl(::TrackerCtrl value) {
  assert(::TrackerCtrl_IsValid(value));
  set_has_trackerctrl();
  trackerctrl_ = value;
}

// optional uint32 trackerEmergencyTime = 13;
inline bool AppParam::has_trackeremergencytime() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void AppParam::set_has_trackeremergencytime() {
  _has_bits_[0] |= 0x00001000u;
}
inline void AppParam::clear_has_trackeremergencytime() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void AppParam::clear_trackeremergencytime() {
  trackeremergencytime_ = 0u;
  clear_has_trackeremergencytime();
}
inline ::google::protobuf::uint32 AppParam::trackeremergencytime() const {
  return trackeremergencytime_;
}
inline void AppParam::set_trackeremergencytime(::google::protobuf::uint32 value) {
  set_has_trackeremergencytime();
  trackeremergencytime_ = value;
}

// -------------------------------------------------------------------

// MsgNode

// optional uint32 id = 1;
inline bool MsgNode::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgNode::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgNode::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgNode::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 MsgNode::id() const {
  return id_;
}
inline void MsgNode::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional uint32 cmd = 2;
inline bool MsgNode::has_cmd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgNode::set_has_cmd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgNode::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgNode::clear_cmd() {
  cmd_ = 0u;
  clear_has_cmd();
}
inline ::google::protobuf::uint32 MsgNode::cmd() const {
  return cmd_;
}
inline void MsgNode::set_cmd(::google::protobuf::uint32 value) {
  set_has_cmd();
  cmd_ = value;
}

// optional uint32 cmdRet = 3;
inline bool MsgNode::has_cmdret() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgNode::set_has_cmdret() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgNode::clear_has_cmdret() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgNode::clear_cmdret() {
  cmdret_ = 0u;
  clear_has_cmdret();
}
inline ::google::protobuf::uint32 MsgNode::cmdret() const {
  return cmdret_;
}
inline void MsgNode::set_cmdret(::google::protobuf::uint32 value) {
  set_has_cmdret();
  cmdret_ = value;
}

// optional .LoraParam loraParam = 4;
inline bool MsgNode::has_loraparam() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgNode::set_has_loraparam() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgNode::clear_has_loraparam() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgNode::clear_loraparam() {
  if (loraparam_ != NULL) loraparam_->::LoraParam::Clear();
  clear_has_loraparam();
}
inline const ::LoraParam& MsgNode::loraparam() const {
  return loraparam_ != NULL ? *loraparam_ : *default_instance_->loraparam_;
}
inline ::LoraParam* MsgNode::mutable_loraparam() {
  set_has_loraparam();
  if (loraparam_ == NULL) loraparam_ = new ::LoraParam;
  return loraparam_;
}
inline ::LoraParam* MsgNode::release_loraparam() {
  clear_has_loraparam();
  ::LoraParam* temp = loraparam_;
  loraparam_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_loraparam(::LoraParam* loraparam) {
  delete loraparam_;
  loraparam_ = loraparam;
  if (loraparam) {
    set_has_loraparam();
  } else {
    clear_has_loraparam();
  }
}

// optional .BleParam bleParam = 5;
inline bool MsgNode::has_bleparam() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MsgNode::set_has_bleparam() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MsgNode::clear_has_bleparam() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MsgNode::clear_bleparam() {
  if (bleparam_ != NULL) bleparam_->::BleParam::Clear();
  clear_has_bleparam();
}
inline const ::BleParam& MsgNode::bleparam() const {
  return bleparam_ != NULL ? *bleparam_ : *default_instance_->bleparam_;
}
inline ::BleParam* MsgNode::mutable_bleparam() {
  set_has_bleparam();
  if (bleparam_ == NULL) bleparam_ = new ::BleParam;
  return bleparam_;
}
inline ::BleParam* MsgNode::release_bleparam() {
  clear_has_bleparam();
  ::BleParam* temp = bleparam_;
  bleparam_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_bleparam(::BleParam* bleparam) {
  delete bleparam_;
  bleparam_ = bleparam;
  if (bleparam) {
    set_has_bleparam();
  } else {
    clear_has_bleparam();
  }
}

// optional .AppParam appParam = 6;
inline bool MsgNode::has_appparam() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MsgNode::set_has_appparam() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MsgNode::clear_has_appparam() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MsgNode::clear_appparam() {
  if (appparam_ != NULL) appparam_->::AppParam::Clear();
  clear_has_appparam();
}
inline const ::AppParam& MsgNode::appparam() const {
  return appparam_ != NULL ? *appparam_ : *default_instance_->appparam_;
}
inline ::AppParam* MsgNode::mutable_appparam() {
  set_has_appparam();
  if (appparam_ == NULL) appparam_ = new ::AppParam;
  return appparam_;
}
inline ::AppParam* MsgNode::release_appparam() {
  clear_has_appparam();
  ::AppParam* temp = appparam_;
  appparam_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_appparam(::AppParam* appparam) {
  delete appparam_;
  appparam_ = appparam;
  if (appparam) {
    set_has_appparam();
  } else {
    clear_has_appparam();
  }
}

// optional sint32 battery = 7;
inline bool MsgNode::has_battery() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MsgNode::set_has_battery() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MsgNode::clear_has_battery() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MsgNode::clear_battery() {
  battery_ = 0;
  clear_has_battery();
}
inline ::google::protobuf::int32 MsgNode::battery() const {
  return battery_;
}
inline void MsgNode::set_battery(::google::protobuf::int32 value) {
  set_has_battery();
  battery_ = value;
}

// optional .GpsData gps = 8;
inline bool MsgNode::has_gps() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MsgNode::set_has_gps() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MsgNode::clear_has_gps() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MsgNode::clear_gps() {
  if (gps_ != NULL) gps_->::GpsData::Clear();
  clear_has_gps();
}
inline const ::GpsData& MsgNode::gps() const {
  return gps_ != NULL ? *gps_ : *default_instance_->gps_;
}
inline ::GpsData* MsgNode::mutable_gps() {
  set_has_gps();
  if (gps_ == NULL) gps_ = new ::GpsData;
  return gps_;
}
inline ::GpsData* MsgNode::release_gps() {
  clear_has_gps();
  ::GpsData* temp = gps_;
  gps_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_gps(::GpsData* gps) {
  delete gps_;
  gps_ = gps;
  if (gps) {
    set_has_gps();
  } else {
    clear_has_gps();
  }
}

// optional .AxisData acceleration = 9;
inline bool MsgNode::has_acceleration() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MsgNode::set_has_acceleration() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MsgNode::clear_has_acceleration() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MsgNode::clear_acceleration() {
  if (acceleration_ != NULL) acceleration_->::AxisData::Clear();
  clear_has_acceleration();
}
inline const ::AxisData& MsgNode::acceleration() const {
  return acceleration_ != NULL ? *acceleration_ : *default_instance_->acceleration_;
}
inline ::AxisData* MsgNode::mutable_acceleration() {
  set_has_acceleration();
  if (acceleration_ == NULL) acceleration_ = new ::AxisData;
  return acceleration_;
}
inline ::AxisData* MsgNode::release_acceleration() {
  clear_has_acceleration();
  ::AxisData* temp = acceleration_;
  acceleration_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_acceleration(::AxisData* acceleration) {
  delete acceleration_;
  acceleration_ = acceleration;
  if (acceleration) {
    set_has_acceleration();
  } else {
    clear_has_acceleration();
  }
}

// optional .AxisData magnetism = 10;
inline bool MsgNode::has_magnetism() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MsgNode::set_has_magnetism() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MsgNode::clear_has_magnetism() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MsgNode::clear_magnetism() {
  if (magnetism_ != NULL) magnetism_->::AxisData::Clear();
  clear_has_magnetism();
}
inline const ::AxisData& MsgNode::magnetism() const {
  return magnetism_ != NULL ? *magnetism_ : *default_instance_->magnetism_;
}
inline ::AxisData* MsgNode::mutable_magnetism() {
  set_has_magnetism();
  if (magnetism_ == NULL) magnetism_ = new ::AxisData;
  return magnetism_;
}
inline ::AxisData* MsgNode::release_magnetism() {
  clear_has_magnetism();
  ::AxisData* temp = magnetism_;
  magnetism_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_magnetism(::AxisData* magnetism) {
  delete magnetism_;
  magnetism_ = magnetism;
  if (magnetism) {
    set_has_magnetism();
  } else {
    clear_has_magnetism();
  }
}

// optional .AxisData gyroscope = 11;
inline bool MsgNode::has_gyroscope() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MsgNode::set_has_gyroscope() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MsgNode::clear_has_gyroscope() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MsgNode::clear_gyroscope() {
  if (gyroscope_ != NULL) gyroscope_->::AxisData::Clear();
  clear_has_gyroscope();
}
inline const ::AxisData& MsgNode::gyroscope() const {
  return gyroscope_ != NULL ? *gyroscope_ : *default_instance_->gyroscope_;
}
inline ::AxisData* MsgNode::mutable_gyroscope() {
  set_has_gyroscope();
  if (gyroscope_ == NULL) gyroscope_ = new ::AxisData;
  return gyroscope_;
}
inline ::AxisData* MsgNode::release_gyroscope() {
  clear_has_gyroscope();
  ::AxisData* temp = gyroscope_;
  gyroscope_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_gyroscope(::AxisData* gyroscope) {
  delete gyroscope_;
  gyroscope_ = gyroscope;
  if (gyroscope) {
    set_has_gyroscope();
  } else {
    clear_has_gyroscope();
  }
}

// optional .SensorData temperature = 12;
inline bool MsgNode::has_temperature() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MsgNode::set_has_temperature() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MsgNode::clear_has_temperature() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MsgNode::clear_temperature() {
  if (temperature_ != NULL) temperature_->::SensorData::Clear();
  clear_has_temperature();
}
inline const ::SensorData& MsgNode::temperature() const {
  return temperature_ != NULL ? *temperature_ : *default_instance_->temperature_;
}
inline ::SensorData* MsgNode::mutable_temperature() {
  set_has_temperature();
  if (temperature_ == NULL) temperature_ = new ::SensorData;
  return temperature_;
}
inline ::SensorData* MsgNode::release_temperature() {
  clear_has_temperature();
  ::SensorData* temp = temperature_;
  temperature_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_temperature(::SensorData* temperature) {
  delete temperature_;
  temperature_ = temperature;
  if (temperature) {
    set_has_temperature();
  } else {
    clear_has_temperature();
  }
}

// optional .SensorData humidity = 13;
inline bool MsgNode::has_humidity() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MsgNode::set_has_humidity() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MsgNode::clear_has_humidity() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MsgNode::clear_humidity() {
  if (humidity_ != NULL) humidity_->::SensorData::Clear();
  clear_has_humidity();
}
inline const ::SensorData& MsgNode::humidity() const {
  return humidity_ != NULL ? *humidity_ : *default_instance_->humidity_;
}
inline ::SensorData* MsgNode::mutable_humidity() {
  set_has_humidity();
  if (humidity_ == NULL) humidity_ = new ::SensorData;
  return humidity_;
}
inline ::SensorData* MsgNode::release_humidity() {
  clear_has_humidity();
  ::SensorData* temp = humidity_;
  humidity_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_humidity(::SensorData* humidity) {
  delete humidity_;
  humidity_ = humidity;
  if (humidity) {
    set_has_humidity();
  } else {
    clear_has_humidity();
  }
}

// optional .SensorData light = 14;
inline bool MsgNode::has_light() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MsgNode::set_has_light() {
  _has_bits_[0] |= 0x00002000u;
}
inline void MsgNode::clear_has_light() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void MsgNode::clear_light() {
  if (light_ != NULL) light_->::SensorData::Clear();
  clear_has_light();
}
inline const ::SensorData& MsgNode::light() const {
  return light_ != NULL ? *light_ : *default_instance_->light_;
}
inline ::SensorData* MsgNode::mutable_light() {
  set_has_light();
  if (light_ == NULL) light_ = new ::SensorData;
  return light_;
}
inline ::SensorData* MsgNode::release_light() {
  clear_has_light();
  ::SensorData* temp = light_;
  light_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_light(::SensorData* light) {
  delete light_;
  light_ = light;
  if (light) {
    set_has_light();
  } else {
    clear_has_light();
  }
}

// optional .SensorData leak = 15;
inline bool MsgNode::has_leak() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void MsgNode::set_has_leak() {
  _has_bits_[0] |= 0x00004000u;
}
inline void MsgNode::clear_has_leak() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void MsgNode::clear_leak() {
  if (leak_ != NULL) leak_->::SensorData::Clear();
  clear_has_leak();
}
inline const ::SensorData& MsgNode::leak() const {
  return leak_ != NULL ? *leak_ : *default_instance_->leak_;
}
inline ::SensorData* MsgNode::mutable_leak() {
  set_has_leak();
  if (leak_ == NULL) leak_ = new ::SensorData;
  return leak_;
}
inline ::SensorData* MsgNode::release_leak() {
  clear_has_leak();
  ::SensorData* temp = leak_;
  leak_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_leak(::SensorData* leak) {
  delete leak_;
  leak_ = leak;
  if (leak) {
    set_has_leak();
  } else {
    clear_has_leak();
  }
}

// optional .SensorData co = 16;
inline bool MsgNode::has_co() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void MsgNode::set_has_co() {
  _has_bits_[0] |= 0x00008000u;
}
inline void MsgNode::clear_has_co() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void MsgNode::clear_co() {
  if (co_ != NULL) co_->::SensorData::Clear();
  clear_has_co();
}
inline const ::SensorData& MsgNode::co() const {
  return co_ != NULL ? *co_ : *default_instance_->co_;
}
inline ::SensorData* MsgNode::mutable_co() {
  set_has_co();
  if (co_ == NULL) co_ = new ::SensorData;
  return co_;
}
inline ::SensorData* MsgNode::release_co() {
  clear_has_co();
  ::SensorData* temp = co_;
  co_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_co(::SensorData* co) {
  delete co_;
  co_ = co;
  if (co) {
    set_has_co();
  } else {
    clear_has_co();
  }
}

// optional .SensorData co2 = 17;
inline bool MsgNode::has_co2() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void MsgNode::set_has_co2() {
  _has_bits_[0] |= 0x00010000u;
}
inline void MsgNode::clear_has_co2() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void MsgNode::clear_co2() {
  if (co2_ != NULL) co2_->::SensorData::Clear();
  clear_has_co2();
}
inline const ::SensorData& MsgNode::co2() const {
  return co2_ != NULL ? *co2_ : *default_instance_->co2_;
}
inline ::SensorData* MsgNode::mutable_co2() {
  set_has_co2();
  if (co2_ == NULL) co2_ = new ::SensorData;
  return co2_;
}
inline ::SensorData* MsgNode::release_co2() {
  clear_has_co2();
  ::SensorData* temp = co2_;
  co2_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_co2(::SensorData* co2) {
  delete co2_;
  co2_ = co2;
  if (co2) {
    set_has_co2();
  } else {
    clear_has_co2();
  }
}

// optional .SensorData so2 = 18;
inline bool MsgNode::has_so2() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void MsgNode::set_has_so2() {
  _has_bits_[0] |= 0x00020000u;
}
inline void MsgNode::clear_has_so2() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void MsgNode::clear_so2() {
  if (so2_ != NULL) so2_->::SensorData::Clear();
  clear_has_so2();
}
inline const ::SensorData& MsgNode::so2() const {
  return so2_ != NULL ? *so2_ : *default_instance_->so2_;
}
inline ::SensorData* MsgNode::mutable_so2() {
  set_has_so2();
  if (so2_ == NULL) so2_ = new ::SensorData;
  return so2_;
}
inline ::SensorData* MsgNode::release_so2() {
  clear_has_so2();
  ::SensorData* temp = so2_;
  so2_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_so2(::SensorData* so2) {
  delete so2_;
  so2_ = so2;
  if (so2) {
    set_has_so2();
  } else {
    clear_has_so2();
  }
}

// optional .SensorData no2 = 19;
inline bool MsgNode::has_no2() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void MsgNode::set_has_no2() {
  _has_bits_[0] |= 0x00040000u;
}
inline void MsgNode::clear_has_no2() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void MsgNode::clear_no2() {
  if (no2_ != NULL) no2_->::SensorData::Clear();
  clear_has_no2();
}
inline const ::SensorData& MsgNode::no2() const {
  return no2_ != NULL ? *no2_ : *default_instance_->no2_;
}
inline ::SensorData* MsgNode::mutable_no2() {
  set_has_no2();
  if (no2_ == NULL) no2_ = new ::SensorData;
  return no2_;
}
inline ::SensorData* MsgNode::release_no2() {
  clear_has_no2();
  ::SensorData* temp = no2_;
  no2_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_no2(::SensorData* no2) {
  delete no2_;
  no2_ = no2;
  if (no2) {
    set_has_no2();
  } else {
    clear_has_no2();
  }
}

// optional .SensorData ch4 = 20;
inline bool MsgNode::has_ch4() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void MsgNode::set_has_ch4() {
  _has_bits_[0] |= 0x00080000u;
}
inline void MsgNode::clear_has_ch4() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void MsgNode::clear_ch4() {
  if (ch4_ != NULL) ch4_->::SensorData::Clear();
  clear_has_ch4();
}
inline const ::SensorData& MsgNode::ch4() const {
  return ch4_ != NULL ? *ch4_ : *default_instance_->ch4_;
}
inline ::SensorData* MsgNode::mutable_ch4() {
  set_has_ch4();
  if (ch4_ == NULL) ch4_ = new ::SensorData;
  return ch4_;
}
inline ::SensorData* MsgNode::release_ch4() {
  clear_has_ch4();
  ::SensorData* temp = ch4_;
  ch4_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_ch4(::SensorData* ch4) {
  delete ch4_;
  ch4_ = ch4;
  if (ch4) {
    set_has_ch4();
  } else {
    clear_has_ch4();
  }
}

// optional .SensorData ch2o = 21;
inline bool MsgNode::has_ch2o() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void MsgNode::set_has_ch2o() {
  _has_bits_[0] |= 0x00100000u;
}
inline void MsgNode::clear_has_ch2o() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void MsgNode::clear_ch2o() {
  if (ch2o_ != NULL) ch2o_->::SensorData::Clear();
  clear_has_ch2o();
}
inline const ::SensorData& MsgNode::ch2o() const {
  return ch2o_ != NULL ? *ch2o_ : *default_instance_->ch2o_;
}
inline ::SensorData* MsgNode::mutable_ch2o() {
  set_has_ch2o();
  if (ch2o_ == NULL) ch2o_ = new ::SensorData;
  return ch2o_;
}
inline ::SensorData* MsgNode::release_ch2o() {
  clear_has_ch2o();
  ::SensorData* temp = ch2o_;
  ch2o_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_ch2o(::SensorData* ch2o) {
  delete ch2o_;
  ch2o_ = ch2o;
  if (ch2o) {
    set_has_ch2o();
  } else {
    clear_has_ch2o();
  }
}

// optional .SensorData lpg = 22;
inline bool MsgNode::has_lpg() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void MsgNode::set_has_lpg() {
  _has_bits_[0] |= 0x00200000u;
}
inline void MsgNode::clear_has_lpg() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void MsgNode::clear_lpg() {
  if (lpg_ != NULL) lpg_->::SensorData::Clear();
  clear_has_lpg();
}
inline const ::SensorData& MsgNode::lpg() const {
  return lpg_ != NULL ? *lpg_ : *default_instance_->lpg_;
}
inline ::SensorData* MsgNode::mutable_lpg() {
  set_has_lpg();
  if (lpg_ == NULL) lpg_ = new ::SensorData;
  return lpg_;
}
inline ::SensorData* MsgNode::release_lpg() {
  clear_has_lpg();
  ::SensorData* temp = lpg_;
  lpg_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_lpg(::SensorData* lpg) {
  delete lpg_;
  lpg_ = lpg;
  if (lpg) {
    set_has_lpg();
  } else {
    clear_has_lpg();
  }
}

// optional .SensorData o3 = 23;
inline bool MsgNode::has_o3() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void MsgNode::set_has_o3() {
  _has_bits_[0] |= 0x00400000u;
}
inline void MsgNode::clear_has_o3() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void MsgNode::clear_o3() {
  if (o3_ != NULL) o3_->::SensorData::Clear();
  clear_has_o3();
}
inline const ::SensorData& MsgNode::o3() const {
  return o3_ != NULL ? *o3_ : *default_instance_->o3_;
}
inline ::SensorData* MsgNode::mutable_o3() {
  set_has_o3();
  if (o3_ == NULL) o3_ = new ::SensorData;
  return o3_;
}
inline ::SensorData* MsgNode::release_o3() {
  clear_has_o3();
  ::SensorData* temp = o3_;
  o3_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_o3(::SensorData* o3) {
  delete o3_;
  o3_ = o3;
  if (o3) {
    set_has_o3();
  } else {
    clear_has_o3();
  }
}

// optional .SensorData pm1 = 24;
inline bool MsgNode::has_pm1() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void MsgNode::set_has_pm1() {
  _has_bits_[0] |= 0x00800000u;
}
inline void MsgNode::clear_has_pm1() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void MsgNode::clear_pm1() {
  if (pm1_ != NULL) pm1_->::SensorData::Clear();
  clear_has_pm1();
}
inline const ::SensorData& MsgNode::pm1() const {
  return pm1_ != NULL ? *pm1_ : *default_instance_->pm1_;
}
inline ::SensorData* MsgNode::mutable_pm1() {
  set_has_pm1();
  if (pm1_ == NULL) pm1_ = new ::SensorData;
  return pm1_;
}
inline ::SensorData* MsgNode::release_pm1() {
  clear_has_pm1();
  ::SensorData* temp = pm1_;
  pm1_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_pm1(::SensorData* pm1) {
  delete pm1_;
  pm1_ = pm1;
  if (pm1) {
    set_has_pm1();
  } else {
    clear_has_pm1();
  }
}

// optional .SensorData pm2_5 = 25;
inline bool MsgNode::has_pm2_5() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void MsgNode::set_has_pm2_5() {
  _has_bits_[0] |= 0x01000000u;
}
inline void MsgNode::clear_has_pm2_5() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void MsgNode::clear_pm2_5() {
  if (pm2_5_ != NULL) pm2_5_->::SensorData::Clear();
  clear_has_pm2_5();
}
inline const ::SensorData& MsgNode::pm2_5() const {
  return pm2_5_ != NULL ? *pm2_5_ : *default_instance_->pm2_5_;
}
inline ::SensorData* MsgNode::mutable_pm2_5() {
  set_has_pm2_5();
  if (pm2_5_ == NULL) pm2_5_ = new ::SensorData;
  return pm2_5_;
}
inline ::SensorData* MsgNode::release_pm2_5() {
  clear_has_pm2_5();
  ::SensorData* temp = pm2_5_;
  pm2_5_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_pm2_5(::SensorData* pm2_5) {
  delete pm2_5_;
  pm2_5_ = pm2_5;
  if (pm2_5) {
    set_has_pm2_5();
  } else {
    clear_has_pm2_5();
  }
}

// optional .SensorData pm10 = 26;
inline bool MsgNode::has_pm10() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void MsgNode::set_has_pm10() {
  _has_bits_[0] |= 0x02000000u;
}
inline void MsgNode::clear_has_pm10() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void MsgNode::clear_pm10() {
  if (pm10_ != NULL) pm10_->::SensorData::Clear();
  clear_has_pm10();
}
inline const ::SensorData& MsgNode::pm10() const {
  return pm10_ != NULL ? *pm10_ : *default_instance_->pm10_;
}
inline ::SensorData* MsgNode::mutable_pm10() {
  set_has_pm10();
  if (pm10_ == NULL) pm10_ = new ::SensorData;
  return pm10_;
}
inline ::SensorData* MsgNode::release_pm10() {
  clear_has_pm10();
  ::SensorData* temp = pm10_;
  pm10_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_pm10(::SensorData* pm10) {
  delete pm10_;
  pm10_ = pm10;
  if (pm10) {
    set_has_pm10();
  } else {
    clear_has_pm10();
  }
}

// optional .SensorData angle = 27;
inline bool MsgNode::has_angle() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void MsgNode::set_has_angle() {
  _has_bits_[0] |= 0x04000000u;
}
inline void MsgNode::clear_has_angle() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void MsgNode::clear_angle() {
  if (angle_ != NULL) angle_->::SensorData::Clear();
  clear_has_angle();
}
inline const ::SensorData& MsgNode::angle() const {
  return angle_ != NULL ? *angle_ : *default_instance_->angle_;
}
inline ::SensorData* MsgNode::mutable_angle() {
  set_has_angle();
  if (angle_ == NULL) angle_ = new ::SensorData;
  return angle_;
}
inline ::SensorData* MsgNode::release_angle() {
  clear_has_angle();
  ::SensorData* temp = angle_;
  angle_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_angle(::SensorData* angle) {
  delete angle_;
  angle_ = angle;
  if (angle) {
    set_has_angle();
  } else {
    clear_has_angle();
  }
}

// optional .SensorData cover = 28;
inline bool MsgNode::has_cover() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void MsgNode::set_has_cover() {
  _has_bits_[0] |= 0x08000000u;
}
inline void MsgNode::clear_has_cover() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void MsgNode::clear_cover() {
  if (cover_ != NULL) cover_->::SensorData::Clear();
  clear_has_cover();
}
inline const ::SensorData& MsgNode::cover() const {
  return cover_ != NULL ? *cover_ : *default_instance_->cover_;
}
inline ::SensorData* MsgNode::mutable_cover() {
  set_has_cover();
  if (cover_ == NULL) cover_ = new ::SensorData;
  return cover_;
}
inline ::SensorData* MsgNode::release_cover() {
  clear_has_cover();
  ::SensorData* temp = cover_;
  cover_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_cover(::SensorData* cover) {
  delete cover_;
  cover_ = cover;
  if (cover) {
    set_has_cover();
  } else {
    clear_has_cover();
  }
}

// optional .SensorData level = 29;
inline bool MsgNode::has_level() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void MsgNode::set_has_level() {
  _has_bits_[0] |= 0x10000000u;
}
inline void MsgNode::clear_has_level() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void MsgNode::clear_level() {
  if (level_ != NULL) level_->::SensorData::Clear();
  clear_has_level();
}
inline const ::SensorData& MsgNode::level() const {
  return level_ != NULL ? *level_ : *default_instance_->level_;
}
inline ::SensorData* MsgNode::mutable_level() {
  set_has_level();
  if (level_ == NULL) level_ = new ::SensorData;
  return level_;
}
inline ::SensorData* MsgNode::release_level() {
  clear_has_level();
  ::SensorData* temp = level_;
  level_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_level(::SensorData* level) {
  delete level_;
  level_ = level;
  if (level) {
    set_has_level();
  } else {
    clear_has_level();
  }
}

// optional .SensorData smoke = 30;
inline bool MsgNode::has_smoke() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void MsgNode::set_has_smoke() {
  _has_bits_[0] |= 0x20000000u;
}
inline void MsgNode::clear_has_smoke() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void MsgNode::clear_smoke() {
  if (smoke_ != NULL) smoke_->::SensorData::Clear();
  clear_has_smoke();
}
inline const ::SensorData& MsgNode::smoke() const {
  return smoke_ != NULL ? *smoke_ : *default_instance_->smoke_;
}
inline ::SensorData* MsgNode::mutable_smoke() {
  set_has_smoke();
  if (smoke_ == NULL) smoke_ = new ::SensorData;
  return smoke_;
}
inline ::SensorData* MsgNode::release_smoke() {
  clear_has_smoke();
  ::SensorData* temp = smoke_;
  smoke_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_smoke(::SensorData* smoke) {
  delete smoke_;
  smoke_ = smoke;
  if (smoke) {
    set_has_smoke();
  } else {
    clear_has_smoke();
  }
}

// optional .SensorData pitch = 31;
inline bool MsgNode::has_pitch() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void MsgNode::set_has_pitch() {
  _has_bits_[0] |= 0x40000000u;
}
inline void MsgNode::clear_has_pitch() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void MsgNode::clear_pitch() {
  if (pitch_ != NULL) pitch_->::SensorData::Clear();
  clear_has_pitch();
}
inline const ::SensorData& MsgNode::pitch() const {
  return pitch_ != NULL ? *pitch_ : *default_instance_->pitch_;
}
inline ::SensorData* MsgNode::mutable_pitch() {
  set_has_pitch();
  if (pitch_ == NULL) pitch_ = new ::SensorData;
  return pitch_;
}
inline ::SensorData* MsgNode::release_pitch() {
  clear_has_pitch();
  ::SensorData* temp = pitch_;
  pitch_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_pitch(::SensorData* pitch) {
  delete pitch_;
  pitch_ = pitch;
  if (pitch) {
    set_has_pitch();
  } else {
    clear_has_pitch();
  }
}

// optional .SensorData roll = 32;
inline bool MsgNode::has_roll() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void MsgNode::set_has_roll() {
  _has_bits_[0] |= 0x80000000u;
}
inline void MsgNode::clear_has_roll() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void MsgNode::clear_roll() {
  if (roll_ != NULL) roll_->::SensorData::Clear();
  clear_has_roll();
}
inline const ::SensorData& MsgNode::roll() const {
  return roll_ != NULL ? *roll_ : *default_instance_->roll_;
}
inline ::SensorData* MsgNode::mutable_roll() {
  set_has_roll();
  if (roll_ == NULL) roll_ = new ::SensorData;
  return roll_;
}
inline ::SensorData* MsgNode::release_roll() {
  clear_has_roll();
  ::SensorData* temp = roll_;
  roll_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_roll(::SensorData* roll) {
  delete roll_;
  roll_ = roll;
  if (roll) {
    set_has_roll();
  } else {
    clear_has_roll();
  }
}

// optional .SensorData yaw = 33;
inline bool MsgNode::has_yaw() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void MsgNode::set_has_yaw() {
  _has_bits_[1] |= 0x00000001u;
}
inline void MsgNode::clear_has_yaw() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void MsgNode::clear_yaw() {
  if (yaw_ != NULL) yaw_->::SensorData::Clear();
  clear_has_yaw();
}
inline const ::SensorData& MsgNode::yaw() const {
  return yaw_ != NULL ? *yaw_ : *default_instance_->yaw_;
}
inline ::SensorData* MsgNode::mutable_yaw() {
  set_has_yaw();
  if (yaw_ == NULL) yaw_ = new ::SensorData;
  return yaw_;
}
inline ::SensorData* MsgNode::release_yaw() {
  clear_has_yaw();
  ::SensorData* temp = yaw_;
  yaw_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_yaw(::SensorData* yaw) {
  delete yaw_;
  yaw_ = yaw;
  if (yaw) {
    set_has_yaw();
  } else {
    clear_has_yaw();
  }
}

// optional .SensorDataInt flame = 34;
inline bool MsgNode::has_flame() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void MsgNode::set_has_flame() {
  _has_bits_[1] |= 0x00000002u;
}
inline void MsgNode::clear_has_flame() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void MsgNode::clear_flame() {
  if (flame_ != NULL) flame_->::SensorDataInt::Clear();
  clear_has_flame();
}
inline const ::SensorDataInt& MsgNode::flame() const {
  return flame_ != NULL ? *flame_ : *default_instance_->flame_;
}
inline ::SensorDataInt* MsgNode::mutable_flame() {
  set_has_flame();
  if (flame_ == NULL) flame_ = new ::SensorDataInt;
  return flame_;
}
inline ::SensorDataInt* MsgNode::release_flame() {
  clear_has_flame();
  ::SensorDataInt* temp = flame_;
  flame_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_flame(::SensorDataInt* flame) {
  delete flame_;
  flame_ = flame;
  if (flame) {
    set_has_flame();
  } else {
    clear_has_flame();
  }
}

// optional .SensorData artificialGas = 35;
inline bool MsgNode::has_artificialgas() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void MsgNode::set_has_artificialgas() {
  _has_bits_[1] |= 0x00000004u;
}
inline void MsgNode::clear_has_artificialgas() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void MsgNode::clear_artificialgas() {
  if (artificialgas_ != NULL) artificialgas_->::SensorData::Clear();
  clear_has_artificialgas();
}
inline const ::SensorData& MsgNode::artificialgas() const {
  return artificialgas_ != NULL ? *artificialgas_ : *default_instance_->artificialgas_;
}
inline ::SensorData* MsgNode::mutable_artificialgas() {
  set_has_artificialgas();
  if (artificialgas_ == NULL) artificialgas_ = new ::SensorData;
  return artificialgas_;
}
inline ::SensorData* MsgNode::release_artificialgas() {
  clear_has_artificialgas();
  ::SensorData* temp = artificialgas_;
  artificialgas_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_artificialgas(::SensorData* artificialgas) {
  delete artificialgas_;
  artificialgas_ = artificialgas;
  if (artificialgas) {
    set_has_artificialgas();
  } else {
    clear_has_artificialgas();
  }
}

// optional .MultiSensorDataInt multiTemp = 36;
inline bool MsgNode::has_multitemp() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void MsgNode::set_has_multitemp() {
  _has_bits_[1] |= 0x00000008u;
}
inline void MsgNode::clear_has_multitemp() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void MsgNode::clear_multitemp() {
  if (multitemp_ != NULL) multitemp_->::MultiSensorDataInt::Clear();
  clear_has_multitemp();
}
inline const ::MultiSensorDataInt& MsgNode::multitemp() const {
  return multitemp_ != NULL ? *multitemp_ : *default_instance_->multitemp_;
}
inline ::MultiSensorDataInt* MsgNode::mutable_multitemp() {
  set_has_multitemp();
  if (multitemp_ == NULL) multitemp_ = new ::MultiSensorDataInt;
  return multitemp_;
}
inline ::MultiSensorDataInt* MsgNode::release_multitemp() {
  clear_has_multitemp();
  ::MultiSensorDataInt* temp = multitemp_;
  multitemp_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_multitemp(::MultiSensorDataInt* multitemp) {
  delete multitemp_;
  multitemp_ = multitemp;
  if (multitemp) {
    set_has_multitemp();
  } else {
    clear_has_multitemp();
  }
}

// optional .SensorData waterPressure = 37;
inline bool MsgNode::has_waterpressure() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void MsgNode::set_has_waterpressure() {
  _has_bits_[1] |= 0x00000010u;
}
inline void MsgNode::clear_has_waterpressure() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void MsgNode::clear_waterpressure() {
  if (waterpressure_ != NULL) waterpressure_->::SensorData::Clear();
  clear_has_waterpressure();
}
inline const ::SensorData& MsgNode::waterpressure() const {
  return waterpressure_ != NULL ? *waterpressure_ : *default_instance_->waterpressure_;
}
inline ::SensorData* MsgNode::mutable_waterpressure() {
  set_has_waterpressure();
  if (waterpressure_ == NULL) waterpressure_ = new ::SensorData;
  return waterpressure_;
}
inline ::SensorData* MsgNode::release_waterpressure() {
  clear_has_waterpressure();
  ::SensorData* temp = waterpressure_;
  waterpressure_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_waterpressure(::SensorData* waterpressure) {
  delete waterpressure_;
  waterpressure_ = waterpressure;
  if (waterpressure) {
    set_has_waterpressure();
  } else {
    clear_has_waterpressure();
  }
}

// optional .iBeacon ibeacon = 38;
inline bool MsgNode::has_ibeacon() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void MsgNode::set_has_ibeacon() {
  _has_bits_[1] |= 0x00000020u;
}
inline void MsgNode::clear_has_ibeacon() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void MsgNode::clear_ibeacon() {
  if (ibeacon_ != NULL) ibeacon_->::iBeacon::Clear();
  clear_has_ibeacon();
}
inline const ::iBeacon& MsgNode::ibeacon() const {
  return ibeacon_ != NULL ? *ibeacon_ : *default_instance_->ibeacon_;
}
inline ::iBeacon* MsgNode::mutable_ibeacon() {
  set_has_ibeacon();
  if (ibeacon_ == NULL) ibeacon_ = new ::iBeacon;
  return ibeacon_;
}
inline ::iBeacon* MsgNode::release_ibeacon() {
  clear_has_ibeacon();
  ::iBeacon* temp = ibeacon_;
  ibeacon_ = NULL;
  return temp;
}
inline void MsgNode::set_allocated_ibeacon(::iBeacon* ibeacon) {
  delete ibeacon_;
  ibeacon_ = ibeacon;
  if (ibeacon) {
    set_has_ibeacon();
  } else {
    clear_has_ibeacon();
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Activtion>() {
  return ::Activtion_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ClassType>() {
  return ::ClassType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SensorError>() {
  return ::SensorError_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SensorType>() {
  return ::SensorType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SensorStatus>() {
  return ::SensorStatus_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AppCmd>() {
  return ::AppCmd_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NodeState>() {
  return ::NodeState_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NodeAlarm>() {
  return ::NodeAlarm_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SmokeCtrl>() {
  return ::SmokeCtrl_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TrackerCtrl>() {
  return ::TrackerCtrl_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_MsgNode_5f1v1_5fm8_2eproto__INCLUDED
