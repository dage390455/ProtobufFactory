// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MsgNode_1v1_m22.proto

#include "MsgNode_1v1_m22.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_MsgNode_5f1v1_5fm22_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AcrelData_MsgNode_5f1v1_5fm22_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_MsgNode_5f1v1_5fm22_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AppParam_MsgNode_5f1v1_5fm22_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_MsgNode_5f1v1_5fm22_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AxisData_MsgNode_5f1v1_5fm22_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_MsgNode_5f1v1_5fm22_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Baymax_MsgNode_5f1v1_5fm22_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_MsgNode_5f1v1_5fm22_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_BleParam_MsgNode_5f1v1_5fm22_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_MsgNode_5f1v1_5fm22_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Cayman_MsgNode_5f1v1_5fm22_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_MsgNode_5f1v1_5fm22_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Channel_MsgNode_5f1v1_5fm22_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_MsgNode_5f1v1_5fm22_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ElecFireData_MsgNode_5f1v1_5fm22_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_MsgNode_5f1v1_5fm22_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ExtSmoke_MsgNode_5f1v1_5fm22_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_MsgNode_5f1v1_5fm22_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_GpsData_MsgNode_5f1v1_5fm22_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_MsgNode_5f1v1_5fm22_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_LpwanParam_MsgNode_5f1v1_5fm22_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_MsgNode_5f1v1_5fm22_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_MantunData_MsgNode_5f1v1_5fm22_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_MsgNode_5f1v1_5fm22_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_MultiSensorDataInt_MsgNode_5f1v1_5fm22_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_MsgNode_5f1v1_5fm22_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_SensorData_MsgNode_5f1v1_5fm22_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_MsgNode_5f1v1_5fm22_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_SensorDataInt_MsgNode_5f1v1_5fm22_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_MsgNode_5f1v1_5fm22_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_iBeacon_MsgNode_5f1v1_5fm22_2eproto;
class ChannelDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Channel> _instance;
} _Channel_default_instance_;
class LpwanParamDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<LpwanParam> _instance;
} _LpwanParam_default_instance_;
class BleParamDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<BleParam> _instance;
} _BleParam_default_instance_;
class SensorDataDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<SensorData> _instance;
} _SensorData_default_instance_;
class SensorDataIntDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<SensorDataInt> _instance;
} _SensorDataInt_default_instance_;
class SensorDataFloatDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<SensorDataFloat> _instance;
} _SensorDataFloat_default_instance_;
class MultiSensorDataDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<MultiSensorData> _instance;
} _MultiSensorData_default_instance_;
class MultiSensorDataIntDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<MultiSensorDataInt> _instance;
} _MultiSensorDataInt_default_instance_;
class GpsDataDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<GpsData> _instance;
} _GpsData_default_instance_;
class AxisDataDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AxisData> _instance;
} _AxisData_default_instance_;
class iBeaconDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<iBeacon> _instance;
} _iBeacon_default_instance_;
class ExtSmokeDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ExtSmoke> _instance;
} _ExtSmoke_default_instance_;
class AppParamDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AppParam> _instance;
} _AppParam_default_instance_;
class ElecFireDataDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ElecFireData> _instance;
} _ElecFireData_default_instance_;
class MantunDataDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<MantunData> _instance;
} _MantunData_default_instance_;
class CaymanDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Cayman> _instance;
} _Cayman_default_instance_;
class AcrelDataDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AcrelData> _instance;
} _AcrelData_default_instance_;
class BaymaxDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Baymax> _instance;
} _Baymax_default_instance_;
class MsgNodeDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<MsgNode> _instance;
} _MsgNode_default_instance_;
static void InitDefaultsscc_info_AcrelData_MsgNode_5f1v1_5fm22_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_AcrelData_default_instance_;
    new (ptr) ::AcrelData();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::AcrelData::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AcrelData_MsgNode_5f1v1_5fm22_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_AcrelData_MsgNode_5f1v1_5fm22_2eproto}, {}};

static void InitDefaultsscc_info_AppParam_MsgNode_5f1v1_5fm22_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_AppParam_default_instance_;
    new (ptr) ::AppParam();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::AppParam::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AppParam_MsgNode_5f1v1_5fm22_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_AppParam_MsgNode_5f1v1_5fm22_2eproto}, {}};

static void InitDefaultsscc_info_AxisData_MsgNode_5f1v1_5fm22_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_AxisData_default_instance_;
    new (ptr) ::AxisData();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::AxisData::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AxisData_MsgNode_5f1v1_5fm22_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_AxisData_MsgNode_5f1v1_5fm22_2eproto}, {}};

static void InitDefaultsscc_info_Baymax_MsgNode_5f1v1_5fm22_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_Baymax_default_instance_;
    new (ptr) ::Baymax();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Baymax::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Baymax_MsgNode_5f1v1_5fm22_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Baymax_MsgNode_5f1v1_5fm22_2eproto}, {}};

static void InitDefaultsscc_info_BleParam_MsgNode_5f1v1_5fm22_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_BleParam_default_instance_;
    new (ptr) ::BleParam();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::BleParam::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_BleParam_MsgNode_5f1v1_5fm22_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_BleParam_MsgNode_5f1v1_5fm22_2eproto}, {}};

static void InitDefaultsscc_info_Cayman_MsgNode_5f1v1_5fm22_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_Cayman_default_instance_;
    new (ptr) ::Cayman();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Cayman::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Cayman_MsgNode_5f1v1_5fm22_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Cayman_MsgNode_5f1v1_5fm22_2eproto}, {}};

static void InitDefaultsscc_info_Channel_MsgNode_5f1v1_5fm22_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_Channel_default_instance_;
    new (ptr) ::Channel();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Channel::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Channel_MsgNode_5f1v1_5fm22_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Channel_MsgNode_5f1v1_5fm22_2eproto}, {}};

static void InitDefaultsscc_info_ElecFireData_MsgNode_5f1v1_5fm22_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_ElecFireData_default_instance_;
    new (ptr) ::ElecFireData();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::ElecFireData::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ElecFireData_MsgNode_5f1v1_5fm22_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_ElecFireData_MsgNode_5f1v1_5fm22_2eproto}, {}};

static void InitDefaultsscc_info_ExtSmoke_MsgNode_5f1v1_5fm22_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_ExtSmoke_default_instance_;
    new (ptr) ::ExtSmoke();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::ExtSmoke::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ExtSmoke_MsgNode_5f1v1_5fm22_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_ExtSmoke_MsgNode_5f1v1_5fm22_2eproto}, {}};

static void InitDefaultsscc_info_GpsData_MsgNode_5f1v1_5fm22_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_GpsData_default_instance_;
    new (ptr) ::GpsData();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::GpsData::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_GpsData_MsgNode_5f1v1_5fm22_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_GpsData_MsgNode_5f1v1_5fm22_2eproto}, {}};

static void InitDefaultsscc_info_LpwanParam_MsgNode_5f1v1_5fm22_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_LpwanParam_default_instance_;
    new (ptr) ::LpwanParam();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::LpwanParam::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_LpwanParam_MsgNode_5f1v1_5fm22_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_LpwanParam_MsgNode_5f1v1_5fm22_2eproto}, {
      &scc_info_Channel_MsgNode_5f1v1_5fm22_2eproto.base,}};

static void InitDefaultsscc_info_MantunData_MsgNode_5f1v1_5fm22_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_MantunData_default_instance_;
    new (ptr) ::MantunData();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::MantunData::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_MantunData_MsgNode_5f1v1_5fm22_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_MantunData_MsgNode_5f1v1_5fm22_2eproto}, {}};

static void InitDefaultsscc_info_MsgNode_MsgNode_5f1v1_5fm22_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_MsgNode_default_instance_;
    new (ptr) ::MsgNode();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::MsgNode::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<15> scc_info_MsgNode_MsgNode_5f1v1_5fm22_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 15, InitDefaultsscc_info_MsgNode_MsgNode_5f1v1_5fm22_2eproto}, {
      &scc_info_LpwanParam_MsgNode_5f1v1_5fm22_2eproto.base,
      &scc_info_BleParam_MsgNode_5f1v1_5fm22_2eproto.base,
      &scc_info_AppParam_MsgNode_5f1v1_5fm22_2eproto.base,
      &scc_info_GpsData_MsgNode_5f1v1_5fm22_2eproto.base,
      &scc_info_AxisData_MsgNode_5f1v1_5fm22_2eproto.base,
      &scc_info_SensorData_MsgNode_5f1v1_5fm22_2eproto.base,
      &scc_info_SensorDataInt_MsgNode_5f1v1_5fm22_2eproto.base,
      &scc_info_MultiSensorDataInt_MsgNode_5f1v1_5fm22_2eproto.base,
      &scc_info_iBeacon_MsgNode_5f1v1_5fm22_2eproto.base,
      &scc_info_ExtSmoke_MsgNode_5f1v1_5fm22_2eproto.base,
      &scc_info_ElecFireData_MsgNode_5f1v1_5fm22_2eproto.base,
      &scc_info_MantunData_MsgNode_5f1v1_5fm22_2eproto.base,
      &scc_info_AcrelData_MsgNode_5f1v1_5fm22_2eproto.base,
      &scc_info_Cayman_MsgNode_5f1v1_5fm22_2eproto.base,
      &scc_info_Baymax_MsgNode_5f1v1_5fm22_2eproto.base,}};

static void InitDefaultsscc_info_MultiSensorData_MsgNode_5f1v1_5fm22_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_MultiSensorData_default_instance_;
    new (ptr) ::MultiSensorData();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::MultiSensorData::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_MultiSensorData_MsgNode_5f1v1_5fm22_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_MultiSensorData_MsgNode_5f1v1_5fm22_2eproto}, {}};

static void InitDefaultsscc_info_MultiSensorDataInt_MsgNode_5f1v1_5fm22_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_MultiSensorDataInt_default_instance_;
    new (ptr) ::MultiSensorDataInt();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::MultiSensorDataInt::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_MultiSensorDataInt_MsgNode_5f1v1_5fm22_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_MultiSensorDataInt_MsgNode_5f1v1_5fm22_2eproto}, {}};

static void InitDefaultsscc_info_SensorData_MsgNode_5f1v1_5fm22_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_SensorData_default_instance_;
    new (ptr) ::SensorData();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::SensorData::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_SensorData_MsgNode_5f1v1_5fm22_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_SensorData_MsgNode_5f1v1_5fm22_2eproto}, {}};

static void InitDefaultsscc_info_SensorDataFloat_MsgNode_5f1v1_5fm22_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_SensorDataFloat_default_instance_;
    new (ptr) ::SensorDataFloat();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::SensorDataFloat::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_SensorDataFloat_MsgNode_5f1v1_5fm22_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_SensorDataFloat_MsgNode_5f1v1_5fm22_2eproto}, {}};

static void InitDefaultsscc_info_SensorDataInt_MsgNode_5f1v1_5fm22_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_SensorDataInt_default_instance_;
    new (ptr) ::SensorDataInt();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::SensorDataInt::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_SensorDataInt_MsgNode_5f1v1_5fm22_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_SensorDataInt_MsgNode_5f1v1_5fm22_2eproto}, {}};

static void InitDefaultsscc_info_iBeacon_MsgNode_5f1v1_5fm22_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_iBeacon_default_instance_;
    new (ptr) ::iBeacon();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::iBeacon::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_iBeacon_MsgNode_5f1v1_5fm22_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_iBeacon_MsgNode_5f1v1_5fm22_2eproto}, {}};

static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_MsgNode_5f1v1_5fm22_2eproto[19];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_MsgNode_5f1v1_5fm22_2eproto[10];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_MsgNode_5f1v1_5fm22_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_MsgNode_5f1v1_5fm22_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::Channel, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::Channel, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Channel, frequency_),
  PROTOBUF_FIELD_OFFSET(::Channel, rx1frequency_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::LpwanParam, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::LpwanParam, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::LpwanParam, deveui_),
  PROTOBUF_FIELD_OFFSET(::LpwanParam, appeui_),
  PROTOBUF_FIELD_OFFSET(::LpwanParam, appkey_),
  PROTOBUF_FIELD_OFFSET(::LpwanParam, appskey_),
  PROTOBUF_FIELD_OFFSET(::LpwanParam, nwkskey_),
  PROTOBUF_FIELD_OFFSET(::LpwanParam, devaddr_),
  PROTOBUF_FIELD_OFFSET(::LpwanParam, datarate_),
  PROTOBUF_FIELD_OFFSET(::LpwanParam, txpower_),
  PROTOBUF_FIELD_OFFSET(::LpwanParam, adr_),
  PROTOBUF_FIELD_OFFSET(::LpwanParam, activition_),
  PROTOBUF_FIELD_OFFSET(::LpwanParam, classtype_),
  PROTOBUF_FIELD_OFFSET(::LpwanParam, delay_),
  PROTOBUF_FIELD_OFFSET(::LpwanParam, channelmask_),
  PROTOBUF_FIELD_OFFSET(::LpwanParam, maxeirp_),
  PROTOBUF_FIELD_OFFSET(::LpwanParam, sglstatus_),
  PROTOBUF_FIELD_OFFSET(::LpwanParam, sglfrequency_),
  PROTOBUF_FIELD_OFFSET(::LpwanParam, sgldatarate_),
  PROTOBUF_FIELD_OFFSET(::LpwanParam, lbtstatus_),
  PROTOBUF_FIELD_OFFSET(::LpwanParam, lbtthreshold_),
  PROTOBUF_FIELD_OFFSET(::LpwanParam, channels_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  ~0u,
  12,
  13,
  14,
  15,
  16,
  17,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::BleParam, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::BleParam, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::BleParam, bleinterval_),
  PROTOBUF_FIELD_OFFSET(::BleParam, bletxp_),
  PROTOBUF_FIELD_OFFSET(::BleParam, bleontime_),
  PROTOBUF_FIELD_OFFSET(::BleParam, bleofftime_),
  PROTOBUF_FIELD_OFFSET(::BleParam, bleonoff_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::SensorData, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::SensorData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::SensorData, type_),
  PROTOBUF_FIELD_OFFSET(::SensorData, data_),
  PROTOBUF_FIELD_OFFSET(::SensorData, alarmhigh_),
  PROTOBUF_FIELD_OFFSET(::SensorData, alarmlow_),
  PROTOBUF_FIELD_OFFSET(::SensorData, calibration_),
  PROTOBUF_FIELD_OFFSET(::SensorData, error_),
  PROTOBUF_FIELD_OFFSET(::SensorData, status_),
  PROTOBUF_FIELD_OFFSET(::SensorData, alarmstephigh_),
  PROTOBUF_FIELD_OFFSET(::SensorData, alarmsteplow_),
  8,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  PROTOBUF_FIELD_OFFSET(::SensorDataInt, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::SensorDataInt, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::SensorDataInt, type_),
  PROTOBUF_FIELD_OFFSET(::SensorDataInt, data_),
  PROTOBUF_FIELD_OFFSET(::SensorDataInt, alarmhigh_),
  PROTOBUF_FIELD_OFFSET(::SensorDataInt, alarmlow_),
  PROTOBUF_FIELD_OFFSET(::SensorDataInt, calibration_),
  PROTOBUF_FIELD_OFFSET(::SensorDataInt, error_),
  PROTOBUF_FIELD_OFFSET(::SensorDataInt, status_),
  PROTOBUF_FIELD_OFFSET(::SensorDataInt, alarmstephigh_),
  PROTOBUF_FIELD_OFFSET(::SensorDataInt, alarmsteplow_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  PROTOBUF_FIELD_OFFSET(::SensorDataFloat, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::SensorDataFloat, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::SensorDataFloat, type_),
  PROTOBUF_FIELD_OFFSET(::SensorDataFloat, data_),
  PROTOBUF_FIELD_OFFSET(::SensorDataFloat, alarmhigh_),
  PROTOBUF_FIELD_OFFSET(::SensorDataFloat, alarmlow_),
  PROTOBUF_FIELD_OFFSET(::SensorDataFloat, calibration_),
  PROTOBUF_FIELD_OFFSET(::SensorDataFloat, error_),
  PROTOBUF_FIELD_OFFSET(::SensorDataFloat, status_),
  PROTOBUF_FIELD_OFFSET(::SensorDataFloat, alarmstephigh_),
  PROTOBUF_FIELD_OFFSET(::SensorDataFloat, alarmsteplow_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  PROTOBUF_FIELD_OFFSET(::MultiSensorData, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::MultiSensorData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::MultiSensorData, data_),
  PROTOBUF_FIELD_OFFSET(::MultiSensorData, alarmhigh_),
  PROTOBUF_FIELD_OFFSET(::MultiSensorData, alarmlow_),
  PROTOBUF_FIELD_OFFSET(::MultiSensorData, calibration_),
  PROTOBUF_FIELD_OFFSET(::MultiSensorData, error_),
  PROTOBUF_FIELD_OFFSET(::MultiSensorData, status_),
  PROTOBUF_FIELD_OFFSET(::MultiSensorData, alarmstephigh_),
  PROTOBUF_FIELD_OFFSET(::MultiSensorData, alarmsteplow_),
  ~0u,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::MultiSensorDataInt, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::MultiSensorDataInt, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::MultiSensorDataInt, data_),
  PROTOBUF_FIELD_OFFSET(::MultiSensorDataInt, alarmhigh_),
  PROTOBUF_FIELD_OFFSET(::MultiSensorDataInt, alarmlow_),
  PROTOBUF_FIELD_OFFSET(::MultiSensorDataInt, calibration_),
  PROTOBUF_FIELD_OFFSET(::MultiSensorDataInt, error_),
  PROTOBUF_FIELD_OFFSET(::MultiSensorDataInt, status_),
  PROTOBUF_FIELD_OFFSET(::MultiSensorDataInt, alarmstephigh_),
  PROTOBUF_FIELD_OFFSET(::MultiSensorDataInt, alarmsteplow_),
  ~0u,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::GpsData, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::GpsData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::GpsData, latitude_),
  PROTOBUF_FIELD_OFFSET(::GpsData, longitude_),
  PROTOBUF_FIELD_OFFSET(::GpsData, altitude_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::AxisData, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::AxisData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::AxisData, x_),
  PROTOBUF_FIELD_OFFSET(::AxisData, y_),
  PROTOBUF_FIELD_OFFSET(::AxisData, z_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::iBeacon, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::iBeacon, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::iBeacon, uuid_),
  PROTOBUF_FIELD_OFFSET(::iBeacon, major_),
  PROTOBUF_FIELD_OFFSET(::iBeacon, minor_),
  PROTOBUF_FIELD_OFFSET(::iBeacon, mrssi_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::ExtSmoke, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ExtSmoke, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::ExtSmoke, bgsignal_),
  PROTOBUF_FIELD_OFFSET(::ExtSmoke, bgsignalthreshold_),
  PROTOBUF_FIELD_OFFSET(::ExtSmoke, bgsignalcalibration_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::AppParam, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::AppParam, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::AppParam, cmd_),
  PROTOBUF_FIELD_OFFSET(::AppParam, uploadinterval_),
  PROTOBUF_FIELD_OFFSET(::AppParam, synctime_),
  PROTOBUF_FIELD_OFFSET(::AppParam, nodestate_),
  PROTOBUF_FIELD_OFFSET(::AppParam, nodealarm_),
  PROTOBUF_FIELD_OFFSET(::AppParam, nodealarmset_),
  PROTOBUF_FIELD_OFFSET(::AppParam, confirm_),
  PROTOBUF_FIELD_OFFSET(::AppParam, smokectrl_),
  PROTOBUF_FIELD_OFFSET(::AppParam, uploadrepeat_),
  PROTOBUF_FIELD_OFFSET(::AppParam, alarmuploadinterval_),
  PROTOBUF_FIELD_OFFSET(::AppParam, alarmuploadnb_),
  PROTOBUF_FIELD_OFFSET(::AppParam, trackerctrl_),
  PROTOBUF_FIELD_OFFSET(::AppParam, trackeremergencytime_),
  PROTOBUF_FIELD_OFFSET(::AppParam, demomode_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  PROTOBUF_FIELD_OFFSET(::ElecFireData, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ElecFireData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::ElecFireData, vol_val_),
  PROTOBUF_FIELD_OFFSET(::ElecFireData, curr_val_),
  PROTOBUF_FIELD_OFFSET(::ElecFireData, leakage_val_),
  PROTOBUF_FIELD_OFFSET(::ElecFireData, power_val_),
  PROTOBUF_FIELD_OFFSET(::ElecFireData, elec_energy_val_),
  PROTOBUF_FIELD_OFFSET(::ElecFireData, temp_val_),
  PROTOBUF_FIELD_OFFSET(::ElecFireData, status_),
  PROTOBUF_FIELD_OFFSET(::ElecFireData, alarm_),
  PROTOBUF_FIELD_OFFSET(::ElecFireData, error_),
  PROTOBUF_FIELD_OFFSET(::ElecFireData, sensorpwd_),
  PROTOBUF_FIELD_OFFSET(::ElecFireData, leakageth_),
  PROTOBUF_FIELD_OFFSET(::ElecFireData, tempth_),
  PROTOBUF_FIELD_OFFSET(::ElecFireData, currentth_),
  PROTOBUF_FIELD_OFFSET(::ElecFireData, loadth_),
  PROTOBUF_FIELD_OFFSET(::ElecFireData, volhighth_),
  PROTOBUF_FIELD_OFFSET(::ElecFireData, vollowth_),
  PROTOBUF_FIELD_OFFSET(::ElecFireData, cmd_),
  PROTOBUF_FIELD_OFFSET(::ElecFireData, autoswitch_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  PROTOBUF_FIELD_OFFSET(::MantunData, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::MantunData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::MantunData, volval_),
  PROTOBUF_FIELD_OFFSET(::MantunData, leakageval_),
  PROTOBUF_FIELD_OFFSET(::MantunData, powerval_),
  PROTOBUF_FIELD_OFFSET(::MantunData, tempval_),
  PROTOBUF_FIELD_OFFSET(::MantunData, currval_),
  PROTOBUF_FIELD_OFFSET(::MantunData, status_),
  PROTOBUF_FIELD_OFFSET(::MantunData, kwhval_),
  PROTOBUF_FIELD_OFFSET(::MantunData, swonoff_),
  PROTOBUF_FIELD_OFFSET(::MantunData, volhighth_),
  PROTOBUF_FIELD_OFFSET(::MantunData, vollowth_),
  PROTOBUF_FIELD_OFFSET(::MantunData, leakageth_),
  PROTOBUF_FIELD_OFFSET(::MantunData, tempth_),
  PROTOBUF_FIELD_OFFSET(::MantunData, currentth_),
  PROTOBUF_FIELD_OFFSET(::MantunData, powerth_),
  PROTOBUF_FIELD_OFFSET(::MantunData, attribute_),
  PROTOBUF_FIELD_OFFSET(::MantunData, cmd_),
  PROTOBUF_FIELD_OFFSET(::MantunData, deverror_),
  PROTOBUF_FIELD_OFFSET(::MantunData, version_),
  PROTOBUF_FIELD_OFFSET(::MantunData, id_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  PROTOBUF_FIELD_OFFSET(::Cayman, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::Cayman, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Cayman, issmoke_),
  PROTOBUF_FIELD_OFFSET(::Cayman, ismoved_),
  PROTOBUF_FIELD_OFFSET(::Cayman, valueoftem_),
  PROTOBUF_FIELD_OFFSET(::Cayman, valueofhum_),
  PROTOBUF_FIELD_OFFSET(::Cayman, valueofsmoke_),
  PROTOBUF_FIELD_OFFSET(::Cayman, standarofsmoke_),
  PROTOBUF_FIELD_OFFSET(::Cayman, alarmofhightem_),
  PROTOBUF_FIELD_OFFSET(::Cayman, alarmoflowtem_),
  PROTOBUF_FIELD_OFFSET(::Cayman, alarmofhighhum_),
  PROTOBUF_FIELD_OFFSET(::Cayman, alarmoflowhum_),
  PROTOBUF_FIELD_OFFSET(::Cayman, cmd_),
  PROTOBUF_FIELD_OFFSET(::Cayman, valueofphotor_),
  PROTOBUF_FIELD_OFFSET(::Cayman, devcestate_),
  PROTOBUF_FIELD_OFFSET(::Cayman, bleadvtype_),
  PROTOBUF_FIELD_OFFSET(::Cayman, bleadvstarttime_),
  PROTOBUF_FIELD_OFFSET(::Cayman, bleadvendtime_),
  PROTOBUF_FIELD_OFFSET(::Cayman, valueofbatb_),
  PROTOBUF_FIELD_OFFSET(::Cayman, levelofalarm_),
  PROTOBUF_FIELD_OFFSET(::Cayman, isselfcheck_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  PROTOBUF_FIELD_OFFSET(::AcrelData, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::AcrelData, channeltype_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, shortcircuit_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, opencircuit_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, chstatus_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, leakageval_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, t1val_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, t2val_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, t3val_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, t4val_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, connectsw_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, chenable_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, leakageth_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, t1th_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, t2th_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, t3th_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, t4th_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, passwd_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, aval_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, bval_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, cval_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, valstatus_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, acurr_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, bcurr_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, ccurr_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, currstatus_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, totalyg_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, totalwg_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, totalsz_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, totalfactor_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, valhighset_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, vallowset_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, currhighset_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, energykwh_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, cmd_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, deverror_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, ct_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, outputsw_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, selfcheck_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, valhightype_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, vallowtype_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, currhightype_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, ict_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, un_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, in_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, pt_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, linemode_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, lineorder_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, volfreq_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, leakagedelay_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, t1delay_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, t2delay_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, t3delay_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, t4delay_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, volhdelay_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, volldelay_),
  PROTOBUF_FIELD_OFFSET(::AcrelData, currdelay_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  PROTOBUF_FIELD_OFFSET(::Baymax, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::Baymax, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Baymax, gasdevclass_),
  PROTOBUF_FIELD_OFFSET(::Baymax, gasdensity_),
  PROTOBUF_FIELD_OFFSET(::Baymax, gasdensityl1_),
  PROTOBUF_FIELD_OFFSET(::Baymax, gasdensityl2_),
  PROTOBUF_FIELD_OFFSET(::Baymax, gasdensityl3_),
  PROTOBUF_FIELD_OFFSET(::Baymax, gasdisassembly_),
  PROTOBUF_FIELD_OFFSET(::Baymax, gaslosepwr_),
  PROTOBUF_FIELD_OFFSET(::Baymax, gasemvalve_),
  PROTOBUF_FIELD_OFFSET(::Baymax, gasdevicestatus_),
  PROTOBUF_FIELD_OFFSET(::Baymax, gasdeviceopstate_),
  PROTOBUF_FIELD_OFFSET(::Baymax, gasdevicecomsdown_),
  PROTOBUF_FIELD_OFFSET(::Baymax, gasdevicecmd_),
  PROTOBUF_FIELD_OFFSET(::Baymax, gasdevicesilentmode_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  PROTOBUF_FIELD_OFFSET(::MsgNode, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::MsgNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::MsgNode, id_),
  PROTOBUF_FIELD_OFFSET(::MsgNode, cmd_),
  PROTOBUF_FIELD_OFFSET(::MsgNode, cmdret_),
  PROTOBUF_FIELD_OFFSET(::MsgNode, lpwanparam_),
  PROTOBUF_FIELD_OFFSET(::MsgNode, bleparam_),
  PROTOBUF_FIELD_OFFSET(::MsgNode, appparam_),
  PROTOBUF_FIELD_OFFSET(::MsgNode, battery_),
  PROTOBUF_FIELD_OFFSET(::MsgNode, gps_),
  PROTOBUF_FIELD_OFFSET(::MsgNode, acceleration_),
  PROTOBUF_FIELD_OFFSET(::MsgNode, magnetism_),
  PROTOBUF_FIELD_OFFSET(::MsgNode, gyroscope_),
  PROTOBUF_FIELD_OFFSET(::MsgNode, temperature_),
  PROTOBUF_FIELD_OFFSET(::MsgNode, humidity_),
  PROTOBUF_FIELD_OFFSET(::MsgNode, light_),
  PROTOBUF_FIELD_OFFSET(::MsgNode, leak_),
  PROTOBUF_FIELD_OFFSET(::MsgNode, co_),
  PROTOBUF_FIELD_OFFSET(::MsgNode, co2_),
  PROTOBUF_FIELD_OFFSET(::MsgNode, so2_),
  PROTOBUF_FIELD_OFFSET(::MsgNode, no2_),
  PROTOBUF_FIELD_OFFSET(::MsgNode, ch4_),
  PROTOBUF_FIELD_OFFSET(::MsgNode, ch2o_),
  PROTOBUF_FIELD_OFFSET(::MsgNode, lpg_),
  PROTOBUF_FIELD_OFFSET(::MsgNode, o3_),
  PROTOBUF_FIELD_OFFSET(::MsgNode, pm1_),
  PROTOBUF_FIELD_OFFSET(::MsgNode, pm2_5_),
  PROTOBUF_FIELD_OFFSET(::MsgNode, pm10_),
  PROTOBUF_FIELD_OFFSET(::MsgNode, angle_),
  PROTOBUF_FIELD_OFFSET(::MsgNode, cover_),
  PROTOBUF_FIELD_OFFSET(::MsgNode, level_),
  PROTOBUF_FIELD_OFFSET(::MsgNode, smoke_),
  PROTOBUF_FIELD_OFFSET(::MsgNode, pitch_),
  PROTOBUF_FIELD_OFFSET(::MsgNode, roll_),
  PROTOBUF_FIELD_OFFSET(::MsgNode, yaw_),
  PROTOBUF_FIELD_OFFSET(::MsgNode, flame_),
  PROTOBUF_FIELD_OFFSET(::MsgNode, artificialgas_),
  PROTOBUF_FIELD_OFFSET(::MsgNode, multitemp_),
  PROTOBUF_FIELD_OFFSET(::MsgNode, waterpressure_),
  PROTOBUF_FIELD_OFFSET(::MsgNode, ibeacon_),
  PROTOBUF_FIELD_OFFSET(::MsgNode, sensors_),
  PROTOBUF_FIELD_OFFSET(::MsgNode, installed_),
  PROTOBUF_FIELD_OFFSET(::MsgNode, extsmoke_),
  PROTOBUF_FIELD_OFFSET(::MsgNode, firedata_),
  PROTOBUF_FIELD_OFFSET(::MsgNode, mtundata_),
  PROTOBUF_FIELD_OFFSET(::MsgNode, acreldata_),
  PROTOBUF_FIELD_OFFSET(::MsgNode, caymandata_),
  PROTOBUF_FIELD_OFFSET(::MsgNode, baymaxdata_),
  39,
  40,
  41,
  0,
  1,
  2,
  42,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  ~0u,
  43,
  34,
  35,
  ~0u,
  36,
  37,
  38,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 7, sizeof(::Channel)},
  { 9, 34, sizeof(::LpwanParam)},
  { 54, 64, sizeof(::BleParam)},
  { 69, 83, sizeof(::SensorData)},
  { 92, 106, sizeof(::SensorDataInt)},
  { 115, 129, sizeof(::SensorDataFloat)},
  { 138, 151, sizeof(::MultiSensorData)},
  { 159, 172, sizeof(::MultiSensorDataInt)},
  { 180, 188, sizeof(::GpsData)},
  { 191, 199, sizeof(::AxisData)},
  { 202, 211, sizeof(::iBeacon)},
  { 215, 223, sizeof(::ExtSmoke)},
  { 226, 245, sizeof(::AppParam)},
  { 259, 282, sizeof(::ElecFireData)},
  { 300, 324, sizeof(::MantunData)},
  { 343, 367, sizeof(::Cayman)},
  { 386, 447, sizeof(::AcrelData)},
  { 503, 521, sizeof(::Baymax)},
  { 534, 585, sizeof(::MsgNode)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_Channel_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_LpwanParam_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_BleParam_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_SensorData_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_SensorDataInt_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_SensorDataFloat_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_MultiSensorData_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_MultiSensorDataInt_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_GpsData_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_AxisData_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_iBeacon_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_ExtSmoke_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_AppParam_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_ElecFireData_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_MantunData_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_Cayman_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_AcrelData_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_Baymax_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_MsgNode_default_instance_),
};

const char descriptor_table_protodef_MsgNode_5f1v1_5fm22_2eproto[] =
  "\n\025MsgNode_1v1_m22.proto\"2\n\007Channel\022\021\n\tfr"
  "equency\030\001 \002(\r\022\024\n\014rx1Frequency\030\002 \001(\r\"\226\003\n\n"
  "LpwanParam\022\016\n\006devEui\030\001 \001(\014\022\016\n\006appEui\030\002 \001"
  "(\014\022\016\n\006appKey\030\003 \001(\014\022\017\n\007appSkey\030\004 \001(\014\022\017\n\007n"
  "wkSkey\030\005 \001(\014\022\017\n\007devAddr\030\006 \001(\r\022\020\n\010datarat"
  "e\030\007 \001(\r\022\017\n\007txPower\030\010 \001(\021\022\013\n\003adr\030\t \001(\r\022\036\n"
  "\nactivition\030\n \001(\0162\n.Activtion\022\035\n\tclassTy"
  "pe\030\013 \001(\0162\n.ClassType\022\r\n\005delay\030\014 \001(\r\022\023\n\013c"
  "hannelMask\030\r \003(\r\022\017\n\007maxEIRP\030\016 \001(\r\022\021\n\tsgl"
  "Status\030\017 \001(\r\022\024\n\014sglFrequency\030\020 \001(\r\022\023\n\013sg"
  "lDatarate\030\021 \001(\r\022\021\n\tlbtStatus\030\022 \001(\r\022\024\n\014lb"
  "tThreshold\030\023 \001(\021\022\032\n\010channels\030\024 \003(\0132\010.Cha"
  "nnel\"h\n\010BleParam\022\023\n\013bleInterval\030\001 \001(\002\022\016\n"
  "\006bleTxp\030\002 \001(\021\022\021\n\tbleOnTime\030\003 \001(\r\022\022\n\nbleO"
  "ffTime\030\004 \001(\r\022\020\n\010bleOnOff\030\005 \001(\r\"\311\001\n\nSenso"
  "rData\022\031\n\004type\030\t \001(\0162\013.SensorType\022\014\n\004data"
  "\030\001 \001(\002\022\021\n\talarmHigh\030\002 \001(\002\022\020\n\010alarmLow\030\003 "
  "\001(\002\022\023\n\013calibration\030\004 \001(\r\022\033\n\005error\030\005 \001(\0162"
  "\014.SensorError\022\016\n\006status\030\006 \001(\r\022\025\n\ralarmSt"
  "epHigh\030\007 \001(\002\022\024\n\014alarmStepLow\030\010 \001(\002\"\314\001\n\rS"
  "ensorDataInt\022\031\n\004type\030\001 \001(\0162\013.SensorType\022"
  "\014\n\004data\030\002 \001(\021\022\021\n\talarmHigh\030\003 \001(\021\022\020\n\010alar"
  "mLow\030\004 \001(\021\022\023\n\013calibration\030\005 \001(\021\022\033\n\005error"
  "\030\006 \001(\0162\014.SensorError\022\016\n\006status\030\007 \001(\r\022\025\n\r"
  "alarmStepHigh\030\010 \001(\021\022\024\n\014alarmStepLow\030\t \001("
  "\021\"\316\001\n\017SensorDataFloat\022\031\n\004type\030\001 \001(\0162\013.Se"
  "nsorType\022\014\n\004data\030\002 \001(\002\022\021\n\talarmHigh\030\003 \001("
  "\002\022\020\n\010alarmLow\030\004 \001(\002\022\023\n\013calibration\030\005 \001(\021"
  "\022\033\n\005error\030\006 \001(\0162\014.SensorError\022\016\n\006status\030"
  "\007 \001(\r\022\025\n\ralarmStepHigh\030\010 \001(\002\022\024\n\014alarmSte"
  "pLow\030\t \001(\002\"\263\001\n\017MultiSensorData\022\014\n\004data\030\001"
  " \003(\002\022\021\n\talarmHigh\030\002 \001(\002\022\020\n\010alarmLow\030\003 \001("
  "\002\022\023\n\013calibration\030\004 \001(\r\022\033\n\005error\030\005 \001(\0162\014."
  "SensorError\022\016\n\006status\030\006 \001(\r\022\025\n\ralarmStep"
  "High\030\007 \001(\002\022\024\n\014alarmStepLow\030\010 \001(\002\"\266\001\n\022Mul"
  "tiSensorDataInt\022\014\n\004data\030\001 \003(\021\022\021\n\talarmHi"
  "gh\030\002 \001(\021\022\020\n\010alarmLow\030\003 \001(\021\022\023\n\013calibratio"
  "n\030\004 \001(\r\022\033\n\005error\030\005 \001(\0162\014.SensorError\022\016\n\006"
  "status\030\006 \001(\r\022\025\n\ralarmStepHigh\030\007 \001(\021\022\024\n\014a"
  "larmStepLow\030\010 \001(\021\"@\n\007GpsData\022\020\n\010latitude"
  "\030\001 \001(\001\022\021\n\tlongitude\030\002 \001(\001\022\020\n\010altitude\030\003 "
  "\001(\001\"+\n\010AxisData\022\t\n\001x\030\001 \001(\002\022\t\n\001y\030\002 \001(\002\022\t\n"
  "\001z\030\003 \001(\002\"D\n\007iBeacon\022\014\n\004uuid\030\001 \001(\014\022\r\n\005maj"
  "or\030\002 \001(\r\022\r\n\005minor\030\003 \001(\r\022\r\n\005mrssi\030\004 \001(\021\"T"
  "\n\010ExtSmoke\022\020\n\010bgSignal\030\001 \001(\r\022\031\n\021bgSignal"
  "Threshold\030\002 \001(\r\022\033\n\023bgSignalCalibration\030\003"
  " \001(\r\"\353\002\n\010AppParam\022\024\n\003cmd\030\001 \001(\0162\007.AppCmd\022"
  "\026\n\016uploadInterval\030\002 \001(\r\022\020\n\010syncTime\030\003 \001("
  "\r\022\035\n\tnodeState\030\004 \001(\0162\n.NodeState\022\035\n\tnode"
  "Alarm\030\005 \001(\0162\n.NodeAlarm\022\024\n\014nodeAlarmSet\030"
  "\006 \001(\r\022\017\n\007confirm\030\007 \001(\r\022\035\n\tsmokeCtrl\030\010 \001("
  "\0162\n.SmokeCtrl\022\024\n\014uploadRepeat\030\t \001(\r\022\033\n\023a"
  "larmUploadInterval\030\n \001(\r\022\025\n\ralarmUploadN"
  "b\030\013 \001(\r\022!\n\013trackerCtrl\030\014 \001(\0162\014.TrackerCt"
  "rl\022\034\n\024trackerEmergencyTime\030\r \001(\r\022\020\n\010demo"
  "Mode\030\016 \001(\r\"\321\002\n\014ElecFireData\022\017\n\007vol_val\030\001"
  " \001(\021\022\020\n\010curr_val\030\002 \001(\r\022\023\n\013leakage_val\030\003 "
  "\001(\021\022\021\n\tpower_val\030\004 \001(\r\022\027\n\017elec_energy_va"
  "l\030\005 \001(\r\022\020\n\010temp_val\030\006 \001(\r\022\016\n\006status\030\007 \001("
  "\r\022\r\n\005alarm\030\010 \001(\r\022\r\n\005error\030\t \001(\r\022\021\n\tsenso"
  "rPwd\030\n \001(\r\022\021\n\tleakageTh\030\013 \001(\r\022\016\n\006tempTh\030"
  "\014 \001(\r\022\021\n\tcurrentTh\030\r \001(\r\022\016\n\006loadTh\030\016 \001(\r"
  "\022\021\n\tvolHighTh\030\017 \001(\r\022\020\n\010volLowTh\030\020 \001(\r\022\013\n"
  "\003cmd\030\021 \001(\r\022\022\n\nautoSwitch\030\022 \001(\r\"\320\002\n\nMantu"
  "nData\022\016\n\006volVal\030\001 \001(\r\022\022\n\nleakageVal\030\002 \001("
  "\r\022\020\n\010powerVal\030\003 \001(\r\022\017\n\007tempVal\030\004 \001(\r\022\017\n\007"
  "currVal\030\005 \001(\r\022\016\n\006status\030\006 \001(\r\022\016\n\006kwhVal\030"
  "\007 \001(\r\022\017\n\007swOnOff\030\010 \001(\r\022\021\n\tvolHighTh\030\t \001("
  "\r\022\020\n\010volLowTh\030\n \001(\r\022\021\n\tleakageTh\030\013 \001(\r\022\016"
  "\n\006tempTh\030\014 \001(\r\022\021\n\tcurrentTh\030\r \001(\r\022\017\n\007pow"
  "erTh\030\016 \001(\r\022\021\n\tattribute\030\017 \001(\r\022\013\n\003cmd\030\020 \001"
  "(\r\022\020\n\010devError\030\021 \001(\r\022\017\n\007version\030\022 \001(\r\022\n\n"
  "\002id\030\023 \001(\r\"\232\003\n\006Cayman\022\017\n\007isSmoke\030\001 \001(\r\022\017\n"
  "\007isMoved\030\002 \001(\r\022\022\n\nvalueOfTem\030\003 \001(\021\022\022\n\nva"
  "lueOfHum\030\004 \001(\r\022\024\n\014valueOfSmoke\030\005 \001(\r\022\026\n\016"
  "standarOfSmoke\030\006 \001(\r\022\026\n\016alarmOfHighTem\030\007"
  " \001(\021\022\025\n\ralarmOfLowTem\030\010 \001(\021\022\026\n\016alarmOfHi"
  "ghHum\030\t \001(\r\022\025\n\ralarmOfLowHum\030\n \001(\r\022\013\n\003cm"
  "d\030\013 \001(\r\022\025\n\rvalueOfphotor\030\014 \001(\r\022\022\n\ndevceS"
  "tate\030\r \001(\r\022\022\n\nbleAdvType\030\016 \001(\r\022\027\n\017bleAdv"
  "StartTime\030\017 \001(\r\022\025\n\rbleAdvEndTime\030\020 \001(\r\022\023"
  "\n\013valueOfBatb\030\021 \001(\r\022\024\n\014levelOfAlarm\030\022 \001("
  "\r\022\023\n\013isSelfCheck\030\023 \001(\r\"\313\007\n\tAcrelData\022\023\n\013"
  "channelType\030\001 \001(\r\022\024\n\014shortCircuit\030\002 \001(\r\022"
  "\023\n\013openCircuit\030\003 \001(\r\022\020\n\010chStatus\030\004 \001(\r\022\022"
  "\n\nleakageVal\030\005 \001(\021\022\r\n\005t1Val\030\006 \001(\021\022\r\n\005t2V"
  "al\030\007 \001(\021\022\r\n\005t3Val\030\010 \001(\021\022\r\n\005t4Val\030\t \001(\021\022\021"
  "\n\tconnectSw\030\n \001(\r\022\020\n\010chEnable\030\013 \001(\r\022\021\n\tl"
  "eakageTh\030\014 \001(\r\022\014\n\004t1Th\030\r \001(\r\022\014\n\004t2Th\030\016 \001"
  "(\r\022\014\n\004t3Th\030\017 \001(\r\022\014\n\004t4Th\030\020 \001(\r\022\016\n\006passwd"
  "\030\021 \001(\r\022\014\n\004aVal\030\022 \001(\r\022\014\n\004bVal\030\023 \001(\r\022\014\n\004cV"
  "al\030\024 \001(\r\022\021\n\tvalStatus\030\025 \001(\r\022\r\n\005aCurr\030\026 \001"
  "(\r\022\r\n\005bCurr\030\027 \001(\r\022\r\n\005cCurr\030\030 \001(\r\022\022\n\ncurr"
  "Status\030\031 \001(\r\022\017\n\007totalYg\030\032 \001(\r\022\017\n\007totalWg"
  "\030\033 \001(\r\022\017\n\007totalSz\030\034 \001(\r\022\023\n\013totalFactor\030\035"
  " \001(\r\022\022\n\nvalHighSet\030\036 \001(\r\022\021\n\tvalLowSet\030\037 "
  "\001(\r\022\023\n\013currHighSet\030  \001(\r\022\021\n\tenergyKwh\030! "
  "\001(\r\022\013\n\003cmd\030# \001(\r\022\020\n\010devError\030$ \001(\r\022\n\n\002ct"
  "\030% \001(\r\022\020\n\010outputSw\030& \001(\r\022\021\n\tselfCheck\030\' "
  "\001(\r\022\023\n\013valHighType\030( \001(\r\022\022\n\nvalLowType\030)"
  " \001(\r\022\024\n\014currHighType\030* \001(\r\022\013\n\003ict\030+ \001(\r\022"
  "\n\n\002un\030, \001(\r\022\n\n\002in\030- \001(\r\022\n\n\002pt\030. \001(\r\022\020\n\010l"
  "ineMode\030/ \001(\r\022\021\n\tlineOrder\0300 \001(\r\022\017\n\007volF"
  "req\0301 \001(\r\022\024\n\014leakageDelay\0302 \001(\r\022\017\n\007T1Del"
  "ay\0303 \001(\r\022\017\n\007T2Delay\0304 \001(\r\022\017\n\007T3Delay\0305 \001"
  "(\r\022\017\n\007T4Delay\0306 \001(\r\022\021\n\tvolHDelay\0307 \001(\r\022\021"
  "\n\tvolLDelay\0308 \001(\r\022\021\n\tcurrDelay\0309 \001(\r\"\264\002\n"
  "\006Baymax\022\023\n\013gasDevClass\030\001 \001(\r\022\022\n\ngasDensi"
  "ty\030\002 \001(\r\022\024\n\014gasDensityL1\030\003 \001(\r\022\024\n\014gasDen"
  "sityL2\030\004 \001(\r\022\024\n\014gasDensityL3\030\005 \001(\r\022\026\n\016ga"
  "sDisassembly\030\006 \001(\r\022\022\n\ngasLosePwr\030\007 \001(\r\022\022"
  "\n\ngasEMValve\030\010 \001(\r\022\027\n\017gasDeviceStatus\030\t "
  "\001(\r\022\030\n\020gasDeviceOpState\030\n \001(\r\022\031\n\021gasDevi"
  "ceComsDown\030\013 \001(\r\022\024\n\014gasDeviceCMD\030\014 \001(\r\022\033"
  "\n\023gasDeviceSilentMode\030\r \001(\r\"\374\t\n\007MsgNode\022"
  "\n\n\002id\030\001 \001(\r\022\013\n\003cmd\030\002 \001(\r\022\016\n\006cmdRet\030\003 \001(\r"
  "\022\037\n\nlpwanParam\030\004 \001(\0132\013.LpwanParam\022\033\n\010ble"
  "Param\030\005 \001(\0132\t.BleParam\022\033\n\010appParam\030\006 \001(\013"
  "2\t.AppParam\022\017\n\007battery\030\007 \001(\021\022\025\n\003gps\030\010 \001("
  "\0132\010.GpsData\022\037\n\014acceleration\030\t \001(\0132\t.Axis"
  "Data\022\034\n\tmagnetism\030\n \001(\0132\t.AxisData\022\034\n\tgy"
  "roscope\030\013 \001(\0132\t.AxisData\022 \n\013temperature\030"
  "\014 \001(\0132\013.SensorData\022\035\n\010humidity\030\r \001(\0132\013.S"
  "ensorData\022\032\n\005light\030\016 \001(\0132\013.SensorData\022\031\n"
  "\004leak\030\017 \001(\0132\013.SensorData\022\027\n\002co\030\020 \001(\0132\013.S"
  "ensorData\022\030\n\003co2\030\021 \001(\0132\013.SensorData\022\030\n\003s"
  "o2\030\022 \001(\0132\013.SensorData\022\030\n\003no2\030\023 \001(\0132\013.Sen"
  "sorData\022\030\n\003ch4\030\024 \001(\0132\013.SensorData\022\031\n\004ch2"
  "o\030\025 \001(\0132\013.SensorData\022\030\n\003lpg\030\026 \001(\0132\013.Sens"
  "orData\022\027\n\002o3\030\027 \001(\0132\013.SensorData\022\030\n\003pm1\030\030"
  " \001(\0132\013.SensorData\022\032\n\005pm2_5\030\031 \001(\0132\013.Senso"
  "rData\022\031\n\004pm10\030\032 \001(\0132\013.SensorData\022\032\n\005angl"
  "e\030\033 \001(\0132\013.SensorData\022\032\n\005cover\030\034 \001(\0132\013.Se"
  "nsorData\022\032\n\005level\030\035 \001(\0132\013.SensorData\022\032\n\005"
  "smoke\030\036 \001(\0132\013.SensorData\022\032\n\005pitch\030\037 \001(\0132"
  "\013.SensorData\022\031\n\004roll\030  \001(\0132\013.SensorData\022"
  "\030\n\003yaw\030! \001(\0132\013.SensorData\022\035\n\005flame\030\" \001(\013"
  "2\016.SensorDataInt\022\"\n\rartificialGas\030# \001(\0132"
  "\013.SensorData\022&\n\tmultiTemp\030$ \001(\0132\023.MultiS"
  "ensorDataInt\022\"\n\rwaterPressure\030% \001(\0132\013.Se"
  "nsorData\022\031\n\007ibeacon\030& \001(\0132\010.iBeacon\022\034\n\007s"
  "ensors\030\' \003(\0132\013.SensorData\022\021\n\tinstalled\030("
  " \001(\010\022\033\n\010extSmoke\030) \001(\0132\t.ExtSmoke\022\037\n\010fir"
  "eData\030* \001(\0132\r.ElecFireData\022\035\n\010mtunData\030+"
  " \003(\0132\013.MantunData\022\035\n\tacrelData\030, \001(\0132\n.A"
  "crelData\022\033\n\ncaymanData\030- \001(\0132\007.Cayman\022\033\n"
  "\nbaymaxData\030. \001(\0132\007.Baymax*\035\n\tActivtion\022"
  "\007\n\003ABP\020\000\022\007\n\003OTA\020\001*2\n\tClassType\022\013\n\007CLASS_"
  "A\020\000\022\013\n\007CLASS_B\020\001\022\013\n\007CLASS_C\020\002*\334\001\n\013Sensor"
  "Error\022\023\n\017SENSOR_ERR_NONE\020\000\022\026\n\022SENSOR_ERR"
  "_NO_DATA\020\001\022\022\n\016SENSOR_ERR_CRC\020\002\022\023\n\017SENSOR"
  "_ERR_DATA\020\003\022\024\n\020SENSOR_ERR_FAULT\020\004\022\024\n\020SEN"
  "SOR_ERR_ALARM\020\005\022\031\n\025SENSOR_ERR_ALARM_HIGH"
  "\020\006\022\030\n\024SENSOR_ERR_ALARM_LOW\020\007\022\026\n\022SENSOR_E"
  "RR_UNKNOWN\020\177*\222\003\n\nSensorType\022\024\n\020SENSOR_TY"
  "PE_TEMP\020\000\022\024\n\020SENSOR_TYPE_HUMI\020\001\022\025\n\021SENSO"
  "R_TYPE_LIGHT\020\002\022\023\n\017SENSOR_TYPE_GPS\020\003\022\025\n\021S"
  "ENSOR_TYPE_ANGLE\020\004\022\025\n\021SENSOR_TYPE_PM2_5\020"
  "\005\022\024\n\020SENSOR_TYPE_PM10\020\006\022\024\n\020SENSOR_TYPE_L"
  "EAK\020\007\022\022\n\016SENSOR_TYPE_CO\020\010\022\023\n\017SENSOR_TYPE"
  "_CO2\020\t\022\023\n\017SENSOR_TYPE_NO2\020\n\022\023\n\017SENSOR_TY"
  "PE_CH4\020\013\022\023\n\017SENSOR_TYPE_LPG\020\014\022\025\n\021SENSOR_"
  "TYPE_FLAME\020\r\022\036\n\032SENSOR_TYPE_ARTIFICIAL_G"
  "AS\020\016\022\032\n\026SENSOR_TYPE_WATER_GAGE\020\017\022\027\n\023SENS"
  "OR_TYPE_TRACKER\020\020*e\n\014SensorStatus\022\027\n\023SEN"
  "SORO_STATUS_NONE\020\000\022\"\n\036SENSORO_STATUS_SEL"
  "F_INSPECTION\020\001\022\030\n\024SENSORO_STATUS_ALARM\020\002"
  "*U\n\006AppCmd\022\020\n\014APP_CMD_NONE\020\000\022\021\n\rAPP_CMD_"
  "RESET\020\001\022\025\n\021APP_CMD_FAC_RESET\020\002\022\017\n\013APP_CM"
  "D_DFU\020\003*O\n\tNodeState\022\026\n\022NODE_STATE_UNKNO"
  "WN\020\000\022\025\n\021NODE_STATE_STATIC\020\001\022\023\n\017NODE_STAT"
  "E_MOVE\020\002*\251\001\n\tNodeAlarm\022\023\n\017NODE_ALARM_NON"
  "E\020\000\022\025\n\021NODE_ALARM_STATIC\020\001\022\023\n\017NODE_ALARM"
  "_MOVE\020\002\022\030\n\024NODE_ALARM_COLLISION\020\003\022\023\n\017NOD"
  "E_ALARM_ROLL\020\004\022\027\n\023NODE_ALARM_INVERTED\020\005\022"
  "\023\n\017NODE_ALARM_FALL\020\006*\201\001\n\tSmokeCtrl\022\023\n\017SM"
  "OKE_CTRL_NONE\020\000\022\021\n\rSMOKE_ERASURE\020\001\022\031\n\025SM"
  "OKE_INSPECTION_TEST\020\002\022\031\n\025SMOKE_INSPECTIO"
  "N_OVER\020\003\022\026\n\022SMOKE_ERASURE_LONE\020\004*\255\001\n\013Tra"
  "ckerCtrl\022\020\n\014TRACKER_Ctrl\020\000\022\020\n\014TRACKER_BO"
  "OT\020\001\022\024\n\020TRACKER_SHUTDOWN\020\002\022\026\n\022TRACKER_CA"
  "LL_START\020\003\022\024\n\020TRACKER_CALL_END\020\004\022\033\n\027TRAC"
  "KER_EMERGENCE_START\020\005\022\031\n\025TRACKER_EMERGEN"
  "CE_END\020\006"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_MsgNode_5f1v1_5fm22_2eproto_deps[1] = {
};
static ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase*const descriptor_table_MsgNode_5f1v1_5fm22_2eproto_sccs[19] = {
  &scc_info_AcrelData_MsgNode_5f1v1_5fm22_2eproto.base,
  &scc_info_AppParam_MsgNode_5f1v1_5fm22_2eproto.base,
  &scc_info_AxisData_MsgNode_5f1v1_5fm22_2eproto.base,
  &scc_info_Baymax_MsgNode_5f1v1_5fm22_2eproto.base,
  &scc_info_BleParam_MsgNode_5f1v1_5fm22_2eproto.base,
  &scc_info_Cayman_MsgNode_5f1v1_5fm22_2eproto.base,
  &scc_info_Channel_MsgNode_5f1v1_5fm22_2eproto.base,
  &scc_info_ElecFireData_MsgNode_5f1v1_5fm22_2eproto.base,
  &scc_info_ExtSmoke_MsgNode_5f1v1_5fm22_2eproto.base,
  &scc_info_GpsData_MsgNode_5f1v1_5fm22_2eproto.base,
  &scc_info_LpwanParam_MsgNode_5f1v1_5fm22_2eproto.base,
  &scc_info_MantunData_MsgNode_5f1v1_5fm22_2eproto.base,
  &scc_info_MsgNode_MsgNode_5f1v1_5fm22_2eproto.base,
  &scc_info_MultiSensorData_MsgNode_5f1v1_5fm22_2eproto.base,
  &scc_info_MultiSensorDataInt_MsgNode_5f1v1_5fm22_2eproto.base,
  &scc_info_SensorData_MsgNode_5f1v1_5fm22_2eproto.base,
  &scc_info_SensorDataFloat_MsgNode_5f1v1_5fm22_2eproto.base,
  &scc_info_SensorDataInt_MsgNode_5f1v1_5fm22_2eproto.base,
  &scc_info_iBeacon_MsgNode_5f1v1_5fm22_2eproto.base,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_MsgNode_5f1v1_5fm22_2eproto_once;
static bool descriptor_table_MsgNode_5f1v1_5fm22_2eproto_initialized = false;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_MsgNode_5f1v1_5fm22_2eproto = {
  &descriptor_table_MsgNode_5f1v1_5fm22_2eproto_initialized, descriptor_table_protodef_MsgNode_5f1v1_5fm22_2eproto, "MsgNode_1v1_m22.proto", 7328,
  &descriptor_table_MsgNode_5f1v1_5fm22_2eproto_once, descriptor_table_MsgNode_5f1v1_5fm22_2eproto_sccs, descriptor_table_MsgNode_5f1v1_5fm22_2eproto_deps, 19, 0,
  schemas, file_default_instances, TableStruct_MsgNode_5f1v1_5fm22_2eproto::offsets,
  file_level_metadata_MsgNode_5f1v1_5fm22_2eproto, 19, file_level_enum_descriptors_MsgNode_5f1v1_5fm22_2eproto, file_level_service_descriptors_MsgNode_5f1v1_5fm22_2eproto,
};

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_MsgNode_5f1v1_5fm22_2eproto = (  ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptors(&descriptor_table_MsgNode_5f1v1_5fm22_2eproto), true);
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Activtion_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_MsgNode_5f1v1_5fm22_2eproto);
  return file_level_enum_descriptors_MsgNode_5f1v1_5fm22_2eproto[0];
}
bool Activtion_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ClassType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_MsgNode_5f1v1_5fm22_2eproto);
  return file_level_enum_descriptors_MsgNode_5f1v1_5fm22_2eproto[1];
}
bool ClassType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SensorError_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_MsgNode_5f1v1_5fm22_2eproto);
  return file_level_enum_descriptors_MsgNode_5f1v1_5fm22_2eproto[2];
}
bool SensorError_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 127:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SensorType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_MsgNode_5f1v1_5fm22_2eproto);
  return file_level_enum_descriptors_MsgNode_5f1v1_5fm22_2eproto[3];
}
bool SensorType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SensorStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_MsgNode_5f1v1_5fm22_2eproto);
  return file_level_enum_descriptors_MsgNode_5f1v1_5fm22_2eproto[4];
}
bool SensorStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AppCmd_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_MsgNode_5f1v1_5fm22_2eproto);
  return file_level_enum_descriptors_MsgNode_5f1v1_5fm22_2eproto[5];
}
bool AppCmd_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NodeState_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_MsgNode_5f1v1_5fm22_2eproto);
  return file_level_enum_descriptors_MsgNode_5f1v1_5fm22_2eproto[6];
}
bool NodeState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NodeAlarm_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_MsgNode_5f1v1_5fm22_2eproto);
  return file_level_enum_descriptors_MsgNode_5f1v1_5fm22_2eproto[7];
}
bool NodeAlarm_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SmokeCtrl_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_MsgNode_5f1v1_5fm22_2eproto);
  return file_level_enum_descriptors_MsgNode_5f1v1_5fm22_2eproto[8];
}
bool SmokeCtrl_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TrackerCtrl_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_MsgNode_5f1v1_5fm22_2eproto);
  return file_level_enum_descriptors_MsgNode_5f1v1_5fm22_2eproto[9];
}
bool TrackerCtrl_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}


// ===================================================================

void Channel::InitAsDefaultInstance() {
}
class Channel::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<Channel>()._has_bits_);
  static void set_has_frequency(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_rx1frequency(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Channel::kFrequencyFieldNumber;
const int Channel::kRx1FrequencyFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Channel::Channel()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Channel)
}
Channel::Channel(const Channel& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&frequency_, &from.frequency_,
    static_cast<size_t>(reinterpret_cast<char*>(&rx1frequency_) -
    reinterpret_cast<char*>(&frequency_)) + sizeof(rx1frequency_));
  // @@protoc_insertion_point(copy_constructor:Channel)
}

void Channel::SharedCtor() {
  ::memset(&frequency_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&rx1frequency_) -
      reinterpret_cast<char*>(&frequency_)) + sizeof(rx1frequency_));
}

Channel::~Channel() {
  // @@protoc_insertion_point(destructor:Channel)
  SharedDtor();
}

void Channel::SharedDtor() {
}

void Channel::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Channel& Channel::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Channel_MsgNode_5f1v1_5fm22_2eproto.base);
  return *internal_default_instance();
}


void Channel::Clear() {
// @@protoc_insertion_point(message_clear_start:Channel)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&frequency_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&rx1frequency_) -
        reinterpret_cast<char*>(&frequency_)) + sizeof(rx1frequency_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Channel::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required uint32 frequency = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          HasBitSetters::set_has_frequency(&has_bits);
          frequency_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 rx1Frequency = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          HasBitSetters::set_has_rx1frequency(&has_bits);
          rx1frequency_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Channel::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:Channel)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 frequency = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_frequency(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &frequency_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 rx1Frequency = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_rx1frequency(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &rx1frequency_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Channel)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Channel)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Channel::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Channel)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 frequency = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(1, this->frequency(), output);
  }

  // optional uint32 rx1Frequency = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(2, this->rx1frequency(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Channel)
}

::PROTOBUF_NAMESPACE_ID::uint8* Channel::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Channel)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 frequency = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->frequency(), target);
  }

  // optional uint32 rx1Frequency = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->rx1frequency(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Channel)
  return target;
}

size_t Channel::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Channel)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required uint32 frequency = 1;
  if (has_frequency()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->frequency());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 rx1Frequency = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->rx1frequency());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Channel::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Channel)
  GOOGLE_DCHECK_NE(&from, this);
  const Channel* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Channel>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Channel)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Channel)
    MergeFrom(*source);
  }
}

void Channel::MergeFrom(const Channel& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Channel)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      frequency_ = from.frequency_;
    }
    if (cached_has_bits & 0x00000002u) {
      rx1frequency_ = from.rx1frequency_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Channel::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Channel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Channel::CopyFrom(const Channel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Channel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Channel::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void Channel::Swap(Channel* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Channel::InternalSwap(Channel* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(frequency_, other->frequency_);
  swap(rx1frequency_, other->rx1frequency_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Channel::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void LpwanParam::InitAsDefaultInstance() {
}
class LpwanParam::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<LpwanParam>()._has_bits_);
  static void set_has_deveui(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_appeui(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_appkey(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_appskey(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_nwkskey(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_devaddr(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_datarate(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_txpower(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_adr(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_activition(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_classtype(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_delay(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_maxeirp(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_sglstatus(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_sglfrequency(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_sgldatarate(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_lbtstatus(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_lbtthreshold(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int LpwanParam::kDevEuiFieldNumber;
const int LpwanParam::kAppEuiFieldNumber;
const int LpwanParam::kAppKeyFieldNumber;
const int LpwanParam::kAppSkeyFieldNumber;
const int LpwanParam::kNwkSkeyFieldNumber;
const int LpwanParam::kDevAddrFieldNumber;
const int LpwanParam::kDatarateFieldNumber;
const int LpwanParam::kTxPowerFieldNumber;
const int LpwanParam::kAdrFieldNumber;
const int LpwanParam::kActivitionFieldNumber;
const int LpwanParam::kClassTypeFieldNumber;
const int LpwanParam::kDelayFieldNumber;
const int LpwanParam::kChannelMaskFieldNumber;
const int LpwanParam::kMaxEIRPFieldNumber;
const int LpwanParam::kSglStatusFieldNumber;
const int LpwanParam::kSglFrequencyFieldNumber;
const int LpwanParam::kSglDatarateFieldNumber;
const int LpwanParam::kLbtStatusFieldNumber;
const int LpwanParam::kLbtThresholdFieldNumber;
const int LpwanParam::kChannelsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

LpwanParam::LpwanParam()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:LpwanParam)
}
LpwanParam::LpwanParam(const LpwanParam& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      channelmask_(from.channelmask_),
      channels_(from.channels_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  deveui_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_deveui()) {
    deveui_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.deveui_);
  }
  appeui_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_appeui()) {
    appeui_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.appeui_);
  }
  appkey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_appkey()) {
    appkey_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.appkey_);
  }
  appskey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_appskey()) {
    appskey_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.appskey_);
  }
  nwkskey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_nwkskey()) {
    nwkskey_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.nwkskey_);
  }
  ::memcpy(&devaddr_, &from.devaddr_,
    static_cast<size_t>(reinterpret_cast<char*>(&lbtthreshold_) -
    reinterpret_cast<char*>(&devaddr_)) + sizeof(lbtthreshold_));
  // @@protoc_insertion_point(copy_constructor:LpwanParam)
}

void LpwanParam::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_LpwanParam_MsgNode_5f1v1_5fm22_2eproto.base);
  deveui_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  appeui_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  appkey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  appskey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  nwkskey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&devaddr_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&lbtthreshold_) -
      reinterpret_cast<char*>(&devaddr_)) + sizeof(lbtthreshold_));
}

LpwanParam::~LpwanParam() {
  // @@protoc_insertion_point(destructor:LpwanParam)
  SharedDtor();
}

void LpwanParam::SharedDtor() {
  deveui_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  appeui_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  appkey_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  appskey_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  nwkskey_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void LpwanParam::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const LpwanParam& LpwanParam::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_LpwanParam_MsgNode_5f1v1_5fm22_2eproto.base);
  return *internal_default_instance();
}


void LpwanParam::Clear() {
// @@protoc_insertion_point(message_clear_start:LpwanParam)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  channelmask_.Clear();
  channels_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      deveui_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      appeui_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      appkey_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000008u) {
      appskey_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000010u) {
      nwkskey_.ClearNonDefaultToEmptyNoArena();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&devaddr_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&txpower_) -
        reinterpret_cast<char*>(&devaddr_)) + sizeof(txpower_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&adr_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&sgldatarate_) -
        reinterpret_cast<char*>(&adr_)) + sizeof(sgldatarate_));
  }
  if (cached_has_bits & 0x00030000u) {
    ::memset(&lbtstatus_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&lbtthreshold_) -
        reinterpret_cast<char*>(&lbtstatus_)) + sizeof(lbtthreshold_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* LpwanParam::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional bytes devEui = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_deveui(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes appEui = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_appeui(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes appKey = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_appkey(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes appSkey = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_appskey(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes nwkSkey = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_nwkskey(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 devAddr = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          HasBitSetters::set_has_devaddr(&has_bits);
          devaddr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 datarate = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          HasBitSetters::set_has_datarate(&has_bits);
          datarate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional sint32 txPower = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          HasBitSetters::set_has_txpower(&has_bits);
          txpower_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 adr = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          HasBitSetters::set_has_adr(&has_bits);
          adr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .Activtion activition = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::Activtion_IsValid(val))) {
            set_activition(static_cast<::Activtion>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(10, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .ClassType classType = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ClassType_IsValid(val))) {
            set_classtype(static_cast<::ClassType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(11, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional uint32 delay = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          HasBitSetters::set_has_delay(&has_bits);
          delay_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated uint32 channelMask = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          ptr -= 1;
          do {
            ptr += 1;
            add_channelmask(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 104);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 106) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(mutable_channelmask(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 maxEIRP = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 112)) {
          HasBitSetters::set_has_maxeirp(&has_bits);
          maxeirp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 sglStatus = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 120)) {
          HasBitSetters::set_has_sglstatus(&has_bits);
          sglstatus_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 sglFrequency = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 128)) {
          HasBitSetters::set_has_sglfrequency(&has_bits);
          sglfrequency_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 sglDatarate = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 136)) {
          HasBitSetters::set_has_sgldatarate(&has_bits);
          sgldatarate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 lbtStatus = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 144)) {
          HasBitSetters::set_has_lbtstatus(&has_bits);
          lbtstatus_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional sint32 lbtThreshold = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 152)) {
          HasBitSetters::set_has_lbtthreshold(&has_bits);
          lbtthreshold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .Channel channels = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 162)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(add_channels(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint16>(ptr) == 418);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool LpwanParam::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:LpwanParam)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes devEui = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_deveui()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes appEui = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_appeui()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes appKey = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_appkey()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes appSkey = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_appskey()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes nwkSkey = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (42 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_nwkskey()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 devAddr = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          HasBitSetters::set_has_devaddr(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &devaddr_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 datarate = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          HasBitSetters::set_has_datarate(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &datarate_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional sint32 txPower = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (64 & 0xFF)) {
          HasBitSetters::set_has_txpower(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_SINT32>(
                 input, &txpower_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 adr = 9;
      case 9: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (72 & 0xFF)) {
          HasBitSetters::set_has_adr(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &adr_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Activtion activition = 10;
      case 10: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (80 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Activtion_IsValid(value)) {
            set_activition(static_cast< ::Activtion >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                10, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .ClassType classType = 11;
      case 11: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (88 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ClassType_IsValid(value)) {
            set_classtype(static_cast< ::ClassType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                11, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 delay = 12;
      case 12: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (96 & 0xFF)) {
          HasBitSetters::set_has_delay(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &delay_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated uint32 channelMask = 13;
      case 13: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (104 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 1, 104u, input, this->mutable_channelmask())));
        } else if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (106 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_channelmask())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 maxEIRP = 14;
      case 14: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (112 & 0xFF)) {
          HasBitSetters::set_has_maxeirp(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &maxeirp_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 sglStatus = 15;
      case 15: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (120 & 0xFF)) {
          HasBitSetters::set_has_sglstatus(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sglstatus_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 sglFrequency = 16;
      case 16: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (128 & 0xFF)) {
          HasBitSetters::set_has_sglfrequency(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sglfrequency_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 sglDatarate = 17;
      case 17: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (136 & 0xFF)) {
          HasBitSetters::set_has_sgldatarate(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sgldatarate_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 lbtStatus = 18;
      case 18: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (144 & 0xFF)) {
          HasBitSetters::set_has_lbtstatus(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &lbtstatus_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional sint32 lbtThreshold = 19;
      case 19: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (152 & 0xFF)) {
          HasBitSetters::set_has_lbtthreshold(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_SINT32>(
                 input, &lbtthreshold_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .Channel channels = 20;
      case 20: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (162 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_channels()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:LpwanParam)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:LpwanParam)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void LpwanParam::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:LpwanParam)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes devEui = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->deveui(), output);
  }

  // optional bytes appEui = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->appeui(), output);
  }

  // optional bytes appKey = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->appkey(), output);
  }

  // optional bytes appSkey = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->appskey(), output);
  }

  // optional bytes nwkSkey = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      5, this->nwkskey(), output);
  }

  // optional uint32 devAddr = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(6, this->devaddr(), output);
  }

  // optional uint32 datarate = 7;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(7, this->datarate(), output);
  }

  // optional sint32 txPower = 8;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32(8, this->txpower(), output);
  }

  // optional uint32 adr = 9;
  if (cached_has_bits & 0x00000100u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(9, this->adr(), output);
  }

  // optional .Activtion activition = 10;
  if (cached_has_bits & 0x00000200u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      10, this->activition(), output);
  }

  // optional .ClassType classType = 11;
  if (cached_has_bits & 0x00000400u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      11, this->classtype(), output);
  }

  // optional uint32 delay = 12;
  if (cached_has_bits & 0x00000800u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(12, this->delay(), output);
  }

  // repeated uint32 channelMask = 13;
  for (int i = 0, n = this->channelmask_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(
      13, this->channelmask(i), output);
  }

  // optional uint32 maxEIRP = 14;
  if (cached_has_bits & 0x00001000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(14, this->maxeirp(), output);
  }

  // optional uint32 sglStatus = 15;
  if (cached_has_bits & 0x00002000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(15, this->sglstatus(), output);
  }

  // optional uint32 sglFrequency = 16;
  if (cached_has_bits & 0x00004000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(16, this->sglfrequency(), output);
  }

  // optional uint32 sglDatarate = 17;
  if (cached_has_bits & 0x00008000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(17, this->sgldatarate(), output);
  }

  // optional uint32 lbtStatus = 18;
  if (cached_has_bits & 0x00010000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(18, this->lbtstatus(), output);
  }

  // optional sint32 lbtThreshold = 19;
  if (cached_has_bits & 0x00020000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32(19, this->lbtthreshold(), output);
  }

  // repeated .Channel channels = 20;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->channels_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      20,
      this->channels(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:LpwanParam)
}

::PROTOBUF_NAMESPACE_ID::uint8* LpwanParam::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:LpwanParam)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes devEui = 1;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        1, this->deveui(), target);
  }

  // optional bytes appEui = 2;
  if (cached_has_bits & 0x00000002u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        2, this->appeui(), target);
  }

  // optional bytes appKey = 3;
  if (cached_has_bits & 0x00000004u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        3, this->appkey(), target);
  }

  // optional bytes appSkey = 4;
  if (cached_has_bits & 0x00000008u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        4, this->appskey(), target);
  }

  // optional bytes nwkSkey = 5;
  if (cached_has_bits & 0x00000010u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        5, this->nwkskey(), target);
  }

  // optional uint32 devAddr = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(6, this->devaddr(), target);
  }

  // optional uint32 datarate = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(7, this->datarate(), target);
  }

  // optional sint32 txPower = 8;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(8, this->txpower(), target);
  }

  // optional uint32 adr = 9;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(9, this->adr(), target);
  }

  // optional .Activtion activition = 10;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      10, this->activition(), target);
  }

  // optional .ClassType classType = 11;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      11, this->classtype(), target);
  }

  // optional uint32 delay = 12;
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(12, this->delay(), target);
  }

  // repeated uint32 channelMask = 13;
  target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
    WriteUInt32ToArray(13, this->channelmask_, target);

  // optional uint32 maxEIRP = 14;
  if (cached_has_bits & 0x00001000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(14, this->maxeirp(), target);
  }

  // optional uint32 sglStatus = 15;
  if (cached_has_bits & 0x00002000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(15, this->sglstatus(), target);
  }

  // optional uint32 sglFrequency = 16;
  if (cached_has_bits & 0x00004000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(16, this->sglfrequency(), target);
  }

  // optional uint32 sglDatarate = 17;
  if (cached_has_bits & 0x00008000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(17, this->sgldatarate(), target);
  }

  // optional uint32 lbtStatus = 18;
  if (cached_has_bits & 0x00010000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(18, this->lbtstatus(), target);
  }

  // optional sint32 lbtThreshold = 19;
  if (cached_has_bits & 0x00020000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(19, this->lbtthreshold(), target);
  }

  // repeated .Channel channels = 20;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->channels_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        20, this->channels(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:LpwanParam)
  return target;
}

size_t LpwanParam::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:LpwanParam)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 channelMask = 13;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->channelmask_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->channelmask_size());
    total_size += data_size;
  }

  // repeated .Channel channels = 20;
  {
    unsigned int count = static_cast<unsigned int>(this->channels_size());
    total_size += 2UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->channels(static_cast<int>(i)));
    }
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes devEui = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->deveui());
    }

    // optional bytes appEui = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->appeui());
    }

    // optional bytes appKey = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->appkey());
    }

    // optional bytes appSkey = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->appskey());
    }

    // optional bytes nwkSkey = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->nwkskey());
    }

    // optional uint32 devAddr = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->devaddr());
    }

    // optional uint32 datarate = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->datarate());
    }

    // optional sint32 txPower = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32Size(
          this->txpower());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional uint32 adr = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->adr());
    }

    // optional .Activtion activition = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->activition());
    }

    // optional .ClassType classType = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->classtype());
    }

    // optional uint32 delay = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->delay());
    }

    // optional uint32 maxEIRP = 14;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->maxeirp());
    }

    // optional uint32 sglStatus = 15;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->sglstatus());
    }

    // optional uint32 sglFrequency = 16;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->sglfrequency());
    }

    // optional uint32 sglDatarate = 17;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->sgldatarate());
    }

  }
  if (cached_has_bits & 0x00030000u) {
    // optional uint32 lbtStatus = 18;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->lbtstatus());
    }

    // optional sint32 lbtThreshold = 19;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32Size(
          this->lbtthreshold());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LpwanParam::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:LpwanParam)
  GOOGLE_DCHECK_NE(&from, this);
  const LpwanParam* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<LpwanParam>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:LpwanParam)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:LpwanParam)
    MergeFrom(*source);
  }
}

void LpwanParam::MergeFrom(const LpwanParam& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:LpwanParam)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  channelmask_.MergeFrom(from.channelmask_);
  channels_.MergeFrom(from.channels_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      deveui_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.deveui_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      appeui_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.appeui_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      appkey_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.appkey_);
    }
    if (cached_has_bits & 0x00000008u) {
      _has_bits_[0] |= 0x00000008u;
      appskey_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.appskey_);
    }
    if (cached_has_bits & 0x00000010u) {
      _has_bits_[0] |= 0x00000010u;
      nwkskey_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.nwkskey_);
    }
    if (cached_has_bits & 0x00000020u) {
      devaddr_ = from.devaddr_;
    }
    if (cached_has_bits & 0x00000040u) {
      datarate_ = from.datarate_;
    }
    if (cached_has_bits & 0x00000080u) {
      txpower_ = from.txpower_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      adr_ = from.adr_;
    }
    if (cached_has_bits & 0x00000200u) {
      activition_ = from.activition_;
    }
    if (cached_has_bits & 0x00000400u) {
      classtype_ = from.classtype_;
    }
    if (cached_has_bits & 0x00000800u) {
      delay_ = from.delay_;
    }
    if (cached_has_bits & 0x00001000u) {
      maxeirp_ = from.maxeirp_;
    }
    if (cached_has_bits & 0x00002000u) {
      sglstatus_ = from.sglstatus_;
    }
    if (cached_has_bits & 0x00004000u) {
      sglfrequency_ = from.sglfrequency_;
    }
    if (cached_has_bits & 0x00008000u) {
      sgldatarate_ = from.sgldatarate_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00030000u) {
    if (cached_has_bits & 0x00010000u) {
      lbtstatus_ = from.lbtstatus_;
    }
    if (cached_has_bits & 0x00020000u) {
      lbtthreshold_ = from.lbtthreshold_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void LpwanParam::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:LpwanParam)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LpwanParam::CopyFrom(const LpwanParam& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:LpwanParam)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LpwanParam::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(this->channels())) return false;
  return true;
}

void LpwanParam::Swap(LpwanParam* other) {
  if (other == this) return;
  InternalSwap(other);
}
void LpwanParam::InternalSwap(LpwanParam* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  channelmask_.InternalSwap(&other->channelmask_);
  CastToBase(&channels_)->InternalSwap(CastToBase(&other->channels_));
  deveui_.Swap(&other->deveui_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  appeui_.Swap(&other->appeui_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  appkey_.Swap(&other->appkey_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  appskey_.Swap(&other->appskey_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  nwkskey_.Swap(&other->nwkskey_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(devaddr_, other->devaddr_);
  swap(datarate_, other->datarate_);
  swap(txpower_, other->txpower_);
  swap(adr_, other->adr_);
  swap(activition_, other->activition_);
  swap(classtype_, other->classtype_);
  swap(delay_, other->delay_);
  swap(maxeirp_, other->maxeirp_);
  swap(sglstatus_, other->sglstatus_);
  swap(sglfrequency_, other->sglfrequency_);
  swap(sgldatarate_, other->sgldatarate_);
  swap(lbtstatus_, other->lbtstatus_);
  swap(lbtthreshold_, other->lbtthreshold_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LpwanParam::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void BleParam::InitAsDefaultInstance() {
}
class BleParam::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<BleParam>()._has_bits_);
  static void set_has_bleinterval(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_bletxp(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_bleontime(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_bleofftime(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_bleonoff(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int BleParam::kBleIntervalFieldNumber;
const int BleParam::kBleTxpFieldNumber;
const int BleParam::kBleOnTimeFieldNumber;
const int BleParam::kBleOffTimeFieldNumber;
const int BleParam::kBleOnOffFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

BleParam::BleParam()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:BleParam)
}
BleParam::BleParam(const BleParam& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&bleinterval_, &from.bleinterval_,
    static_cast<size_t>(reinterpret_cast<char*>(&bleonoff_) -
    reinterpret_cast<char*>(&bleinterval_)) + sizeof(bleonoff_));
  // @@protoc_insertion_point(copy_constructor:BleParam)
}

void BleParam::SharedCtor() {
  ::memset(&bleinterval_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&bleonoff_) -
      reinterpret_cast<char*>(&bleinterval_)) + sizeof(bleonoff_));
}

BleParam::~BleParam() {
  // @@protoc_insertion_point(destructor:BleParam)
  SharedDtor();
}

void BleParam::SharedDtor() {
}

void BleParam::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const BleParam& BleParam::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_BleParam_MsgNode_5f1v1_5fm22_2eproto.base);
  return *internal_default_instance();
}


void BleParam::Clear() {
// @@protoc_insertion_point(message_clear_start:BleParam)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&bleinterval_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&bleonoff_) -
        reinterpret_cast<char*>(&bleinterval_)) + sizeof(bleonoff_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* BleParam::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional float bleInterval = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          HasBitSetters::set_has_bleinterval(&has_bits);
          bleinterval_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional sint32 bleTxp = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          HasBitSetters::set_has_bletxp(&has_bits);
          bletxp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 bleOnTime = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          HasBitSetters::set_has_bleontime(&has_bits);
          bleontime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 bleOffTime = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          HasBitSetters::set_has_bleofftime(&has_bits);
          bleofftime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 bleOnOff = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          HasBitSetters::set_has_bleonoff(&has_bits);
          bleonoff_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool BleParam::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:BleParam)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float bleInterval = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (13 & 0xFF)) {
          HasBitSetters::set_has_bleinterval(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &bleinterval_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional sint32 bleTxp = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_bletxp(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_SINT32>(
                 input, &bletxp_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 bleOnTime = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_bleontime(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &bleontime_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 bleOffTime = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_bleofftime(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &bleofftime_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 bleOnOff = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_bleonoff(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &bleonoff_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:BleParam)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:BleParam)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void BleParam::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:BleParam)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float bleInterval = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(1, this->bleinterval(), output);
  }

  // optional sint32 bleTxp = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32(2, this->bletxp(), output);
  }

  // optional uint32 bleOnTime = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->bleontime(), output);
  }

  // optional uint32 bleOffTime = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->bleofftime(), output);
  }

  // optional uint32 bleOnOff = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(5, this->bleonoff(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:BleParam)
}

::PROTOBUF_NAMESPACE_ID::uint8* BleParam::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:BleParam)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float bleInterval = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->bleinterval(), target);
  }

  // optional sint32 bleTxp = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(2, this->bletxp(), target);
  }

  // optional uint32 bleOnTime = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->bleontime(), target);
  }

  // optional uint32 bleOffTime = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->bleofftime(), target);
  }

  // optional uint32 bleOnOff = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->bleonoff(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:BleParam)
  return target;
}

size_t BleParam::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:BleParam)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional float bleInterval = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional sint32 bleTxp = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32Size(
          this->bletxp());
    }

    // optional uint32 bleOnTime = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->bleontime());
    }

    // optional uint32 bleOffTime = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->bleofftime());
    }

    // optional uint32 bleOnOff = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->bleonoff());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BleParam::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:BleParam)
  GOOGLE_DCHECK_NE(&from, this);
  const BleParam* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<BleParam>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:BleParam)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:BleParam)
    MergeFrom(*source);
  }
}

void BleParam::MergeFrom(const BleParam& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:BleParam)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      bleinterval_ = from.bleinterval_;
    }
    if (cached_has_bits & 0x00000002u) {
      bletxp_ = from.bletxp_;
    }
    if (cached_has_bits & 0x00000004u) {
      bleontime_ = from.bleontime_;
    }
    if (cached_has_bits & 0x00000008u) {
      bleofftime_ = from.bleofftime_;
    }
    if (cached_has_bits & 0x00000010u) {
      bleonoff_ = from.bleonoff_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void BleParam::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:BleParam)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BleParam::CopyFrom(const BleParam& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:BleParam)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BleParam::IsInitialized() const {
  return true;
}

void BleParam::Swap(BleParam* other) {
  if (other == this) return;
  InternalSwap(other);
}
void BleParam::InternalSwap(BleParam* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(bleinterval_, other->bleinterval_);
  swap(bletxp_, other->bletxp_);
  swap(bleontime_, other->bleontime_);
  swap(bleofftime_, other->bleofftime_);
  swap(bleonoff_, other->bleonoff_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BleParam::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void SensorData::InitAsDefaultInstance() {
}
class SensorData::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<SensorData>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_alarmhigh(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_alarmlow(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_calibration(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_alarmstephigh(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_alarmsteplow(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SensorData::kTypeFieldNumber;
const int SensorData::kDataFieldNumber;
const int SensorData::kAlarmHighFieldNumber;
const int SensorData::kAlarmLowFieldNumber;
const int SensorData::kCalibrationFieldNumber;
const int SensorData::kErrorFieldNumber;
const int SensorData::kStatusFieldNumber;
const int SensorData::kAlarmStepHighFieldNumber;
const int SensorData::kAlarmStepLowFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SensorData::SensorData()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SensorData)
}
SensorData::SensorData(const SensorData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&data_, &from.data_,
    static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&data_)) + sizeof(type_));
  // @@protoc_insertion_point(copy_constructor:SensorData)
}

void SensorData::SharedCtor() {
  ::memset(&data_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&type_) -
      reinterpret_cast<char*>(&data_)) + sizeof(type_));
}

SensorData::~SensorData() {
  // @@protoc_insertion_point(destructor:SensorData)
  SharedDtor();
}

void SensorData::SharedDtor() {
}

void SensorData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SensorData& SensorData::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_SensorData_MsgNode_5f1v1_5fm22_2eproto.base);
  return *internal_default_instance();
}


void SensorData::Clear() {
// @@protoc_insertion_point(message_clear_start:SensorData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&data_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&alarmsteplow_) -
        reinterpret_cast<char*>(&data_)) + sizeof(alarmsteplow_));
  }
  type_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* SensorData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional float data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          HasBitSetters::set_has_data(&has_bits);
          data_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float alarmHigh = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          HasBitSetters::set_has_alarmhigh(&has_bits);
          alarmhigh_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float alarmLow = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          HasBitSetters::set_has_alarmlow(&has_bits);
          alarmlow_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional uint32 calibration = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          HasBitSetters::set_has_calibration(&has_bits);
          calibration_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .SensorError error = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::SensorError_IsValid(val))) {
            set_error(static_cast<::SensorError>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional uint32 status = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          HasBitSetters::set_has_status(&has_bits);
          status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float alarmStepHigh = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 61)) {
          HasBitSetters::set_has_alarmstephigh(&has_bits);
          alarmstephigh_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float alarmStepLow = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 69)) {
          HasBitSetters::set_has_alarmsteplow(&has_bits);
          alarmsteplow_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional .SensorType type = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::SensorType_IsValid(val))) {
            set_type(static_cast<::SensorType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(9, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool SensorData::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:SensorData)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float data = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (13 & 0xFF)) {
          HasBitSetters::set_has_data(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &data_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float alarmHigh = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (21 & 0xFF)) {
          HasBitSetters::set_has_alarmhigh(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &alarmhigh_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float alarmLow = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (29 & 0xFF)) {
          HasBitSetters::set_has_alarmlow(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &alarmlow_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 calibration = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_calibration(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &calibration_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .SensorError error = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::SensorError_IsValid(value)) {
            set_error(static_cast< ::SensorError >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                5, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 status = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          HasBitSetters::set_has_status(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &status_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float alarmStepHigh = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (61 & 0xFF)) {
          HasBitSetters::set_has_alarmstephigh(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &alarmstephigh_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float alarmStepLow = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (69 & 0xFF)) {
          HasBitSetters::set_has_alarmsteplow(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &alarmsteplow_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .SensorType type = 9;
      case 9: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (72 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::SensorType_IsValid(value)) {
            set_type(static_cast< ::SensorType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                9, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:SensorData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:SensorData)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void SensorData::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:SensorData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float data = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(1, this->data(), output);
  }

  // optional float alarmHigh = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(2, this->alarmhigh(), output);
  }

  // optional float alarmLow = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(3, this->alarmlow(), output);
  }

  // optional uint32 calibration = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->calibration(), output);
  }

  // optional .SensorError error = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      5, this->error(), output);
  }

  // optional uint32 status = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(6, this->status(), output);
  }

  // optional float alarmStepHigh = 7;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(7, this->alarmstephigh(), output);
  }

  // optional float alarmStepLow = 8;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(8, this->alarmsteplow(), output);
  }

  // optional .SensorType type = 9;
  if (cached_has_bits & 0x00000100u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      9, this->type(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:SensorData)
}

::PROTOBUF_NAMESPACE_ID::uint8* SensorData::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:SensorData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float data = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->data(), target);
  }

  // optional float alarmHigh = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->alarmhigh(), target);
  }

  // optional float alarmLow = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->alarmlow(), target);
  }

  // optional uint32 calibration = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->calibration(), target);
  }

  // optional .SensorError error = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      5, this->error(), target);
  }

  // optional uint32 status = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(6, this->status(), target);
  }

  // optional float alarmStepHigh = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(7, this->alarmstephigh(), target);
  }

  // optional float alarmStepLow = 8;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(8, this->alarmsteplow(), target);
  }

  // optional .SensorType type = 9;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      9, this->type(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SensorData)
  return target;
}

size_t SensorData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SensorData)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional float data = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float alarmHigh = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float alarmLow = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional uint32 calibration = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->calibration());
    }

    // optional .SensorError error = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->error());
    }

    // optional uint32 status = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->status());
    }

    // optional float alarmStepHigh = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional float alarmStepLow = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  // optional .SensorType type = 9;
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->type());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SensorData::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:SensorData)
  GOOGLE_DCHECK_NE(&from, this);
  const SensorData* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<SensorData>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:SensorData)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:SensorData)
    MergeFrom(*source);
  }
}

void SensorData::MergeFrom(const SensorData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SensorData)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      data_ = from.data_;
    }
    if (cached_has_bits & 0x00000002u) {
      alarmhigh_ = from.alarmhigh_;
    }
    if (cached_has_bits & 0x00000004u) {
      alarmlow_ = from.alarmlow_;
    }
    if (cached_has_bits & 0x00000008u) {
      calibration_ = from.calibration_;
    }
    if (cached_has_bits & 0x00000010u) {
      error_ = from.error_;
    }
    if (cached_has_bits & 0x00000020u) {
      status_ = from.status_;
    }
    if (cached_has_bits & 0x00000040u) {
      alarmstephigh_ = from.alarmstephigh_;
    }
    if (cached_has_bits & 0x00000080u) {
      alarmsteplow_ = from.alarmsteplow_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    set_type(from.type());
  }
}

void SensorData::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:SensorData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SensorData::CopyFrom(const SensorData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SensorData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SensorData::IsInitialized() const {
  return true;
}

void SensorData::Swap(SensorData* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SensorData::InternalSwap(SensorData* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(data_, other->data_);
  swap(alarmhigh_, other->alarmhigh_);
  swap(alarmlow_, other->alarmlow_);
  swap(calibration_, other->calibration_);
  swap(error_, other->error_);
  swap(status_, other->status_);
  swap(alarmstephigh_, other->alarmstephigh_);
  swap(alarmsteplow_, other->alarmsteplow_);
  swap(type_, other->type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SensorData::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void SensorDataInt::InitAsDefaultInstance() {
}
class SensorDataInt::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<SensorDataInt>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_alarmhigh(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_alarmlow(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_calibration(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_alarmstephigh(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_alarmsteplow(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SensorDataInt::kTypeFieldNumber;
const int SensorDataInt::kDataFieldNumber;
const int SensorDataInt::kAlarmHighFieldNumber;
const int SensorDataInt::kAlarmLowFieldNumber;
const int SensorDataInt::kCalibrationFieldNumber;
const int SensorDataInt::kErrorFieldNumber;
const int SensorDataInt::kStatusFieldNumber;
const int SensorDataInt::kAlarmStepHighFieldNumber;
const int SensorDataInt::kAlarmStepLowFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SensorDataInt::SensorDataInt()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SensorDataInt)
}
SensorDataInt::SensorDataInt(const SensorDataInt& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&type_, &from.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&alarmsteplow_) -
    reinterpret_cast<char*>(&type_)) + sizeof(alarmsteplow_));
  // @@protoc_insertion_point(copy_constructor:SensorDataInt)
}

void SensorDataInt::SharedCtor() {
  ::memset(&type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&alarmsteplow_) -
      reinterpret_cast<char*>(&type_)) + sizeof(alarmsteplow_));
}

SensorDataInt::~SensorDataInt() {
  // @@protoc_insertion_point(destructor:SensorDataInt)
  SharedDtor();
}

void SensorDataInt::SharedDtor() {
}

void SensorDataInt::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SensorDataInt& SensorDataInt::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_SensorDataInt_MsgNode_5f1v1_5fm22_2eproto.base);
  return *internal_default_instance();
}


void SensorDataInt::Clear() {
// @@protoc_insertion_point(message_clear_start:SensorDataInt)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&alarmstephigh_) -
        reinterpret_cast<char*>(&type_)) + sizeof(alarmstephigh_));
  }
  alarmsteplow_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* SensorDataInt::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .SensorType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::SensorType_IsValid(val))) {
            set_type(static_cast<::SensorType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional sint32 data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          HasBitSetters::set_has_data(&has_bits);
          data_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional sint32 alarmHigh = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          HasBitSetters::set_has_alarmhigh(&has_bits);
          alarmhigh_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional sint32 alarmLow = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          HasBitSetters::set_has_alarmlow(&has_bits);
          alarmlow_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional sint32 calibration = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          HasBitSetters::set_has_calibration(&has_bits);
          calibration_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .SensorError error = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::SensorError_IsValid(val))) {
            set_error(static_cast<::SensorError>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional uint32 status = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          HasBitSetters::set_has_status(&has_bits);
          status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional sint32 alarmStepHigh = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          HasBitSetters::set_has_alarmstephigh(&has_bits);
          alarmstephigh_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional sint32 alarmStepLow = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          HasBitSetters::set_has_alarmsteplow(&has_bits);
          alarmsteplow_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool SensorDataInt::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:SensorDataInt)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .SensorType type = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::SensorType_IsValid(value)) {
            set_type(static_cast< ::SensorType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional sint32 data = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_data(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_SINT32>(
                 input, &data_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional sint32 alarmHigh = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_alarmhigh(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_SINT32>(
                 input, &alarmhigh_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional sint32 alarmLow = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_alarmlow(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_SINT32>(
                 input, &alarmlow_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional sint32 calibration = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_calibration(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_SINT32>(
                 input, &calibration_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .SensorError error = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::SensorError_IsValid(value)) {
            set_error(static_cast< ::SensorError >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                6, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 status = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          HasBitSetters::set_has_status(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &status_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional sint32 alarmStepHigh = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (64 & 0xFF)) {
          HasBitSetters::set_has_alarmstephigh(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_SINT32>(
                 input, &alarmstephigh_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional sint32 alarmStepLow = 9;
      case 9: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (72 & 0xFF)) {
          HasBitSetters::set_has_alarmsteplow(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_SINT32>(
                 input, &alarmsteplow_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:SensorDataInt)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:SensorDataInt)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void SensorDataInt::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:SensorDataInt)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .SensorType type = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional sint32 data = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32(2, this->data(), output);
  }

  // optional sint32 alarmHigh = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32(3, this->alarmhigh(), output);
  }

  // optional sint32 alarmLow = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32(4, this->alarmlow(), output);
  }

  // optional sint32 calibration = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32(5, this->calibration(), output);
  }

  // optional .SensorError error = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      6, this->error(), output);
  }

  // optional uint32 status = 7;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(7, this->status(), output);
  }

  // optional sint32 alarmStepHigh = 8;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32(8, this->alarmstephigh(), output);
  }

  // optional sint32 alarmStepLow = 9;
  if (cached_has_bits & 0x00000100u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32(9, this->alarmsteplow(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:SensorDataInt)
}

::PROTOBUF_NAMESPACE_ID::uint8* SensorDataInt::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:SensorDataInt)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .SensorType type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional sint32 data = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(2, this->data(), target);
  }

  // optional sint32 alarmHigh = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(3, this->alarmhigh(), target);
  }

  // optional sint32 alarmLow = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(4, this->alarmlow(), target);
  }

  // optional sint32 calibration = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(5, this->calibration(), target);
  }

  // optional .SensorError error = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      6, this->error(), target);
  }

  // optional uint32 status = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(7, this->status(), target);
  }

  // optional sint32 alarmStepHigh = 8;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(8, this->alarmstephigh(), target);
  }

  // optional sint32 alarmStepLow = 9;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(9, this->alarmsteplow(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SensorDataInt)
  return target;
}

size_t SensorDataInt::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SensorDataInt)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .SensorType type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional sint32 data = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32Size(
          this->data());
    }

    // optional sint32 alarmHigh = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32Size(
          this->alarmhigh());
    }

    // optional sint32 alarmLow = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32Size(
          this->alarmlow());
    }

    // optional sint32 calibration = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32Size(
          this->calibration());
    }

    // optional .SensorError error = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->error());
    }

    // optional uint32 status = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->status());
    }

    // optional sint32 alarmStepHigh = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32Size(
          this->alarmstephigh());
    }

  }
  // optional sint32 alarmStepLow = 9;
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32Size(
        this->alarmsteplow());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SensorDataInt::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:SensorDataInt)
  GOOGLE_DCHECK_NE(&from, this);
  const SensorDataInt* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<SensorDataInt>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:SensorDataInt)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:SensorDataInt)
    MergeFrom(*source);
  }
}

void SensorDataInt::MergeFrom(const SensorDataInt& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SensorDataInt)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000002u) {
      data_ = from.data_;
    }
    if (cached_has_bits & 0x00000004u) {
      alarmhigh_ = from.alarmhigh_;
    }
    if (cached_has_bits & 0x00000008u) {
      alarmlow_ = from.alarmlow_;
    }
    if (cached_has_bits & 0x00000010u) {
      calibration_ = from.calibration_;
    }
    if (cached_has_bits & 0x00000020u) {
      error_ = from.error_;
    }
    if (cached_has_bits & 0x00000040u) {
      status_ = from.status_;
    }
    if (cached_has_bits & 0x00000080u) {
      alarmstephigh_ = from.alarmstephigh_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    set_alarmsteplow(from.alarmsteplow());
  }
}

void SensorDataInt::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:SensorDataInt)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SensorDataInt::CopyFrom(const SensorDataInt& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SensorDataInt)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SensorDataInt::IsInitialized() const {
  return true;
}

void SensorDataInt::Swap(SensorDataInt* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SensorDataInt::InternalSwap(SensorDataInt* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(type_, other->type_);
  swap(data_, other->data_);
  swap(alarmhigh_, other->alarmhigh_);
  swap(alarmlow_, other->alarmlow_);
  swap(calibration_, other->calibration_);
  swap(error_, other->error_);
  swap(status_, other->status_);
  swap(alarmstephigh_, other->alarmstephigh_);
  swap(alarmsteplow_, other->alarmsteplow_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SensorDataInt::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void SensorDataFloat::InitAsDefaultInstance() {
}
class SensorDataFloat::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<SensorDataFloat>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_alarmhigh(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_alarmlow(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_calibration(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_alarmstephigh(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_alarmsteplow(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SensorDataFloat::kTypeFieldNumber;
const int SensorDataFloat::kDataFieldNumber;
const int SensorDataFloat::kAlarmHighFieldNumber;
const int SensorDataFloat::kAlarmLowFieldNumber;
const int SensorDataFloat::kCalibrationFieldNumber;
const int SensorDataFloat::kErrorFieldNumber;
const int SensorDataFloat::kStatusFieldNumber;
const int SensorDataFloat::kAlarmStepHighFieldNumber;
const int SensorDataFloat::kAlarmStepLowFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SensorDataFloat::SensorDataFloat()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:SensorDataFloat)
}
SensorDataFloat::SensorDataFloat(const SensorDataFloat& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&type_, &from.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&alarmsteplow_) -
    reinterpret_cast<char*>(&type_)) + sizeof(alarmsteplow_));
  // @@protoc_insertion_point(copy_constructor:SensorDataFloat)
}

void SensorDataFloat::SharedCtor() {
  ::memset(&type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&alarmsteplow_) -
      reinterpret_cast<char*>(&type_)) + sizeof(alarmsteplow_));
}

SensorDataFloat::~SensorDataFloat() {
  // @@protoc_insertion_point(destructor:SensorDataFloat)
  SharedDtor();
}

void SensorDataFloat::SharedDtor() {
}

void SensorDataFloat::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SensorDataFloat& SensorDataFloat::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_SensorDataFloat_MsgNode_5f1v1_5fm22_2eproto.base);
  return *internal_default_instance();
}


void SensorDataFloat::Clear() {
// @@protoc_insertion_point(message_clear_start:SensorDataFloat)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&alarmstephigh_) -
        reinterpret_cast<char*>(&type_)) + sizeof(alarmstephigh_));
  }
  alarmsteplow_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* SensorDataFloat::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .SensorType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::SensorType_IsValid(val))) {
            set_type(static_cast<::SensorType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional float data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          HasBitSetters::set_has_data(&has_bits);
          data_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float alarmHigh = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          HasBitSetters::set_has_alarmhigh(&has_bits);
          alarmhigh_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float alarmLow = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          HasBitSetters::set_has_alarmlow(&has_bits);
          alarmlow_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional sint32 calibration = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          HasBitSetters::set_has_calibration(&has_bits);
          calibration_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .SensorError error = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::SensorError_IsValid(val))) {
            set_error(static_cast<::SensorError>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional uint32 status = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          HasBitSetters::set_has_status(&has_bits);
          status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float alarmStepHigh = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 69)) {
          HasBitSetters::set_has_alarmstephigh(&has_bits);
          alarmstephigh_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float alarmStepLow = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 77)) {
          HasBitSetters::set_has_alarmsteplow(&has_bits);
          alarmsteplow_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool SensorDataFloat::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:SensorDataFloat)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .SensorType type = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::SensorType_IsValid(value)) {
            set_type(static_cast< ::SensorType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float data = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (21 & 0xFF)) {
          HasBitSetters::set_has_data(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &data_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float alarmHigh = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (29 & 0xFF)) {
          HasBitSetters::set_has_alarmhigh(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &alarmhigh_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float alarmLow = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (37 & 0xFF)) {
          HasBitSetters::set_has_alarmlow(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &alarmlow_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional sint32 calibration = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_calibration(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_SINT32>(
                 input, &calibration_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .SensorError error = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::SensorError_IsValid(value)) {
            set_error(static_cast< ::SensorError >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                6, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 status = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          HasBitSetters::set_has_status(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &status_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float alarmStepHigh = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (69 & 0xFF)) {
          HasBitSetters::set_has_alarmstephigh(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &alarmstephigh_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float alarmStepLow = 9;
      case 9: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (77 & 0xFF)) {
          HasBitSetters::set_has_alarmsteplow(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &alarmsteplow_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:SensorDataFloat)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:SensorDataFloat)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void SensorDataFloat::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:SensorDataFloat)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .SensorType type = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional float data = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(2, this->data(), output);
  }

  // optional float alarmHigh = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(3, this->alarmhigh(), output);
  }

  // optional float alarmLow = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(4, this->alarmlow(), output);
  }

  // optional sint32 calibration = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32(5, this->calibration(), output);
  }

  // optional .SensorError error = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      6, this->error(), output);
  }

  // optional uint32 status = 7;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(7, this->status(), output);
  }

  // optional float alarmStepHigh = 8;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(8, this->alarmstephigh(), output);
  }

  // optional float alarmStepLow = 9;
  if (cached_has_bits & 0x00000100u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(9, this->alarmsteplow(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:SensorDataFloat)
}

::PROTOBUF_NAMESPACE_ID::uint8* SensorDataFloat::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:SensorDataFloat)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .SensorType type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional float data = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->data(), target);
  }

  // optional float alarmHigh = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->alarmhigh(), target);
  }

  // optional float alarmLow = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->alarmlow(), target);
  }

  // optional sint32 calibration = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(5, this->calibration(), target);
  }

  // optional .SensorError error = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      6, this->error(), target);
  }

  // optional uint32 status = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(7, this->status(), target);
  }

  // optional float alarmStepHigh = 8;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(8, this->alarmstephigh(), target);
  }

  // optional float alarmStepLow = 9;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(9, this->alarmsteplow(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SensorDataFloat)
  return target;
}

size_t SensorDataFloat::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SensorDataFloat)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .SensorType type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional float data = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float alarmHigh = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float alarmLow = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional sint32 calibration = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32Size(
          this->calibration());
    }

    // optional .SensorError error = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->error());
    }

    // optional uint32 status = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->status());
    }

    // optional float alarmStepHigh = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  // optional float alarmStepLow = 9;
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 + 4;
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SensorDataFloat::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:SensorDataFloat)
  GOOGLE_DCHECK_NE(&from, this);
  const SensorDataFloat* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<SensorDataFloat>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:SensorDataFloat)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:SensorDataFloat)
    MergeFrom(*source);
  }
}

void SensorDataFloat::MergeFrom(const SensorDataFloat& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SensorDataFloat)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000002u) {
      data_ = from.data_;
    }
    if (cached_has_bits & 0x00000004u) {
      alarmhigh_ = from.alarmhigh_;
    }
    if (cached_has_bits & 0x00000008u) {
      alarmlow_ = from.alarmlow_;
    }
    if (cached_has_bits & 0x00000010u) {
      calibration_ = from.calibration_;
    }
    if (cached_has_bits & 0x00000020u) {
      error_ = from.error_;
    }
    if (cached_has_bits & 0x00000040u) {
      status_ = from.status_;
    }
    if (cached_has_bits & 0x00000080u) {
      alarmstephigh_ = from.alarmstephigh_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    set_alarmsteplow(from.alarmsteplow());
  }
}

void SensorDataFloat::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:SensorDataFloat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SensorDataFloat::CopyFrom(const SensorDataFloat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SensorDataFloat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SensorDataFloat::IsInitialized() const {
  return true;
}

void SensorDataFloat::Swap(SensorDataFloat* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SensorDataFloat::InternalSwap(SensorDataFloat* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(type_, other->type_);
  swap(data_, other->data_);
  swap(alarmhigh_, other->alarmhigh_);
  swap(alarmlow_, other->alarmlow_);
  swap(calibration_, other->calibration_);
  swap(error_, other->error_);
  swap(status_, other->status_);
  swap(alarmstephigh_, other->alarmstephigh_);
  swap(alarmsteplow_, other->alarmsteplow_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SensorDataFloat::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void MultiSensorData::InitAsDefaultInstance() {
}
class MultiSensorData::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<MultiSensorData>()._has_bits_);
  static void set_has_alarmhigh(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_alarmlow(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_calibration(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_alarmstephigh(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_alarmsteplow(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MultiSensorData::kDataFieldNumber;
const int MultiSensorData::kAlarmHighFieldNumber;
const int MultiSensorData::kAlarmLowFieldNumber;
const int MultiSensorData::kCalibrationFieldNumber;
const int MultiSensorData::kErrorFieldNumber;
const int MultiSensorData::kStatusFieldNumber;
const int MultiSensorData::kAlarmStepHighFieldNumber;
const int MultiSensorData::kAlarmStepLowFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

MultiSensorData::MultiSensorData()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MultiSensorData)
}
MultiSensorData::MultiSensorData(const MultiSensorData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      data_(from.data_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&alarmhigh_, &from.alarmhigh_,
    static_cast<size_t>(reinterpret_cast<char*>(&alarmsteplow_) -
    reinterpret_cast<char*>(&alarmhigh_)) + sizeof(alarmsteplow_));
  // @@protoc_insertion_point(copy_constructor:MultiSensorData)
}

void MultiSensorData::SharedCtor() {
  ::memset(&alarmhigh_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&alarmsteplow_) -
      reinterpret_cast<char*>(&alarmhigh_)) + sizeof(alarmsteplow_));
}

MultiSensorData::~MultiSensorData() {
  // @@protoc_insertion_point(destructor:MultiSensorData)
  SharedDtor();
}

void MultiSensorData::SharedDtor() {
}

void MultiSensorData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const MultiSensorData& MultiSensorData::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_MultiSensorData_MsgNode_5f1v1_5fm22_2eproto.base);
  return *internal_default_instance();
}


void MultiSensorData::Clear() {
// @@protoc_insertion_point(message_clear_start:MultiSensorData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  data_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&alarmhigh_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&alarmsteplow_) -
        reinterpret_cast<char*>(&alarmhigh_)) + sizeof(alarmsteplow_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* MultiSensorData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated float data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          ptr -= 1;
          do {
            ptr += 1;
            add_data(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
            ptr += sizeof(float);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 13);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(mutable_data(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float alarmHigh = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          HasBitSetters::set_has_alarmhigh(&has_bits);
          alarmhigh_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float alarmLow = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          HasBitSetters::set_has_alarmlow(&has_bits);
          alarmlow_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional uint32 calibration = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          HasBitSetters::set_has_calibration(&has_bits);
          calibration_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .SensorError error = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::SensorError_IsValid(val))) {
            set_error(static_cast<::SensorError>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional uint32 status = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          HasBitSetters::set_has_status(&has_bits);
          status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float alarmStepHigh = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 61)) {
          HasBitSetters::set_has_alarmstephigh(&has_bits);
          alarmstephigh_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float alarmStepLow = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 69)) {
          HasBitSetters::set_has_alarmsteplow(&has_bits);
          alarmsteplow_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool MultiSensorData::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:MultiSensorData)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated float data = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (13 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 13u, input, this->mutable_data())));
        } else if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_data())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float alarmHigh = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (21 & 0xFF)) {
          HasBitSetters::set_has_alarmhigh(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &alarmhigh_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float alarmLow = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (29 & 0xFF)) {
          HasBitSetters::set_has_alarmlow(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &alarmlow_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 calibration = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_calibration(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &calibration_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .SensorError error = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::SensorError_IsValid(value)) {
            set_error(static_cast< ::SensorError >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                5, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 status = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          HasBitSetters::set_has_status(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &status_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float alarmStepHigh = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (61 & 0xFF)) {
          HasBitSetters::set_has_alarmstephigh(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &alarmstephigh_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float alarmStepLow = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (69 & 0xFF)) {
          HasBitSetters::set_has_alarmsteplow(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &alarmsteplow_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MultiSensorData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MultiSensorData)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void MultiSensorData::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MultiSensorData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated float data = 1;
  for (int i = 0, n = this->data_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(
      1, this->data(i), output);
  }

  cached_has_bits = _has_bits_[0];
  // optional float alarmHigh = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(2, this->alarmhigh(), output);
  }

  // optional float alarmLow = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(3, this->alarmlow(), output);
  }

  // optional uint32 calibration = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->calibration(), output);
  }

  // optional .SensorError error = 5;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      5, this->error(), output);
  }

  // optional uint32 status = 6;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(6, this->status(), output);
  }

  // optional float alarmStepHigh = 7;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(7, this->alarmstephigh(), output);
  }

  // optional float alarmStepLow = 8;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(8, this->alarmsteplow(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:MultiSensorData)
}

::PROTOBUF_NAMESPACE_ID::uint8* MultiSensorData::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:MultiSensorData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated float data = 1;
  target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
    WriteFloatToArray(1, this->data_, target);

  cached_has_bits = _has_bits_[0];
  // optional float alarmHigh = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->alarmhigh(), target);
  }

  // optional float alarmLow = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->alarmlow(), target);
  }

  // optional uint32 calibration = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->calibration(), target);
  }

  // optional .SensorError error = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      5, this->error(), target);
  }

  // optional uint32 status = 6;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(6, this->status(), target);
  }

  // optional float alarmStepHigh = 7;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(7, this->alarmstephigh(), target);
  }

  // optional float alarmStepLow = 8;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(8, this->alarmsteplow(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MultiSensorData)
  return target;
}

size_t MultiSensorData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:MultiSensorData)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float data = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->data_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->data_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional float alarmHigh = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float alarmLow = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional uint32 calibration = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->calibration());
    }

    // optional .SensorError error = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->error());
    }

    // optional uint32 status = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->status());
    }

    // optional float alarmStepHigh = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float alarmStepLow = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MultiSensorData::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:MultiSensorData)
  GOOGLE_DCHECK_NE(&from, this);
  const MultiSensorData* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<MultiSensorData>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:MultiSensorData)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:MultiSensorData)
    MergeFrom(*source);
  }
}

void MultiSensorData::MergeFrom(const MultiSensorData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:MultiSensorData)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  data_.MergeFrom(from.data_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      alarmhigh_ = from.alarmhigh_;
    }
    if (cached_has_bits & 0x00000002u) {
      alarmlow_ = from.alarmlow_;
    }
    if (cached_has_bits & 0x00000004u) {
      calibration_ = from.calibration_;
    }
    if (cached_has_bits & 0x00000008u) {
      error_ = from.error_;
    }
    if (cached_has_bits & 0x00000010u) {
      status_ = from.status_;
    }
    if (cached_has_bits & 0x00000020u) {
      alarmstephigh_ = from.alarmstephigh_;
    }
    if (cached_has_bits & 0x00000040u) {
      alarmsteplow_ = from.alarmsteplow_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void MultiSensorData::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:MultiSensorData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MultiSensorData::CopyFrom(const MultiSensorData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:MultiSensorData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MultiSensorData::IsInitialized() const {
  return true;
}

void MultiSensorData::Swap(MultiSensorData* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MultiSensorData::InternalSwap(MultiSensorData* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  data_.InternalSwap(&other->data_);
  swap(alarmhigh_, other->alarmhigh_);
  swap(alarmlow_, other->alarmlow_);
  swap(calibration_, other->calibration_);
  swap(error_, other->error_);
  swap(status_, other->status_);
  swap(alarmstephigh_, other->alarmstephigh_);
  swap(alarmsteplow_, other->alarmsteplow_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MultiSensorData::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void MultiSensorDataInt::InitAsDefaultInstance() {
}
class MultiSensorDataInt::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<MultiSensorDataInt>()._has_bits_);
  static void set_has_alarmhigh(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_alarmlow(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_calibration(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_alarmstephigh(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_alarmsteplow(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MultiSensorDataInt::kDataFieldNumber;
const int MultiSensorDataInt::kAlarmHighFieldNumber;
const int MultiSensorDataInt::kAlarmLowFieldNumber;
const int MultiSensorDataInt::kCalibrationFieldNumber;
const int MultiSensorDataInt::kErrorFieldNumber;
const int MultiSensorDataInt::kStatusFieldNumber;
const int MultiSensorDataInt::kAlarmStepHighFieldNumber;
const int MultiSensorDataInt::kAlarmStepLowFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

MultiSensorDataInt::MultiSensorDataInt()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MultiSensorDataInt)
}
MultiSensorDataInt::MultiSensorDataInt(const MultiSensorDataInt& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      data_(from.data_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&alarmhigh_, &from.alarmhigh_,
    static_cast<size_t>(reinterpret_cast<char*>(&alarmsteplow_) -
    reinterpret_cast<char*>(&alarmhigh_)) + sizeof(alarmsteplow_));
  // @@protoc_insertion_point(copy_constructor:MultiSensorDataInt)
}

void MultiSensorDataInt::SharedCtor() {
  ::memset(&alarmhigh_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&alarmsteplow_) -
      reinterpret_cast<char*>(&alarmhigh_)) + sizeof(alarmsteplow_));
}

MultiSensorDataInt::~MultiSensorDataInt() {
  // @@protoc_insertion_point(destructor:MultiSensorDataInt)
  SharedDtor();
}

void MultiSensorDataInt::SharedDtor() {
}

void MultiSensorDataInt::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const MultiSensorDataInt& MultiSensorDataInt::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_MultiSensorDataInt_MsgNode_5f1v1_5fm22_2eproto.base);
  return *internal_default_instance();
}


void MultiSensorDataInt::Clear() {
// @@protoc_insertion_point(message_clear_start:MultiSensorDataInt)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  data_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&alarmhigh_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&alarmsteplow_) -
        reinterpret_cast<char*>(&alarmhigh_)) + sizeof(alarmsteplow_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* MultiSensorDataInt::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated sint32 data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            add_data(::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 8);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedSInt32Parser(mutable_data(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional sint32 alarmHigh = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          HasBitSetters::set_has_alarmhigh(&has_bits);
          alarmhigh_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional sint32 alarmLow = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          HasBitSetters::set_has_alarmlow(&has_bits);
          alarmlow_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 calibration = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          HasBitSetters::set_has_calibration(&has_bits);
          calibration_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .SensorError error = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::SensorError_IsValid(val))) {
            set_error(static_cast<::SensorError>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional uint32 status = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          HasBitSetters::set_has_status(&has_bits);
          status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional sint32 alarmStepHigh = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          HasBitSetters::set_has_alarmstephigh(&has_bits);
          alarmstephigh_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional sint32 alarmStepLow = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          HasBitSetters::set_has_alarmsteplow(&has_bits);
          alarmsteplow_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool MultiSensorDataInt::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:MultiSensorDataInt)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated sint32 data = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_SINT32>(
                 1, 8u, input, this->mutable_data())));
        } else if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_SINT32>(
                 input, this->mutable_data())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional sint32 alarmHigh = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_alarmhigh(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_SINT32>(
                 input, &alarmhigh_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional sint32 alarmLow = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_alarmlow(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_SINT32>(
                 input, &alarmlow_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 calibration = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_calibration(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &calibration_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .SensorError error = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::SensorError_IsValid(value)) {
            set_error(static_cast< ::SensorError >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                5, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 status = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          HasBitSetters::set_has_status(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &status_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional sint32 alarmStepHigh = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          HasBitSetters::set_has_alarmstephigh(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_SINT32>(
                 input, &alarmstephigh_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional sint32 alarmStepLow = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (64 & 0xFF)) {
          HasBitSetters::set_has_alarmsteplow(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_SINT32>(
                 input, &alarmsteplow_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MultiSensorDataInt)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MultiSensorDataInt)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void MultiSensorDataInt::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MultiSensorDataInt)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated sint32 data = 1;
  for (int i = 0, n = this->data_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32(
      1, this->data(i), output);
  }

  cached_has_bits = _has_bits_[0];
  // optional sint32 alarmHigh = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32(2, this->alarmhigh(), output);
  }

  // optional sint32 alarmLow = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32(3, this->alarmlow(), output);
  }

  // optional uint32 calibration = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->calibration(), output);
  }

  // optional .SensorError error = 5;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      5, this->error(), output);
  }

  // optional uint32 status = 6;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(6, this->status(), output);
  }

  // optional sint32 alarmStepHigh = 7;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32(7, this->alarmstephigh(), output);
  }

  // optional sint32 alarmStepLow = 8;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32(8, this->alarmsteplow(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:MultiSensorDataInt)
}

::PROTOBUF_NAMESPACE_ID::uint8* MultiSensorDataInt::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:MultiSensorDataInt)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated sint32 data = 1;
  target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
    WriteSInt32ToArray(1, this->data_, target);

  cached_has_bits = _has_bits_[0];
  // optional sint32 alarmHigh = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(2, this->alarmhigh(), target);
  }

  // optional sint32 alarmLow = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(3, this->alarmlow(), target);
  }

  // optional uint32 calibration = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->calibration(), target);
  }

  // optional .SensorError error = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      5, this->error(), target);
  }

  // optional uint32 status = 6;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(6, this->status(), target);
  }

  // optional sint32 alarmStepHigh = 7;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(7, this->alarmstephigh(), target);
  }

  // optional sint32 alarmStepLow = 8;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(8, this->alarmsteplow(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MultiSensorDataInt)
  return target;
}

size_t MultiSensorDataInt::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:MultiSensorDataInt)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated sint32 data = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      SInt32Size(this->data_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->data_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional sint32 alarmHigh = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32Size(
          this->alarmhigh());
    }

    // optional sint32 alarmLow = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32Size(
          this->alarmlow());
    }

    // optional uint32 calibration = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->calibration());
    }

    // optional .SensorError error = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->error());
    }

    // optional uint32 status = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->status());
    }

    // optional sint32 alarmStepHigh = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32Size(
          this->alarmstephigh());
    }

    // optional sint32 alarmStepLow = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32Size(
          this->alarmsteplow());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MultiSensorDataInt::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:MultiSensorDataInt)
  GOOGLE_DCHECK_NE(&from, this);
  const MultiSensorDataInt* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<MultiSensorDataInt>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:MultiSensorDataInt)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:MultiSensorDataInt)
    MergeFrom(*source);
  }
}

void MultiSensorDataInt::MergeFrom(const MultiSensorDataInt& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:MultiSensorDataInt)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  data_.MergeFrom(from.data_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      alarmhigh_ = from.alarmhigh_;
    }
    if (cached_has_bits & 0x00000002u) {
      alarmlow_ = from.alarmlow_;
    }
    if (cached_has_bits & 0x00000004u) {
      calibration_ = from.calibration_;
    }
    if (cached_has_bits & 0x00000008u) {
      error_ = from.error_;
    }
    if (cached_has_bits & 0x00000010u) {
      status_ = from.status_;
    }
    if (cached_has_bits & 0x00000020u) {
      alarmstephigh_ = from.alarmstephigh_;
    }
    if (cached_has_bits & 0x00000040u) {
      alarmsteplow_ = from.alarmsteplow_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void MultiSensorDataInt::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:MultiSensorDataInt)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MultiSensorDataInt::CopyFrom(const MultiSensorDataInt& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:MultiSensorDataInt)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MultiSensorDataInt::IsInitialized() const {
  return true;
}

void MultiSensorDataInt::Swap(MultiSensorDataInt* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MultiSensorDataInt::InternalSwap(MultiSensorDataInt* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  data_.InternalSwap(&other->data_);
  swap(alarmhigh_, other->alarmhigh_);
  swap(alarmlow_, other->alarmlow_);
  swap(calibration_, other->calibration_);
  swap(error_, other->error_);
  swap(status_, other->status_);
  swap(alarmstephigh_, other->alarmstephigh_);
  swap(alarmsteplow_, other->alarmsteplow_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MultiSensorDataInt::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void GpsData::InitAsDefaultInstance() {
}
class GpsData::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<GpsData>()._has_bits_);
  static void set_has_latitude(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_longitude(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_altitude(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GpsData::kLatitudeFieldNumber;
const int GpsData::kLongitudeFieldNumber;
const int GpsData::kAltitudeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GpsData::GpsData()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:GpsData)
}
GpsData::GpsData(const GpsData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&latitude_, &from.latitude_,
    static_cast<size_t>(reinterpret_cast<char*>(&altitude_) -
    reinterpret_cast<char*>(&latitude_)) + sizeof(altitude_));
  // @@protoc_insertion_point(copy_constructor:GpsData)
}

void GpsData::SharedCtor() {
  ::memset(&latitude_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&altitude_) -
      reinterpret_cast<char*>(&latitude_)) + sizeof(altitude_));
}

GpsData::~GpsData() {
  // @@protoc_insertion_point(destructor:GpsData)
  SharedDtor();
}

void GpsData::SharedDtor() {
}

void GpsData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const GpsData& GpsData::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_GpsData_MsgNode_5f1v1_5fm22_2eproto.base);
  return *internal_default_instance();
}


void GpsData::Clear() {
// @@protoc_insertion_point(message_clear_start:GpsData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&latitude_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&altitude_) -
        reinterpret_cast<char*>(&latitude_)) + sizeof(altitude_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* GpsData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional double latitude = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
          HasBitSetters::set_has_latitude(&has_bits);
          latitude_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double longitude = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 17)) {
          HasBitSetters::set_has_longitude(&has_bits);
          longitude_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double altitude = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 25)) {
          HasBitSetters::set_has_altitude(&has_bits);
          altitude_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool GpsData::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:GpsData)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double latitude = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (9 & 0xFF)) {
          HasBitSetters::set_has_latitude(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   double, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &latitude_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double longitude = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (17 & 0xFF)) {
          HasBitSetters::set_has_longitude(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   double, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &longitude_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double altitude = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (25 & 0xFF)) {
          HasBitSetters::set_has_altitude(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   double, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &altitude_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:GpsData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:GpsData)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void GpsData::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:GpsData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double latitude = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDouble(1, this->latitude(), output);
  }

  // optional double longitude = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDouble(2, this->longitude(), output);
  }

  // optional double altitude = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDouble(3, this->altitude(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:GpsData)
}

::PROTOBUF_NAMESPACE_ID::uint8* GpsData::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:GpsData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double latitude = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->latitude(), target);
  }

  // optional double longitude = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->longitude(), target);
  }

  // optional double altitude = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->altitude(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:GpsData)
  return target;
}

size_t GpsData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:GpsData)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional double latitude = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double longitude = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double altitude = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GpsData::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:GpsData)
  GOOGLE_DCHECK_NE(&from, this);
  const GpsData* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<GpsData>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:GpsData)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:GpsData)
    MergeFrom(*source);
  }
}

void GpsData::MergeFrom(const GpsData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:GpsData)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      latitude_ = from.latitude_;
    }
    if (cached_has_bits & 0x00000002u) {
      longitude_ = from.longitude_;
    }
    if (cached_has_bits & 0x00000004u) {
      altitude_ = from.altitude_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void GpsData::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:GpsData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GpsData::CopyFrom(const GpsData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:GpsData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GpsData::IsInitialized() const {
  return true;
}

void GpsData::Swap(GpsData* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GpsData::InternalSwap(GpsData* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(latitude_, other->latitude_);
  swap(longitude_, other->longitude_);
  swap(altitude_, other->altitude_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GpsData::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void AxisData::InitAsDefaultInstance() {
}
class AxisData::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<AxisData>()._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_z(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int AxisData::kXFieldNumber;
const int AxisData::kYFieldNumber;
const int AxisData::kZFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

AxisData::AxisData()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:AxisData)
}
AxisData::AxisData(const AxisData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&z_) -
    reinterpret_cast<char*>(&x_)) + sizeof(z_));
  // @@protoc_insertion_point(copy_constructor:AxisData)
}

void AxisData::SharedCtor() {
  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&z_) -
      reinterpret_cast<char*>(&x_)) + sizeof(z_));
}

AxisData::~AxisData() {
  // @@protoc_insertion_point(destructor:AxisData)
  SharedDtor();
}

void AxisData::SharedDtor() {
}

void AxisData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AxisData& AxisData::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AxisData_MsgNode_5f1v1_5fm22_2eproto.base);
  return *internal_default_instance();
}


void AxisData::Clear() {
// @@protoc_insertion_point(message_clear_start:AxisData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&z_) -
        reinterpret_cast<char*>(&x_)) + sizeof(z_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* AxisData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          HasBitSetters::set_has_x(&has_bits);
          x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          HasBitSetters::set_has_y(&has_bits);
          y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          HasBitSetters::set_has_z(&has_bits);
          z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool AxisData::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:AxisData)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float x = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (13 & 0xFF)) {
          HasBitSetters::set_has_x(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float y = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (21 & 0xFF)) {
          HasBitSetters::set_has_y(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float z = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (29 & 0xFF)) {
          HasBitSetters::set_has_z(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &z_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:AxisData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:AxisData)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void AxisData::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:AxisData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float x = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(1, this->x(), output);
  }

  // optional float y = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(2, this->y(), output);
  }

  // optional float z = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(3, this->z(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:AxisData)
}

::PROTOBUF_NAMESPACE_ID::uint8* AxisData::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:AxisData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->x(), target);
  }

  // optional float y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->y(), target);
  }

  // optional float z = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->z(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AxisData)
  return target;
}

size_t AxisData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AxisData)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional float x = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float y = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float z = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AxisData::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:AxisData)
  GOOGLE_DCHECK_NE(&from, this);
  const AxisData* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<AxisData>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:AxisData)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:AxisData)
    MergeFrom(*source);
  }
}

void AxisData::MergeFrom(const AxisData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AxisData)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      y_ = from.y_;
    }
    if (cached_has_bits & 0x00000004u) {
      z_ = from.z_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void AxisData::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:AxisData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AxisData::CopyFrom(const AxisData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AxisData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AxisData::IsInitialized() const {
  return true;
}

void AxisData::Swap(AxisData* other) {
  if (other == this) return;
  InternalSwap(other);
}
void AxisData::InternalSwap(AxisData* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(x_, other->x_);
  swap(y_, other->y_);
  swap(z_, other->z_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AxisData::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void iBeacon::InitAsDefaultInstance() {
}
class iBeacon::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<iBeacon>()._has_bits_);
  static void set_has_uuid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_major(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_minor(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_mrssi(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int iBeacon::kUuidFieldNumber;
const int iBeacon::kMajorFieldNumber;
const int iBeacon::kMinorFieldNumber;
const int iBeacon::kMrssiFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

iBeacon::iBeacon()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:iBeacon)
}
iBeacon::iBeacon(const iBeacon& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  uuid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_uuid()) {
    uuid_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.uuid_);
  }
  ::memcpy(&major_, &from.major_,
    static_cast<size_t>(reinterpret_cast<char*>(&mrssi_) -
    reinterpret_cast<char*>(&major_)) + sizeof(mrssi_));
  // @@protoc_insertion_point(copy_constructor:iBeacon)
}

void iBeacon::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_iBeacon_MsgNode_5f1v1_5fm22_2eproto.base);
  uuid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&major_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&mrssi_) -
      reinterpret_cast<char*>(&major_)) + sizeof(mrssi_));
}

iBeacon::~iBeacon() {
  // @@protoc_insertion_point(destructor:iBeacon)
  SharedDtor();
}

void iBeacon::SharedDtor() {
  uuid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void iBeacon::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const iBeacon& iBeacon::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_iBeacon_MsgNode_5f1v1_5fm22_2eproto.base);
  return *internal_default_instance();
}


void iBeacon::Clear() {
// @@protoc_insertion_point(message_clear_start:iBeacon)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    uuid_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&major_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&mrssi_) -
        reinterpret_cast<char*>(&major_)) + sizeof(mrssi_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* iBeacon::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional bytes uuid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_uuid(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 major = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          HasBitSetters::set_has_major(&has_bits);
          major_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 minor = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          HasBitSetters::set_has_minor(&has_bits);
          minor_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional sint32 mrssi = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          HasBitSetters::set_has_mrssi(&has_bits);
          mrssi_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool iBeacon::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:iBeacon)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes uuid = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_uuid()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 major = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_major(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &major_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 minor = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_minor(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &minor_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional sint32 mrssi = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_mrssi(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_SINT32>(
                 input, &mrssi_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:iBeacon)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:iBeacon)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void iBeacon::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:iBeacon)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes uuid = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->uuid(), output);
  }

  // optional uint32 major = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(2, this->major(), output);
  }

  // optional uint32 minor = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->minor(), output);
  }

  // optional sint32 mrssi = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32(4, this->mrssi(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:iBeacon)
}

::PROTOBUF_NAMESPACE_ID::uint8* iBeacon::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:iBeacon)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes uuid = 1;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        1, this->uuid(), target);
  }

  // optional uint32 major = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->major(), target);
  }

  // optional uint32 minor = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->minor(), target);
  }

  // optional sint32 mrssi = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(4, this->mrssi(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:iBeacon)
  return target;
}

size_t iBeacon::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:iBeacon)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes uuid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->uuid());
    }

    // optional uint32 major = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->major());
    }

    // optional uint32 minor = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->minor());
    }

    // optional sint32 mrssi = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32Size(
          this->mrssi());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void iBeacon::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:iBeacon)
  GOOGLE_DCHECK_NE(&from, this);
  const iBeacon* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<iBeacon>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:iBeacon)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:iBeacon)
    MergeFrom(*source);
  }
}

void iBeacon::MergeFrom(const iBeacon& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:iBeacon)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      uuid_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.uuid_);
    }
    if (cached_has_bits & 0x00000002u) {
      major_ = from.major_;
    }
    if (cached_has_bits & 0x00000004u) {
      minor_ = from.minor_;
    }
    if (cached_has_bits & 0x00000008u) {
      mrssi_ = from.mrssi_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void iBeacon::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:iBeacon)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void iBeacon::CopyFrom(const iBeacon& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:iBeacon)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool iBeacon::IsInitialized() const {
  return true;
}

void iBeacon::Swap(iBeacon* other) {
  if (other == this) return;
  InternalSwap(other);
}
void iBeacon::InternalSwap(iBeacon* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  uuid_.Swap(&other->uuid_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(major_, other->major_);
  swap(minor_, other->minor_);
  swap(mrssi_, other->mrssi_);
}

::PROTOBUF_NAMESPACE_ID::Metadata iBeacon::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void ExtSmoke::InitAsDefaultInstance() {
}
class ExtSmoke::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<ExtSmoke>()._has_bits_);
  static void set_has_bgsignal(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_bgsignalthreshold(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_bgsignalcalibration(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ExtSmoke::kBgSignalFieldNumber;
const int ExtSmoke::kBgSignalThresholdFieldNumber;
const int ExtSmoke::kBgSignalCalibrationFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ExtSmoke::ExtSmoke()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ExtSmoke)
}
ExtSmoke::ExtSmoke(const ExtSmoke& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&bgsignal_, &from.bgsignal_,
    static_cast<size_t>(reinterpret_cast<char*>(&bgsignalcalibration_) -
    reinterpret_cast<char*>(&bgsignal_)) + sizeof(bgsignalcalibration_));
  // @@protoc_insertion_point(copy_constructor:ExtSmoke)
}

void ExtSmoke::SharedCtor() {
  ::memset(&bgsignal_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&bgsignalcalibration_) -
      reinterpret_cast<char*>(&bgsignal_)) + sizeof(bgsignalcalibration_));
}

ExtSmoke::~ExtSmoke() {
  // @@protoc_insertion_point(destructor:ExtSmoke)
  SharedDtor();
}

void ExtSmoke::SharedDtor() {
}

void ExtSmoke::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ExtSmoke& ExtSmoke::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ExtSmoke_MsgNode_5f1v1_5fm22_2eproto.base);
  return *internal_default_instance();
}


void ExtSmoke::Clear() {
// @@protoc_insertion_point(message_clear_start:ExtSmoke)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&bgsignal_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&bgsignalcalibration_) -
        reinterpret_cast<char*>(&bgsignal_)) + sizeof(bgsignalcalibration_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ExtSmoke::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 bgSignal = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          HasBitSetters::set_has_bgsignal(&has_bits);
          bgsignal_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 bgSignalThreshold = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          HasBitSetters::set_has_bgsignalthreshold(&has_bits);
          bgsignalthreshold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 bgSignalCalibration = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          HasBitSetters::set_has_bgsignalcalibration(&has_bits);
          bgsignalcalibration_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ExtSmoke::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:ExtSmoke)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 bgSignal = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_bgsignal(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &bgsignal_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 bgSignalThreshold = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_bgsignalthreshold(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &bgsignalthreshold_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 bgSignalCalibration = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_bgsignalcalibration(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &bgsignalcalibration_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ExtSmoke)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ExtSmoke)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ExtSmoke::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ExtSmoke)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 bgSignal = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(1, this->bgsignal(), output);
  }

  // optional uint32 bgSignalThreshold = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(2, this->bgsignalthreshold(), output);
  }

  // optional uint32 bgSignalCalibration = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->bgsignalcalibration(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ExtSmoke)
}

::PROTOBUF_NAMESPACE_ID::uint8* ExtSmoke::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ExtSmoke)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 bgSignal = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->bgsignal(), target);
  }

  // optional uint32 bgSignalThreshold = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->bgsignalthreshold(), target);
  }

  // optional uint32 bgSignalCalibration = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->bgsignalcalibration(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ExtSmoke)
  return target;
}

size_t ExtSmoke::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ExtSmoke)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 bgSignal = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->bgsignal());
    }

    // optional uint32 bgSignalThreshold = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->bgsignalthreshold());
    }

    // optional uint32 bgSignalCalibration = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->bgsignalcalibration());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ExtSmoke::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:ExtSmoke)
  GOOGLE_DCHECK_NE(&from, this);
  const ExtSmoke* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ExtSmoke>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:ExtSmoke)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:ExtSmoke)
    MergeFrom(*source);
  }
}

void ExtSmoke::MergeFrom(const ExtSmoke& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ExtSmoke)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      bgsignal_ = from.bgsignal_;
    }
    if (cached_has_bits & 0x00000002u) {
      bgsignalthreshold_ = from.bgsignalthreshold_;
    }
    if (cached_has_bits & 0x00000004u) {
      bgsignalcalibration_ = from.bgsignalcalibration_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ExtSmoke::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:ExtSmoke)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ExtSmoke::CopyFrom(const ExtSmoke& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ExtSmoke)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExtSmoke::IsInitialized() const {
  return true;
}

void ExtSmoke::Swap(ExtSmoke* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ExtSmoke::InternalSwap(ExtSmoke* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(bgsignal_, other->bgsignal_);
  swap(bgsignalthreshold_, other->bgsignalthreshold_);
  swap(bgsignalcalibration_, other->bgsignalcalibration_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ExtSmoke::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void AppParam::InitAsDefaultInstance() {
}
class AppParam::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<AppParam>()._has_bits_);
  static void set_has_cmd(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_uploadinterval(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_synctime(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_nodestate(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_nodealarm(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_nodealarmset(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_confirm(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_smokectrl(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_uploadrepeat(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_alarmuploadinterval(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_alarmuploadnb(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_trackerctrl(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_trackeremergencytime(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_demomode(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int AppParam::kCmdFieldNumber;
const int AppParam::kUploadIntervalFieldNumber;
const int AppParam::kSyncTimeFieldNumber;
const int AppParam::kNodeStateFieldNumber;
const int AppParam::kNodeAlarmFieldNumber;
const int AppParam::kNodeAlarmSetFieldNumber;
const int AppParam::kConfirmFieldNumber;
const int AppParam::kSmokeCtrlFieldNumber;
const int AppParam::kUploadRepeatFieldNumber;
const int AppParam::kAlarmUploadIntervalFieldNumber;
const int AppParam::kAlarmUploadNbFieldNumber;
const int AppParam::kTrackerCtrlFieldNumber;
const int AppParam::kTrackerEmergencyTimeFieldNumber;
const int AppParam::kDemoModeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

AppParam::AppParam()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:AppParam)
}
AppParam::AppParam(const AppParam& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&cmd_, &from.cmd_,
    static_cast<size_t>(reinterpret_cast<char*>(&demomode_) -
    reinterpret_cast<char*>(&cmd_)) + sizeof(demomode_));
  // @@protoc_insertion_point(copy_constructor:AppParam)
}

void AppParam::SharedCtor() {
  ::memset(&cmd_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&demomode_) -
      reinterpret_cast<char*>(&cmd_)) + sizeof(demomode_));
}

AppParam::~AppParam() {
  // @@protoc_insertion_point(destructor:AppParam)
  SharedDtor();
}

void AppParam::SharedDtor() {
}

void AppParam::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AppParam& AppParam::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AppParam_MsgNode_5f1v1_5fm22_2eproto.base);
  return *internal_default_instance();
}


void AppParam::Clear() {
// @@protoc_insertion_point(message_clear_start:AppParam)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&cmd_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&smokectrl_) -
        reinterpret_cast<char*>(&cmd_)) + sizeof(smokectrl_));
  }
  if (cached_has_bits & 0x00003f00u) {
    ::memset(&uploadrepeat_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&demomode_) -
        reinterpret_cast<char*>(&uploadrepeat_)) + sizeof(demomode_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* AppParam::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .AppCmd cmd = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::AppCmd_IsValid(val))) {
            set_cmd(static_cast<::AppCmd>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional uint32 uploadInterval = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          HasBitSetters::set_has_uploadinterval(&has_bits);
          uploadinterval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 syncTime = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          HasBitSetters::set_has_synctime(&has_bits);
          synctime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .NodeState nodeState = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::NodeState_IsValid(val))) {
            set_nodestate(static_cast<::NodeState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .NodeAlarm nodeAlarm = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::NodeAlarm_IsValid(val))) {
            set_nodealarm(static_cast<::NodeAlarm>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional uint32 nodeAlarmSet = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          HasBitSetters::set_has_nodealarmset(&has_bits);
          nodealarmset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 confirm = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          HasBitSetters::set_has_confirm(&has_bits);
          confirm_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .SmokeCtrl smokeCtrl = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::SmokeCtrl_IsValid(val))) {
            set_smokectrl(static_cast<::SmokeCtrl>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(8, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional uint32 uploadRepeat = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          HasBitSetters::set_has_uploadrepeat(&has_bits);
          uploadrepeat_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 alarmUploadInterval = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          HasBitSetters::set_has_alarmuploadinterval(&has_bits);
          alarmuploadinterval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 alarmUploadNb = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          HasBitSetters::set_has_alarmuploadnb(&has_bits);
          alarmuploadnb_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .TrackerCtrl trackerCtrl = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TrackerCtrl_IsValid(val))) {
            set_trackerctrl(static_cast<::TrackerCtrl>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(12, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional uint32 trackerEmergencyTime = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          HasBitSetters::set_has_trackeremergencytime(&has_bits);
          trackeremergencytime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 demoMode = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 112)) {
          HasBitSetters::set_has_demomode(&has_bits);
          demomode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool AppParam::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:AppParam)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .AppCmd cmd = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::AppCmd_IsValid(value)) {
            set_cmd(static_cast< ::AppCmd >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 uploadInterval = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_uploadinterval(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &uploadinterval_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 syncTime = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_synctime(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &synctime_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .NodeState nodeState = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::NodeState_IsValid(value)) {
            set_nodestate(static_cast< ::NodeState >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                4, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .NodeAlarm nodeAlarm = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::NodeAlarm_IsValid(value)) {
            set_nodealarm(static_cast< ::NodeAlarm >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                5, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 nodeAlarmSet = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          HasBitSetters::set_has_nodealarmset(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &nodealarmset_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 confirm = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          HasBitSetters::set_has_confirm(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &confirm_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .SmokeCtrl smokeCtrl = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (64 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::SmokeCtrl_IsValid(value)) {
            set_smokectrl(static_cast< ::SmokeCtrl >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                8, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 uploadRepeat = 9;
      case 9: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (72 & 0xFF)) {
          HasBitSetters::set_has_uploadrepeat(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &uploadrepeat_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 alarmUploadInterval = 10;
      case 10: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (80 & 0xFF)) {
          HasBitSetters::set_has_alarmuploadinterval(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &alarmuploadinterval_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 alarmUploadNb = 11;
      case 11: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (88 & 0xFF)) {
          HasBitSetters::set_has_alarmuploadnb(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &alarmuploadnb_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .TrackerCtrl trackerCtrl = 12;
      case 12: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (96 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::TrackerCtrl_IsValid(value)) {
            set_trackerctrl(static_cast< ::TrackerCtrl >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                12, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 trackerEmergencyTime = 13;
      case 13: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (104 & 0xFF)) {
          HasBitSetters::set_has_trackeremergencytime(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &trackeremergencytime_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 demoMode = 14;
      case 14: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (112 & 0xFF)) {
          HasBitSetters::set_has_demomode(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &demomode_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:AppParam)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:AppParam)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void AppParam::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:AppParam)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .AppCmd cmd = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->cmd(), output);
  }

  // optional uint32 uploadInterval = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(2, this->uploadinterval(), output);
  }

  // optional uint32 syncTime = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->synctime(), output);
  }

  // optional .NodeState nodeState = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      4, this->nodestate(), output);
  }

  // optional .NodeAlarm nodeAlarm = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      5, this->nodealarm(), output);
  }

  // optional uint32 nodeAlarmSet = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(6, this->nodealarmset(), output);
  }

  // optional uint32 confirm = 7;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(7, this->confirm(), output);
  }

  // optional .SmokeCtrl smokeCtrl = 8;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      8, this->smokectrl(), output);
  }

  // optional uint32 uploadRepeat = 9;
  if (cached_has_bits & 0x00000100u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(9, this->uploadrepeat(), output);
  }

  // optional uint32 alarmUploadInterval = 10;
  if (cached_has_bits & 0x00000200u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(10, this->alarmuploadinterval(), output);
  }

  // optional uint32 alarmUploadNb = 11;
  if (cached_has_bits & 0x00000400u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(11, this->alarmuploadnb(), output);
  }

  // optional .TrackerCtrl trackerCtrl = 12;
  if (cached_has_bits & 0x00000800u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      12, this->trackerctrl(), output);
  }

  // optional uint32 trackerEmergencyTime = 13;
  if (cached_has_bits & 0x00001000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(13, this->trackeremergencytime(), output);
  }

  // optional uint32 demoMode = 14;
  if (cached_has_bits & 0x00002000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(14, this->demomode(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:AppParam)
}

::PROTOBUF_NAMESPACE_ID::uint8* AppParam::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:AppParam)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .AppCmd cmd = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->cmd(), target);
  }

  // optional uint32 uploadInterval = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->uploadinterval(), target);
  }

  // optional uint32 syncTime = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->synctime(), target);
  }

  // optional .NodeState nodeState = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->nodestate(), target);
  }

  // optional .NodeAlarm nodeAlarm = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      5, this->nodealarm(), target);
  }

  // optional uint32 nodeAlarmSet = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(6, this->nodealarmset(), target);
  }

  // optional uint32 confirm = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(7, this->confirm(), target);
  }

  // optional .SmokeCtrl smokeCtrl = 8;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      8, this->smokectrl(), target);
  }

  // optional uint32 uploadRepeat = 9;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(9, this->uploadrepeat(), target);
  }

  // optional uint32 alarmUploadInterval = 10;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(10, this->alarmuploadinterval(), target);
  }

  // optional uint32 alarmUploadNb = 11;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(11, this->alarmuploadnb(), target);
  }

  // optional .TrackerCtrl trackerCtrl = 12;
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      12, this->trackerctrl(), target);
  }

  // optional uint32 trackerEmergencyTime = 13;
  if (cached_has_bits & 0x00001000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(13, this->trackeremergencytime(), target);
  }

  // optional uint32 demoMode = 14;
  if (cached_has_bits & 0x00002000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(14, this->demomode(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AppParam)
  return target;
}

size_t AppParam::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AppParam)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .AppCmd cmd = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->cmd());
    }

    // optional uint32 uploadInterval = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->uploadinterval());
    }

    // optional uint32 syncTime = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->synctime());
    }

    // optional .NodeState nodeState = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->nodestate());
    }

    // optional .NodeAlarm nodeAlarm = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->nodealarm());
    }

    // optional uint32 nodeAlarmSet = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->nodealarmset());
    }

    // optional uint32 confirm = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->confirm());
    }

    // optional .SmokeCtrl smokeCtrl = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->smokectrl());
    }

  }
  if (cached_has_bits & 0x00003f00u) {
    // optional uint32 uploadRepeat = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->uploadrepeat());
    }

    // optional uint32 alarmUploadInterval = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->alarmuploadinterval());
    }

    // optional uint32 alarmUploadNb = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->alarmuploadnb());
    }

    // optional .TrackerCtrl trackerCtrl = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->trackerctrl());
    }

    // optional uint32 trackerEmergencyTime = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->trackeremergencytime());
    }

    // optional uint32 demoMode = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->demomode());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AppParam::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:AppParam)
  GOOGLE_DCHECK_NE(&from, this);
  const AppParam* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<AppParam>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:AppParam)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:AppParam)
    MergeFrom(*source);
  }
}

void AppParam::MergeFrom(const AppParam& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AppParam)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      cmd_ = from.cmd_;
    }
    if (cached_has_bits & 0x00000002u) {
      uploadinterval_ = from.uploadinterval_;
    }
    if (cached_has_bits & 0x00000004u) {
      synctime_ = from.synctime_;
    }
    if (cached_has_bits & 0x00000008u) {
      nodestate_ = from.nodestate_;
    }
    if (cached_has_bits & 0x00000010u) {
      nodealarm_ = from.nodealarm_;
    }
    if (cached_has_bits & 0x00000020u) {
      nodealarmset_ = from.nodealarmset_;
    }
    if (cached_has_bits & 0x00000040u) {
      confirm_ = from.confirm_;
    }
    if (cached_has_bits & 0x00000080u) {
      smokectrl_ = from.smokectrl_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00003f00u) {
    if (cached_has_bits & 0x00000100u) {
      uploadrepeat_ = from.uploadrepeat_;
    }
    if (cached_has_bits & 0x00000200u) {
      alarmuploadinterval_ = from.alarmuploadinterval_;
    }
    if (cached_has_bits & 0x00000400u) {
      alarmuploadnb_ = from.alarmuploadnb_;
    }
    if (cached_has_bits & 0x00000800u) {
      trackerctrl_ = from.trackerctrl_;
    }
    if (cached_has_bits & 0x00001000u) {
      trackeremergencytime_ = from.trackeremergencytime_;
    }
    if (cached_has_bits & 0x00002000u) {
      demomode_ = from.demomode_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void AppParam::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:AppParam)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AppParam::CopyFrom(const AppParam& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AppParam)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AppParam::IsInitialized() const {
  return true;
}

void AppParam::Swap(AppParam* other) {
  if (other == this) return;
  InternalSwap(other);
}
void AppParam::InternalSwap(AppParam* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(cmd_, other->cmd_);
  swap(uploadinterval_, other->uploadinterval_);
  swap(synctime_, other->synctime_);
  swap(nodestate_, other->nodestate_);
  swap(nodealarm_, other->nodealarm_);
  swap(nodealarmset_, other->nodealarmset_);
  swap(confirm_, other->confirm_);
  swap(smokectrl_, other->smokectrl_);
  swap(uploadrepeat_, other->uploadrepeat_);
  swap(alarmuploadinterval_, other->alarmuploadinterval_);
  swap(alarmuploadnb_, other->alarmuploadnb_);
  swap(trackerctrl_, other->trackerctrl_);
  swap(trackeremergencytime_, other->trackeremergencytime_);
  swap(demomode_, other->demomode_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AppParam::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void ElecFireData::InitAsDefaultInstance() {
}
class ElecFireData::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<ElecFireData>()._has_bits_);
  static void set_has_vol_val(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_curr_val(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_leakage_val(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_power_val(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_elec_energy_val(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_temp_val(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_alarm(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_sensorpwd(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_leakageth(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_tempth(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_currentth(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_loadth(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_volhighth(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_vollowth(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_cmd(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_autoswitch(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ElecFireData::kVolValFieldNumber;
const int ElecFireData::kCurrValFieldNumber;
const int ElecFireData::kLeakageValFieldNumber;
const int ElecFireData::kPowerValFieldNumber;
const int ElecFireData::kElecEnergyValFieldNumber;
const int ElecFireData::kTempValFieldNumber;
const int ElecFireData::kStatusFieldNumber;
const int ElecFireData::kAlarmFieldNumber;
const int ElecFireData::kErrorFieldNumber;
const int ElecFireData::kSensorPwdFieldNumber;
const int ElecFireData::kLeakageThFieldNumber;
const int ElecFireData::kTempThFieldNumber;
const int ElecFireData::kCurrentThFieldNumber;
const int ElecFireData::kLoadThFieldNumber;
const int ElecFireData::kVolHighThFieldNumber;
const int ElecFireData::kVolLowThFieldNumber;
const int ElecFireData::kCmdFieldNumber;
const int ElecFireData::kAutoSwitchFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ElecFireData::ElecFireData()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ElecFireData)
}
ElecFireData::ElecFireData(const ElecFireData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&vol_val_, &from.vol_val_,
    static_cast<size_t>(reinterpret_cast<char*>(&autoswitch_) -
    reinterpret_cast<char*>(&vol_val_)) + sizeof(autoswitch_));
  // @@protoc_insertion_point(copy_constructor:ElecFireData)
}

void ElecFireData::SharedCtor() {
  ::memset(&vol_val_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&autoswitch_) -
      reinterpret_cast<char*>(&vol_val_)) + sizeof(autoswitch_));
}

ElecFireData::~ElecFireData() {
  // @@protoc_insertion_point(destructor:ElecFireData)
  SharedDtor();
}

void ElecFireData::SharedDtor() {
}

void ElecFireData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ElecFireData& ElecFireData::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ElecFireData_MsgNode_5f1v1_5fm22_2eproto.base);
  return *internal_default_instance();
}


void ElecFireData::Clear() {
// @@protoc_insertion_point(message_clear_start:ElecFireData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&vol_val_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&alarm_) -
        reinterpret_cast<char*>(&vol_val_)) + sizeof(alarm_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&error_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&vollowth_) -
        reinterpret_cast<char*>(&error_)) + sizeof(vollowth_));
  }
  if (cached_has_bits & 0x00030000u) {
    ::memset(&cmd_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&autoswitch_) -
        reinterpret_cast<char*>(&cmd_)) + sizeof(autoswitch_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ElecFireData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional sint32 vol_val = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          HasBitSetters::set_has_vol_val(&has_bits);
          vol_val_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 curr_val = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          HasBitSetters::set_has_curr_val(&has_bits);
          curr_val_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional sint32 leakage_val = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          HasBitSetters::set_has_leakage_val(&has_bits);
          leakage_val_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 power_val = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          HasBitSetters::set_has_power_val(&has_bits);
          power_val_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 elec_energy_val = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          HasBitSetters::set_has_elec_energy_val(&has_bits);
          elec_energy_val_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 temp_val = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          HasBitSetters::set_has_temp_val(&has_bits);
          temp_val_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 status = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          HasBitSetters::set_has_status(&has_bits);
          status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 alarm = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          HasBitSetters::set_has_alarm(&has_bits);
          alarm_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 error = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          HasBitSetters::set_has_error(&has_bits);
          error_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 sensorPwd = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          HasBitSetters::set_has_sensorpwd(&has_bits);
          sensorpwd_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 leakageTh = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          HasBitSetters::set_has_leakageth(&has_bits);
          leakageth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 tempTh = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          HasBitSetters::set_has_tempth(&has_bits);
          tempth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 currentTh = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          HasBitSetters::set_has_currentth(&has_bits);
          currentth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 loadTh = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 112)) {
          HasBitSetters::set_has_loadth(&has_bits);
          loadth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 volHighTh = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 120)) {
          HasBitSetters::set_has_volhighth(&has_bits);
          volhighth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 volLowTh = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 128)) {
          HasBitSetters::set_has_vollowth(&has_bits);
          vollowth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 cmd = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 136)) {
          HasBitSetters::set_has_cmd(&has_bits);
          cmd_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 autoSwitch = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 144)) {
          HasBitSetters::set_has_autoswitch(&has_bits);
          autoswitch_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ElecFireData::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:ElecFireData)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional sint32 vol_val = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_vol_val(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_SINT32>(
                 input, &vol_val_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 curr_val = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_curr_val(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &curr_val_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional sint32 leakage_val = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_leakage_val(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_SINT32>(
                 input, &leakage_val_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 power_val = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_power_val(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &power_val_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 elec_energy_val = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_elec_energy_val(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &elec_energy_val_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 temp_val = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          HasBitSetters::set_has_temp_val(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &temp_val_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 status = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          HasBitSetters::set_has_status(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &status_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 alarm = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (64 & 0xFF)) {
          HasBitSetters::set_has_alarm(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &alarm_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 error = 9;
      case 9: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (72 & 0xFF)) {
          HasBitSetters::set_has_error(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &error_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 sensorPwd = 10;
      case 10: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (80 & 0xFF)) {
          HasBitSetters::set_has_sensorpwd(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sensorpwd_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 leakageTh = 11;
      case 11: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (88 & 0xFF)) {
          HasBitSetters::set_has_leakageth(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &leakageth_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 tempTh = 12;
      case 12: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (96 & 0xFF)) {
          HasBitSetters::set_has_tempth(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &tempth_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 currentTh = 13;
      case 13: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (104 & 0xFF)) {
          HasBitSetters::set_has_currentth(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &currentth_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 loadTh = 14;
      case 14: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (112 & 0xFF)) {
          HasBitSetters::set_has_loadth(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &loadth_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 volHighTh = 15;
      case 15: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (120 & 0xFF)) {
          HasBitSetters::set_has_volhighth(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &volhighth_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 volLowTh = 16;
      case 16: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (128 & 0xFF)) {
          HasBitSetters::set_has_vollowth(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &vollowth_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 cmd = 17;
      case 17: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (136 & 0xFF)) {
          HasBitSetters::set_has_cmd(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cmd_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 autoSwitch = 18;
      case 18: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (144 & 0xFF)) {
          HasBitSetters::set_has_autoswitch(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &autoswitch_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ElecFireData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ElecFireData)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ElecFireData::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ElecFireData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional sint32 vol_val = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32(1, this->vol_val(), output);
  }

  // optional uint32 curr_val = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(2, this->curr_val(), output);
  }

  // optional sint32 leakage_val = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32(3, this->leakage_val(), output);
  }

  // optional uint32 power_val = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->power_val(), output);
  }

  // optional uint32 elec_energy_val = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(5, this->elec_energy_val(), output);
  }

  // optional uint32 temp_val = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(6, this->temp_val(), output);
  }

  // optional uint32 status = 7;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(7, this->status(), output);
  }

  // optional uint32 alarm = 8;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(8, this->alarm(), output);
  }

  // optional uint32 error = 9;
  if (cached_has_bits & 0x00000100u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(9, this->error(), output);
  }

  // optional uint32 sensorPwd = 10;
  if (cached_has_bits & 0x00000200u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(10, this->sensorpwd(), output);
  }

  // optional uint32 leakageTh = 11;
  if (cached_has_bits & 0x00000400u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(11, this->leakageth(), output);
  }

  // optional uint32 tempTh = 12;
  if (cached_has_bits & 0x00000800u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(12, this->tempth(), output);
  }

  // optional uint32 currentTh = 13;
  if (cached_has_bits & 0x00001000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(13, this->currentth(), output);
  }

  // optional uint32 loadTh = 14;
  if (cached_has_bits & 0x00002000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(14, this->loadth(), output);
  }

  // optional uint32 volHighTh = 15;
  if (cached_has_bits & 0x00004000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(15, this->volhighth(), output);
  }

  // optional uint32 volLowTh = 16;
  if (cached_has_bits & 0x00008000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(16, this->vollowth(), output);
  }

  // optional uint32 cmd = 17;
  if (cached_has_bits & 0x00010000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(17, this->cmd(), output);
  }

  // optional uint32 autoSwitch = 18;
  if (cached_has_bits & 0x00020000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(18, this->autoswitch(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ElecFireData)
}

::PROTOBUF_NAMESPACE_ID::uint8* ElecFireData::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ElecFireData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional sint32 vol_val = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(1, this->vol_val(), target);
  }

  // optional uint32 curr_val = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->curr_val(), target);
  }

  // optional sint32 leakage_val = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(3, this->leakage_val(), target);
  }

  // optional uint32 power_val = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->power_val(), target);
  }

  // optional uint32 elec_energy_val = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->elec_energy_val(), target);
  }

  // optional uint32 temp_val = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(6, this->temp_val(), target);
  }

  // optional uint32 status = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(7, this->status(), target);
  }

  // optional uint32 alarm = 8;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(8, this->alarm(), target);
  }

  // optional uint32 error = 9;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(9, this->error(), target);
  }

  // optional uint32 sensorPwd = 10;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(10, this->sensorpwd(), target);
  }

  // optional uint32 leakageTh = 11;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(11, this->leakageth(), target);
  }

  // optional uint32 tempTh = 12;
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(12, this->tempth(), target);
  }

  // optional uint32 currentTh = 13;
  if (cached_has_bits & 0x00001000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(13, this->currentth(), target);
  }

  // optional uint32 loadTh = 14;
  if (cached_has_bits & 0x00002000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(14, this->loadth(), target);
  }

  // optional uint32 volHighTh = 15;
  if (cached_has_bits & 0x00004000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(15, this->volhighth(), target);
  }

  // optional uint32 volLowTh = 16;
  if (cached_has_bits & 0x00008000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(16, this->vollowth(), target);
  }

  // optional uint32 cmd = 17;
  if (cached_has_bits & 0x00010000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(17, this->cmd(), target);
  }

  // optional uint32 autoSwitch = 18;
  if (cached_has_bits & 0x00020000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(18, this->autoswitch(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ElecFireData)
  return target;
}

size_t ElecFireData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ElecFireData)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional sint32 vol_val = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32Size(
          this->vol_val());
    }

    // optional uint32 curr_val = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->curr_val());
    }

    // optional sint32 leakage_val = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32Size(
          this->leakage_val());
    }

    // optional uint32 power_val = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->power_val());
    }

    // optional uint32 elec_energy_val = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->elec_energy_val());
    }

    // optional uint32 temp_val = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->temp_val());
    }

    // optional uint32 status = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->status());
    }

    // optional uint32 alarm = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->alarm());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional uint32 error = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->error());
    }

    // optional uint32 sensorPwd = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->sensorpwd());
    }

    // optional uint32 leakageTh = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->leakageth());
    }

    // optional uint32 tempTh = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->tempth());
    }

    // optional uint32 currentTh = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->currentth());
    }

    // optional uint32 loadTh = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->loadth());
    }

    // optional uint32 volHighTh = 15;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->volhighth());
    }

    // optional uint32 volLowTh = 16;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->vollowth());
    }

  }
  if (cached_has_bits & 0x00030000u) {
    // optional uint32 cmd = 17;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->cmd());
    }

    // optional uint32 autoSwitch = 18;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->autoswitch());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ElecFireData::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:ElecFireData)
  GOOGLE_DCHECK_NE(&from, this);
  const ElecFireData* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ElecFireData>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:ElecFireData)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:ElecFireData)
    MergeFrom(*source);
  }
}

void ElecFireData::MergeFrom(const ElecFireData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ElecFireData)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      vol_val_ = from.vol_val_;
    }
    if (cached_has_bits & 0x00000002u) {
      curr_val_ = from.curr_val_;
    }
    if (cached_has_bits & 0x00000004u) {
      leakage_val_ = from.leakage_val_;
    }
    if (cached_has_bits & 0x00000008u) {
      power_val_ = from.power_val_;
    }
    if (cached_has_bits & 0x00000010u) {
      elec_energy_val_ = from.elec_energy_val_;
    }
    if (cached_has_bits & 0x00000020u) {
      temp_val_ = from.temp_val_;
    }
    if (cached_has_bits & 0x00000040u) {
      status_ = from.status_;
    }
    if (cached_has_bits & 0x00000080u) {
      alarm_ = from.alarm_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      error_ = from.error_;
    }
    if (cached_has_bits & 0x00000200u) {
      sensorpwd_ = from.sensorpwd_;
    }
    if (cached_has_bits & 0x00000400u) {
      leakageth_ = from.leakageth_;
    }
    if (cached_has_bits & 0x00000800u) {
      tempth_ = from.tempth_;
    }
    if (cached_has_bits & 0x00001000u) {
      currentth_ = from.currentth_;
    }
    if (cached_has_bits & 0x00002000u) {
      loadth_ = from.loadth_;
    }
    if (cached_has_bits & 0x00004000u) {
      volhighth_ = from.volhighth_;
    }
    if (cached_has_bits & 0x00008000u) {
      vollowth_ = from.vollowth_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00030000u) {
    if (cached_has_bits & 0x00010000u) {
      cmd_ = from.cmd_;
    }
    if (cached_has_bits & 0x00020000u) {
      autoswitch_ = from.autoswitch_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ElecFireData::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:ElecFireData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ElecFireData::CopyFrom(const ElecFireData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ElecFireData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ElecFireData::IsInitialized() const {
  return true;
}

void ElecFireData::Swap(ElecFireData* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ElecFireData::InternalSwap(ElecFireData* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(vol_val_, other->vol_val_);
  swap(curr_val_, other->curr_val_);
  swap(leakage_val_, other->leakage_val_);
  swap(power_val_, other->power_val_);
  swap(elec_energy_val_, other->elec_energy_val_);
  swap(temp_val_, other->temp_val_);
  swap(status_, other->status_);
  swap(alarm_, other->alarm_);
  swap(error_, other->error_);
  swap(sensorpwd_, other->sensorpwd_);
  swap(leakageth_, other->leakageth_);
  swap(tempth_, other->tempth_);
  swap(currentth_, other->currentth_);
  swap(loadth_, other->loadth_);
  swap(volhighth_, other->volhighth_);
  swap(vollowth_, other->vollowth_);
  swap(cmd_, other->cmd_);
  swap(autoswitch_, other->autoswitch_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ElecFireData::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void MantunData::InitAsDefaultInstance() {
}
class MantunData::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<MantunData>()._has_bits_);
  static void set_has_volval(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_leakageval(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_powerval(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_tempval(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_currval(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_kwhval(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_swonoff(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_volhighth(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_vollowth(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_leakageth(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_tempth(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_currentth(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_powerth(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_attribute(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_cmd(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_deverror(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MantunData::kVolValFieldNumber;
const int MantunData::kLeakageValFieldNumber;
const int MantunData::kPowerValFieldNumber;
const int MantunData::kTempValFieldNumber;
const int MantunData::kCurrValFieldNumber;
const int MantunData::kStatusFieldNumber;
const int MantunData::kKwhValFieldNumber;
const int MantunData::kSwOnOffFieldNumber;
const int MantunData::kVolHighThFieldNumber;
const int MantunData::kVolLowThFieldNumber;
const int MantunData::kLeakageThFieldNumber;
const int MantunData::kTempThFieldNumber;
const int MantunData::kCurrentThFieldNumber;
const int MantunData::kPowerThFieldNumber;
const int MantunData::kAttributeFieldNumber;
const int MantunData::kCmdFieldNumber;
const int MantunData::kDevErrorFieldNumber;
const int MantunData::kVersionFieldNumber;
const int MantunData::kIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

MantunData::MantunData()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MantunData)
}
MantunData::MantunData(const MantunData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&volval_, &from.volval_,
    static_cast<size_t>(reinterpret_cast<char*>(&id_) -
    reinterpret_cast<char*>(&volval_)) + sizeof(id_));
  // @@protoc_insertion_point(copy_constructor:MantunData)
}

void MantunData::SharedCtor() {
  ::memset(&volval_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&id_) -
      reinterpret_cast<char*>(&volval_)) + sizeof(id_));
}

MantunData::~MantunData() {
  // @@protoc_insertion_point(destructor:MantunData)
  SharedDtor();
}

void MantunData::SharedDtor() {
}

void MantunData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const MantunData& MantunData::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_MantunData_MsgNode_5f1v1_5fm22_2eproto.base);
  return *internal_default_instance();
}


void MantunData::Clear() {
// @@protoc_insertion_point(message_clear_start:MantunData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&volval_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&swonoff_) -
        reinterpret_cast<char*>(&volval_)) + sizeof(swonoff_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&volhighth_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&cmd_) -
        reinterpret_cast<char*>(&volhighth_)) + sizeof(cmd_));
  }
  if (cached_has_bits & 0x00070000u) {
    ::memset(&deverror_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&id_) -
        reinterpret_cast<char*>(&deverror_)) + sizeof(id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* MantunData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 volVal = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          HasBitSetters::set_has_volval(&has_bits);
          volval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 leakageVal = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          HasBitSetters::set_has_leakageval(&has_bits);
          leakageval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 powerVal = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          HasBitSetters::set_has_powerval(&has_bits);
          powerval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 tempVal = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          HasBitSetters::set_has_tempval(&has_bits);
          tempval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 currVal = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          HasBitSetters::set_has_currval(&has_bits);
          currval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 status = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          HasBitSetters::set_has_status(&has_bits);
          status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 kwhVal = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          HasBitSetters::set_has_kwhval(&has_bits);
          kwhval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 swOnOff = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          HasBitSetters::set_has_swonoff(&has_bits);
          swonoff_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 volHighTh = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          HasBitSetters::set_has_volhighth(&has_bits);
          volhighth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 volLowTh = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          HasBitSetters::set_has_vollowth(&has_bits);
          vollowth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 leakageTh = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          HasBitSetters::set_has_leakageth(&has_bits);
          leakageth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 tempTh = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          HasBitSetters::set_has_tempth(&has_bits);
          tempth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 currentTh = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          HasBitSetters::set_has_currentth(&has_bits);
          currentth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 powerTh = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 112)) {
          HasBitSetters::set_has_powerth(&has_bits);
          powerth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 attribute = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 120)) {
          HasBitSetters::set_has_attribute(&has_bits);
          attribute_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 cmd = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 128)) {
          HasBitSetters::set_has_cmd(&has_bits);
          cmd_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 devError = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 136)) {
          HasBitSetters::set_has_deverror(&has_bits);
          deverror_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 version = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 144)) {
          HasBitSetters::set_has_version(&has_bits);
          version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 id = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 152)) {
          HasBitSetters::set_has_id(&has_bits);
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool MantunData::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:MantunData)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 volVal = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_volval(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &volval_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 leakageVal = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_leakageval(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &leakageval_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 powerVal = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_powerval(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &powerval_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 tempVal = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_tempval(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &tempval_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 currVal = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_currval(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &currval_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 status = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          HasBitSetters::set_has_status(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &status_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 kwhVal = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          HasBitSetters::set_has_kwhval(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &kwhval_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 swOnOff = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (64 & 0xFF)) {
          HasBitSetters::set_has_swonoff(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &swonoff_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 volHighTh = 9;
      case 9: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (72 & 0xFF)) {
          HasBitSetters::set_has_volhighth(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &volhighth_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 volLowTh = 10;
      case 10: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (80 & 0xFF)) {
          HasBitSetters::set_has_vollowth(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &vollowth_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 leakageTh = 11;
      case 11: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (88 & 0xFF)) {
          HasBitSetters::set_has_leakageth(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &leakageth_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 tempTh = 12;
      case 12: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (96 & 0xFF)) {
          HasBitSetters::set_has_tempth(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &tempth_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 currentTh = 13;
      case 13: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (104 & 0xFF)) {
          HasBitSetters::set_has_currentth(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &currentth_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 powerTh = 14;
      case 14: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (112 & 0xFF)) {
          HasBitSetters::set_has_powerth(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &powerth_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 attribute = 15;
      case 15: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (120 & 0xFF)) {
          HasBitSetters::set_has_attribute(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &attribute_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 cmd = 16;
      case 16: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (128 & 0xFF)) {
          HasBitSetters::set_has_cmd(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cmd_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 devError = 17;
      case 17: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (136 & 0xFF)) {
          HasBitSetters::set_has_deverror(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &deverror_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 version = 18;
      case 18: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (144 & 0xFF)) {
          HasBitSetters::set_has_version(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &version_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 id = 19;
      case 19: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (152 & 0xFF)) {
          HasBitSetters::set_has_id(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MantunData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MantunData)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void MantunData::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MantunData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 volVal = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(1, this->volval(), output);
  }

  // optional uint32 leakageVal = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(2, this->leakageval(), output);
  }

  // optional uint32 powerVal = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->powerval(), output);
  }

  // optional uint32 tempVal = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->tempval(), output);
  }

  // optional uint32 currVal = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(5, this->currval(), output);
  }

  // optional uint32 status = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(6, this->status(), output);
  }

  // optional uint32 kwhVal = 7;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(7, this->kwhval(), output);
  }

  // optional uint32 swOnOff = 8;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(8, this->swonoff(), output);
  }

  // optional uint32 volHighTh = 9;
  if (cached_has_bits & 0x00000100u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(9, this->volhighth(), output);
  }

  // optional uint32 volLowTh = 10;
  if (cached_has_bits & 0x00000200u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(10, this->vollowth(), output);
  }

  // optional uint32 leakageTh = 11;
  if (cached_has_bits & 0x00000400u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(11, this->leakageth(), output);
  }

  // optional uint32 tempTh = 12;
  if (cached_has_bits & 0x00000800u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(12, this->tempth(), output);
  }

  // optional uint32 currentTh = 13;
  if (cached_has_bits & 0x00001000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(13, this->currentth(), output);
  }

  // optional uint32 powerTh = 14;
  if (cached_has_bits & 0x00002000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(14, this->powerth(), output);
  }

  // optional uint32 attribute = 15;
  if (cached_has_bits & 0x00004000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(15, this->attribute(), output);
  }

  // optional uint32 cmd = 16;
  if (cached_has_bits & 0x00008000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(16, this->cmd(), output);
  }

  // optional uint32 devError = 17;
  if (cached_has_bits & 0x00010000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(17, this->deverror(), output);
  }

  // optional uint32 version = 18;
  if (cached_has_bits & 0x00020000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(18, this->version(), output);
  }

  // optional uint32 id = 19;
  if (cached_has_bits & 0x00040000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(19, this->id(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:MantunData)
}

::PROTOBUF_NAMESPACE_ID::uint8* MantunData::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:MantunData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 volVal = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->volval(), target);
  }

  // optional uint32 leakageVal = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->leakageval(), target);
  }

  // optional uint32 powerVal = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->powerval(), target);
  }

  // optional uint32 tempVal = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->tempval(), target);
  }

  // optional uint32 currVal = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->currval(), target);
  }

  // optional uint32 status = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(6, this->status(), target);
  }

  // optional uint32 kwhVal = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(7, this->kwhval(), target);
  }

  // optional uint32 swOnOff = 8;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(8, this->swonoff(), target);
  }

  // optional uint32 volHighTh = 9;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(9, this->volhighth(), target);
  }

  // optional uint32 volLowTh = 10;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(10, this->vollowth(), target);
  }

  // optional uint32 leakageTh = 11;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(11, this->leakageth(), target);
  }

  // optional uint32 tempTh = 12;
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(12, this->tempth(), target);
  }

  // optional uint32 currentTh = 13;
  if (cached_has_bits & 0x00001000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(13, this->currentth(), target);
  }

  // optional uint32 powerTh = 14;
  if (cached_has_bits & 0x00002000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(14, this->powerth(), target);
  }

  // optional uint32 attribute = 15;
  if (cached_has_bits & 0x00004000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(15, this->attribute(), target);
  }

  // optional uint32 cmd = 16;
  if (cached_has_bits & 0x00008000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(16, this->cmd(), target);
  }

  // optional uint32 devError = 17;
  if (cached_has_bits & 0x00010000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(17, this->deverror(), target);
  }

  // optional uint32 version = 18;
  if (cached_has_bits & 0x00020000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(18, this->version(), target);
  }

  // optional uint32 id = 19;
  if (cached_has_bits & 0x00040000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(19, this->id(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MantunData)
  return target;
}

size_t MantunData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:MantunData)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint32 volVal = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->volval());
    }

    // optional uint32 leakageVal = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->leakageval());
    }

    // optional uint32 powerVal = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->powerval());
    }

    // optional uint32 tempVal = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->tempval());
    }

    // optional uint32 currVal = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->currval());
    }

    // optional uint32 status = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->status());
    }

    // optional uint32 kwhVal = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->kwhval());
    }

    // optional uint32 swOnOff = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->swonoff());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional uint32 volHighTh = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->volhighth());
    }

    // optional uint32 volLowTh = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->vollowth());
    }

    // optional uint32 leakageTh = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->leakageth());
    }

    // optional uint32 tempTh = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->tempth());
    }

    // optional uint32 currentTh = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->currentth());
    }

    // optional uint32 powerTh = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->powerth());
    }

    // optional uint32 attribute = 15;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->attribute());
    }

    // optional uint32 cmd = 16;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->cmd());
    }

  }
  if (cached_has_bits & 0x00070000u) {
    // optional uint32 devError = 17;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->deverror());
    }

    // optional uint32 version = 18;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->version());
    }

    // optional uint32 id = 19;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->id());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MantunData::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:MantunData)
  GOOGLE_DCHECK_NE(&from, this);
  const MantunData* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<MantunData>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:MantunData)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:MantunData)
    MergeFrom(*source);
  }
}

void MantunData::MergeFrom(const MantunData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:MantunData)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      volval_ = from.volval_;
    }
    if (cached_has_bits & 0x00000002u) {
      leakageval_ = from.leakageval_;
    }
    if (cached_has_bits & 0x00000004u) {
      powerval_ = from.powerval_;
    }
    if (cached_has_bits & 0x00000008u) {
      tempval_ = from.tempval_;
    }
    if (cached_has_bits & 0x00000010u) {
      currval_ = from.currval_;
    }
    if (cached_has_bits & 0x00000020u) {
      status_ = from.status_;
    }
    if (cached_has_bits & 0x00000040u) {
      kwhval_ = from.kwhval_;
    }
    if (cached_has_bits & 0x00000080u) {
      swonoff_ = from.swonoff_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      volhighth_ = from.volhighth_;
    }
    if (cached_has_bits & 0x00000200u) {
      vollowth_ = from.vollowth_;
    }
    if (cached_has_bits & 0x00000400u) {
      leakageth_ = from.leakageth_;
    }
    if (cached_has_bits & 0x00000800u) {
      tempth_ = from.tempth_;
    }
    if (cached_has_bits & 0x00001000u) {
      currentth_ = from.currentth_;
    }
    if (cached_has_bits & 0x00002000u) {
      powerth_ = from.powerth_;
    }
    if (cached_has_bits & 0x00004000u) {
      attribute_ = from.attribute_;
    }
    if (cached_has_bits & 0x00008000u) {
      cmd_ = from.cmd_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00070000u) {
    if (cached_has_bits & 0x00010000u) {
      deverror_ = from.deverror_;
    }
    if (cached_has_bits & 0x00020000u) {
      version_ = from.version_;
    }
    if (cached_has_bits & 0x00040000u) {
      id_ = from.id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void MantunData::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:MantunData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MantunData::CopyFrom(const MantunData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:MantunData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MantunData::IsInitialized() const {
  return true;
}

void MantunData::Swap(MantunData* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MantunData::InternalSwap(MantunData* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(volval_, other->volval_);
  swap(leakageval_, other->leakageval_);
  swap(powerval_, other->powerval_);
  swap(tempval_, other->tempval_);
  swap(currval_, other->currval_);
  swap(status_, other->status_);
  swap(kwhval_, other->kwhval_);
  swap(swonoff_, other->swonoff_);
  swap(volhighth_, other->volhighth_);
  swap(vollowth_, other->vollowth_);
  swap(leakageth_, other->leakageth_);
  swap(tempth_, other->tempth_);
  swap(currentth_, other->currentth_);
  swap(powerth_, other->powerth_);
  swap(attribute_, other->attribute_);
  swap(cmd_, other->cmd_);
  swap(deverror_, other->deverror_);
  swap(version_, other->version_);
  swap(id_, other->id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MantunData::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Cayman::InitAsDefaultInstance() {
}
class Cayman::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<Cayman>()._has_bits_);
  static void set_has_issmoke(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ismoved(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_valueoftem(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_valueofhum(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_valueofsmoke(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_standarofsmoke(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_alarmofhightem(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_alarmoflowtem(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_alarmofhighhum(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_alarmoflowhum(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_cmd(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_valueofphotor(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_devcestate(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_bleadvtype(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_bleadvstarttime(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_bleadvendtime(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_valueofbatb(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_levelofalarm(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_isselfcheck(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Cayman::kIsSmokeFieldNumber;
const int Cayman::kIsMovedFieldNumber;
const int Cayman::kValueOfTemFieldNumber;
const int Cayman::kValueOfHumFieldNumber;
const int Cayman::kValueOfSmokeFieldNumber;
const int Cayman::kStandarOfSmokeFieldNumber;
const int Cayman::kAlarmOfHighTemFieldNumber;
const int Cayman::kAlarmOfLowTemFieldNumber;
const int Cayman::kAlarmOfHighHumFieldNumber;
const int Cayman::kAlarmOfLowHumFieldNumber;
const int Cayman::kCmdFieldNumber;
const int Cayman::kValueOfphotorFieldNumber;
const int Cayman::kDevceStateFieldNumber;
const int Cayman::kBleAdvTypeFieldNumber;
const int Cayman::kBleAdvStartTimeFieldNumber;
const int Cayman::kBleAdvEndTimeFieldNumber;
const int Cayman::kValueOfBatbFieldNumber;
const int Cayman::kLevelOfAlarmFieldNumber;
const int Cayman::kIsSelfCheckFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Cayman::Cayman()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Cayman)
}
Cayman::Cayman(const Cayman& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&issmoke_, &from.issmoke_,
    static_cast<size_t>(reinterpret_cast<char*>(&isselfcheck_) -
    reinterpret_cast<char*>(&issmoke_)) + sizeof(isselfcheck_));
  // @@protoc_insertion_point(copy_constructor:Cayman)
}

void Cayman::SharedCtor() {
  ::memset(&issmoke_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&isselfcheck_) -
      reinterpret_cast<char*>(&issmoke_)) + sizeof(isselfcheck_));
}

Cayman::~Cayman() {
  // @@protoc_insertion_point(destructor:Cayman)
  SharedDtor();
}

void Cayman::SharedDtor() {
}

void Cayman::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Cayman& Cayman::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Cayman_MsgNode_5f1v1_5fm22_2eproto.base);
  return *internal_default_instance();
}


void Cayman::Clear() {
// @@protoc_insertion_point(message_clear_start:Cayman)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&issmoke_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&alarmoflowtem_) -
        reinterpret_cast<char*>(&issmoke_)) + sizeof(alarmoflowtem_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&alarmofhighhum_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&bleadvendtime_) -
        reinterpret_cast<char*>(&alarmofhighhum_)) + sizeof(bleadvendtime_));
  }
  if (cached_has_bits & 0x00070000u) {
    ::memset(&valueofbatb_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&isselfcheck_) -
        reinterpret_cast<char*>(&valueofbatb_)) + sizeof(isselfcheck_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Cayman::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 isSmoke = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          HasBitSetters::set_has_issmoke(&has_bits);
          issmoke_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 isMoved = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          HasBitSetters::set_has_ismoved(&has_bits);
          ismoved_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional sint32 valueOfTem = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          HasBitSetters::set_has_valueoftem(&has_bits);
          valueoftem_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 valueOfHum = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          HasBitSetters::set_has_valueofhum(&has_bits);
          valueofhum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 valueOfSmoke = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          HasBitSetters::set_has_valueofsmoke(&has_bits);
          valueofsmoke_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 standarOfSmoke = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          HasBitSetters::set_has_standarofsmoke(&has_bits);
          standarofsmoke_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional sint32 alarmOfHighTem = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          HasBitSetters::set_has_alarmofhightem(&has_bits);
          alarmofhightem_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional sint32 alarmOfLowTem = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          HasBitSetters::set_has_alarmoflowtem(&has_bits);
          alarmoflowtem_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 alarmOfHighHum = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          HasBitSetters::set_has_alarmofhighhum(&has_bits);
          alarmofhighhum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 alarmOfLowHum = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          HasBitSetters::set_has_alarmoflowhum(&has_bits);
          alarmoflowhum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 cmd = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          HasBitSetters::set_has_cmd(&has_bits);
          cmd_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 valueOfphotor = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          HasBitSetters::set_has_valueofphotor(&has_bits);
          valueofphotor_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 devceState = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          HasBitSetters::set_has_devcestate(&has_bits);
          devcestate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 bleAdvType = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 112)) {
          HasBitSetters::set_has_bleadvtype(&has_bits);
          bleadvtype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 bleAdvStartTime = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 120)) {
          HasBitSetters::set_has_bleadvstarttime(&has_bits);
          bleadvstarttime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 bleAdvEndTime = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 128)) {
          HasBitSetters::set_has_bleadvendtime(&has_bits);
          bleadvendtime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 valueOfBatb = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 136)) {
          HasBitSetters::set_has_valueofbatb(&has_bits);
          valueofbatb_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 levelOfAlarm = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 144)) {
          HasBitSetters::set_has_levelofalarm(&has_bits);
          levelofalarm_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 isSelfCheck = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 152)) {
          HasBitSetters::set_has_isselfcheck(&has_bits);
          isselfcheck_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Cayman::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:Cayman)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 isSmoke = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_issmoke(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &issmoke_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 isMoved = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_ismoved(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ismoved_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional sint32 valueOfTem = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_valueoftem(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_SINT32>(
                 input, &valueoftem_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 valueOfHum = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_valueofhum(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &valueofhum_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 valueOfSmoke = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_valueofsmoke(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &valueofsmoke_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 standarOfSmoke = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          HasBitSetters::set_has_standarofsmoke(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &standarofsmoke_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional sint32 alarmOfHighTem = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          HasBitSetters::set_has_alarmofhightem(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_SINT32>(
                 input, &alarmofhightem_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional sint32 alarmOfLowTem = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (64 & 0xFF)) {
          HasBitSetters::set_has_alarmoflowtem(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_SINT32>(
                 input, &alarmoflowtem_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 alarmOfHighHum = 9;
      case 9: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (72 & 0xFF)) {
          HasBitSetters::set_has_alarmofhighhum(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &alarmofhighhum_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 alarmOfLowHum = 10;
      case 10: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (80 & 0xFF)) {
          HasBitSetters::set_has_alarmoflowhum(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &alarmoflowhum_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 cmd = 11;
      case 11: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (88 & 0xFF)) {
          HasBitSetters::set_has_cmd(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cmd_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 valueOfphotor = 12;
      case 12: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (96 & 0xFF)) {
          HasBitSetters::set_has_valueofphotor(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &valueofphotor_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 devceState = 13;
      case 13: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (104 & 0xFF)) {
          HasBitSetters::set_has_devcestate(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &devcestate_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 bleAdvType = 14;
      case 14: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (112 & 0xFF)) {
          HasBitSetters::set_has_bleadvtype(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &bleadvtype_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 bleAdvStartTime = 15;
      case 15: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (120 & 0xFF)) {
          HasBitSetters::set_has_bleadvstarttime(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &bleadvstarttime_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 bleAdvEndTime = 16;
      case 16: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (128 & 0xFF)) {
          HasBitSetters::set_has_bleadvendtime(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &bleadvendtime_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 valueOfBatb = 17;
      case 17: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (136 & 0xFF)) {
          HasBitSetters::set_has_valueofbatb(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &valueofbatb_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 levelOfAlarm = 18;
      case 18: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (144 & 0xFF)) {
          HasBitSetters::set_has_levelofalarm(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &levelofalarm_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 isSelfCheck = 19;
      case 19: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (152 & 0xFF)) {
          HasBitSetters::set_has_isselfcheck(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &isselfcheck_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Cayman)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Cayman)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Cayman::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Cayman)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 isSmoke = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(1, this->issmoke(), output);
  }

  // optional uint32 isMoved = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(2, this->ismoved(), output);
  }

  // optional sint32 valueOfTem = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32(3, this->valueoftem(), output);
  }

  // optional uint32 valueOfHum = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->valueofhum(), output);
  }

  // optional uint32 valueOfSmoke = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(5, this->valueofsmoke(), output);
  }

  // optional uint32 standarOfSmoke = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(6, this->standarofsmoke(), output);
  }

  // optional sint32 alarmOfHighTem = 7;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32(7, this->alarmofhightem(), output);
  }

  // optional sint32 alarmOfLowTem = 8;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32(8, this->alarmoflowtem(), output);
  }

  // optional uint32 alarmOfHighHum = 9;
  if (cached_has_bits & 0x00000100u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(9, this->alarmofhighhum(), output);
  }

  // optional uint32 alarmOfLowHum = 10;
  if (cached_has_bits & 0x00000200u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(10, this->alarmoflowhum(), output);
  }

  // optional uint32 cmd = 11;
  if (cached_has_bits & 0x00000400u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(11, this->cmd(), output);
  }

  // optional uint32 valueOfphotor = 12;
  if (cached_has_bits & 0x00000800u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(12, this->valueofphotor(), output);
  }

  // optional uint32 devceState = 13;
  if (cached_has_bits & 0x00001000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(13, this->devcestate(), output);
  }

  // optional uint32 bleAdvType = 14;
  if (cached_has_bits & 0x00002000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(14, this->bleadvtype(), output);
  }

  // optional uint32 bleAdvStartTime = 15;
  if (cached_has_bits & 0x00004000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(15, this->bleadvstarttime(), output);
  }

  // optional uint32 bleAdvEndTime = 16;
  if (cached_has_bits & 0x00008000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(16, this->bleadvendtime(), output);
  }

  // optional uint32 valueOfBatb = 17;
  if (cached_has_bits & 0x00010000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(17, this->valueofbatb(), output);
  }

  // optional uint32 levelOfAlarm = 18;
  if (cached_has_bits & 0x00020000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(18, this->levelofalarm(), output);
  }

  // optional uint32 isSelfCheck = 19;
  if (cached_has_bits & 0x00040000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(19, this->isselfcheck(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Cayman)
}

::PROTOBUF_NAMESPACE_ID::uint8* Cayman::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Cayman)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 isSmoke = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->issmoke(), target);
  }

  // optional uint32 isMoved = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->ismoved(), target);
  }

  // optional sint32 valueOfTem = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(3, this->valueoftem(), target);
  }

  // optional uint32 valueOfHum = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->valueofhum(), target);
  }

  // optional uint32 valueOfSmoke = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->valueofsmoke(), target);
  }

  // optional uint32 standarOfSmoke = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(6, this->standarofsmoke(), target);
  }

  // optional sint32 alarmOfHighTem = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(7, this->alarmofhightem(), target);
  }

  // optional sint32 alarmOfLowTem = 8;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(8, this->alarmoflowtem(), target);
  }

  // optional uint32 alarmOfHighHum = 9;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(9, this->alarmofhighhum(), target);
  }

  // optional uint32 alarmOfLowHum = 10;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(10, this->alarmoflowhum(), target);
  }

  // optional uint32 cmd = 11;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(11, this->cmd(), target);
  }

  // optional uint32 valueOfphotor = 12;
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(12, this->valueofphotor(), target);
  }

  // optional uint32 devceState = 13;
  if (cached_has_bits & 0x00001000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(13, this->devcestate(), target);
  }

  // optional uint32 bleAdvType = 14;
  if (cached_has_bits & 0x00002000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(14, this->bleadvtype(), target);
  }

  // optional uint32 bleAdvStartTime = 15;
  if (cached_has_bits & 0x00004000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(15, this->bleadvstarttime(), target);
  }

  // optional uint32 bleAdvEndTime = 16;
  if (cached_has_bits & 0x00008000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(16, this->bleadvendtime(), target);
  }

  // optional uint32 valueOfBatb = 17;
  if (cached_has_bits & 0x00010000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(17, this->valueofbatb(), target);
  }

  // optional uint32 levelOfAlarm = 18;
  if (cached_has_bits & 0x00020000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(18, this->levelofalarm(), target);
  }

  // optional uint32 isSelfCheck = 19;
  if (cached_has_bits & 0x00040000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(19, this->isselfcheck(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Cayman)
  return target;
}

size_t Cayman::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Cayman)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint32 isSmoke = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->issmoke());
    }

    // optional uint32 isMoved = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->ismoved());
    }

    // optional sint32 valueOfTem = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32Size(
          this->valueoftem());
    }

    // optional uint32 valueOfHum = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->valueofhum());
    }

    // optional uint32 valueOfSmoke = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->valueofsmoke());
    }

    // optional uint32 standarOfSmoke = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->standarofsmoke());
    }

    // optional sint32 alarmOfHighTem = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32Size(
          this->alarmofhightem());
    }

    // optional sint32 alarmOfLowTem = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32Size(
          this->alarmoflowtem());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional uint32 alarmOfHighHum = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->alarmofhighhum());
    }

    // optional uint32 alarmOfLowHum = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->alarmoflowhum());
    }

    // optional uint32 cmd = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->cmd());
    }

    // optional uint32 valueOfphotor = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->valueofphotor());
    }

    // optional uint32 devceState = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->devcestate());
    }

    // optional uint32 bleAdvType = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->bleadvtype());
    }

    // optional uint32 bleAdvStartTime = 15;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->bleadvstarttime());
    }

    // optional uint32 bleAdvEndTime = 16;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->bleadvendtime());
    }

  }
  if (cached_has_bits & 0x00070000u) {
    // optional uint32 valueOfBatb = 17;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->valueofbatb());
    }

    // optional uint32 levelOfAlarm = 18;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->levelofalarm());
    }

    // optional uint32 isSelfCheck = 19;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->isselfcheck());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Cayman::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Cayman)
  GOOGLE_DCHECK_NE(&from, this);
  const Cayman* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Cayman>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Cayman)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Cayman)
    MergeFrom(*source);
  }
}

void Cayman::MergeFrom(const Cayman& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Cayman)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      issmoke_ = from.issmoke_;
    }
    if (cached_has_bits & 0x00000002u) {
      ismoved_ = from.ismoved_;
    }
    if (cached_has_bits & 0x00000004u) {
      valueoftem_ = from.valueoftem_;
    }
    if (cached_has_bits & 0x00000008u) {
      valueofhum_ = from.valueofhum_;
    }
    if (cached_has_bits & 0x00000010u) {
      valueofsmoke_ = from.valueofsmoke_;
    }
    if (cached_has_bits & 0x00000020u) {
      standarofsmoke_ = from.standarofsmoke_;
    }
    if (cached_has_bits & 0x00000040u) {
      alarmofhightem_ = from.alarmofhightem_;
    }
    if (cached_has_bits & 0x00000080u) {
      alarmoflowtem_ = from.alarmoflowtem_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      alarmofhighhum_ = from.alarmofhighhum_;
    }
    if (cached_has_bits & 0x00000200u) {
      alarmoflowhum_ = from.alarmoflowhum_;
    }
    if (cached_has_bits & 0x00000400u) {
      cmd_ = from.cmd_;
    }
    if (cached_has_bits & 0x00000800u) {
      valueofphotor_ = from.valueofphotor_;
    }
    if (cached_has_bits & 0x00001000u) {
      devcestate_ = from.devcestate_;
    }
    if (cached_has_bits & 0x00002000u) {
      bleadvtype_ = from.bleadvtype_;
    }
    if (cached_has_bits & 0x00004000u) {
      bleadvstarttime_ = from.bleadvstarttime_;
    }
    if (cached_has_bits & 0x00008000u) {
      bleadvendtime_ = from.bleadvendtime_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00070000u) {
    if (cached_has_bits & 0x00010000u) {
      valueofbatb_ = from.valueofbatb_;
    }
    if (cached_has_bits & 0x00020000u) {
      levelofalarm_ = from.levelofalarm_;
    }
    if (cached_has_bits & 0x00040000u) {
      isselfcheck_ = from.isselfcheck_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Cayman::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Cayman)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Cayman::CopyFrom(const Cayman& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Cayman)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Cayman::IsInitialized() const {
  return true;
}

void Cayman::Swap(Cayman* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Cayman::InternalSwap(Cayman* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(issmoke_, other->issmoke_);
  swap(ismoved_, other->ismoved_);
  swap(valueoftem_, other->valueoftem_);
  swap(valueofhum_, other->valueofhum_);
  swap(valueofsmoke_, other->valueofsmoke_);
  swap(standarofsmoke_, other->standarofsmoke_);
  swap(alarmofhightem_, other->alarmofhightem_);
  swap(alarmoflowtem_, other->alarmoflowtem_);
  swap(alarmofhighhum_, other->alarmofhighhum_);
  swap(alarmoflowhum_, other->alarmoflowhum_);
  swap(cmd_, other->cmd_);
  swap(valueofphotor_, other->valueofphotor_);
  swap(devcestate_, other->devcestate_);
  swap(bleadvtype_, other->bleadvtype_);
  swap(bleadvstarttime_, other->bleadvstarttime_);
  swap(bleadvendtime_, other->bleadvendtime_);
  swap(valueofbatb_, other->valueofbatb_);
  swap(levelofalarm_, other->levelofalarm_);
  swap(isselfcheck_, other->isselfcheck_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Cayman::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void AcrelData::InitAsDefaultInstance() {
}
class AcrelData::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<AcrelData>()._has_bits_);
  static void set_has_channeltype(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_shortcircuit(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_opencircuit(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_chstatus(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_leakageval(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_t1val(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_t2val(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_t3val(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_t4val(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_connectsw(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_chenable(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_leakageth(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_t1th(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_t2th(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_t3th(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_t4th(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_passwd(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_aval(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_bval(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_cval(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_valstatus(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_acurr(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_bcurr(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_ccurr(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_currstatus(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_totalyg(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_totalwg(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static void set_has_totalsz(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static void set_has_totalfactor(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static void set_has_valhighset(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static void set_has_vallowset(HasBits* has_bits) {
    (*has_bits)[0] |= 1073741824u;
  }
  static void set_has_currhighset(HasBits* has_bits) {
    (*has_bits)[0] |= 2147483648u;
  }
  static void set_has_energykwh(HasBits* has_bits) {
    (*has_bits)[1] |= 1u;
  }
  static void set_has_cmd(HasBits* has_bits) {
    (*has_bits)[1] |= 2u;
  }
  static void set_has_deverror(HasBits* has_bits) {
    (*has_bits)[1] |= 4u;
  }
  static void set_has_ct(HasBits* has_bits) {
    (*has_bits)[1] |= 8u;
  }
  static void set_has_outputsw(HasBits* has_bits) {
    (*has_bits)[1] |= 16u;
  }
  static void set_has_selfcheck(HasBits* has_bits) {
    (*has_bits)[1] |= 32u;
  }
  static void set_has_valhightype(HasBits* has_bits) {
    (*has_bits)[1] |= 64u;
  }
  static void set_has_vallowtype(HasBits* has_bits) {
    (*has_bits)[1] |= 128u;
  }
  static void set_has_currhightype(HasBits* has_bits) {
    (*has_bits)[1] |= 256u;
  }
  static void set_has_ict(HasBits* has_bits) {
    (*has_bits)[1] |= 512u;
  }
  static void set_has_un(HasBits* has_bits) {
    (*has_bits)[1] |= 1024u;
  }
  static void set_has_in(HasBits* has_bits) {
    (*has_bits)[1] |= 2048u;
  }
  static void set_has_pt(HasBits* has_bits) {
    (*has_bits)[1] |= 4096u;
  }
  static void set_has_linemode(HasBits* has_bits) {
    (*has_bits)[1] |= 8192u;
  }
  static void set_has_lineorder(HasBits* has_bits) {
    (*has_bits)[1] |= 16384u;
  }
  static void set_has_volfreq(HasBits* has_bits) {
    (*has_bits)[1] |= 32768u;
  }
  static void set_has_leakagedelay(HasBits* has_bits) {
    (*has_bits)[1] |= 65536u;
  }
  static void set_has_t1delay(HasBits* has_bits) {
    (*has_bits)[1] |= 131072u;
  }
  static void set_has_t2delay(HasBits* has_bits) {
    (*has_bits)[1] |= 262144u;
  }
  static void set_has_t3delay(HasBits* has_bits) {
    (*has_bits)[1] |= 524288u;
  }
  static void set_has_t4delay(HasBits* has_bits) {
    (*has_bits)[1] |= 1048576u;
  }
  static void set_has_volhdelay(HasBits* has_bits) {
    (*has_bits)[1] |= 2097152u;
  }
  static void set_has_volldelay(HasBits* has_bits) {
    (*has_bits)[1] |= 4194304u;
  }
  static void set_has_currdelay(HasBits* has_bits) {
    (*has_bits)[1] |= 8388608u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int AcrelData::kChannelTypeFieldNumber;
const int AcrelData::kShortCircuitFieldNumber;
const int AcrelData::kOpenCircuitFieldNumber;
const int AcrelData::kChStatusFieldNumber;
const int AcrelData::kLeakageValFieldNumber;
const int AcrelData::kT1ValFieldNumber;
const int AcrelData::kT2ValFieldNumber;
const int AcrelData::kT3ValFieldNumber;
const int AcrelData::kT4ValFieldNumber;
const int AcrelData::kConnectSwFieldNumber;
const int AcrelData::kChEnableFieldNumber;
const int AcrelData::kLeakageThFieldNumber;
const int AcrelData::kT1ThFieldNumber;
const int AcrelData::kT2ThFieldNumber;
const int AcrelData::kT3ThFieldNumber;
const int AcrelData::kT4ThFieldNumber;
const int AcrelData::kPasswdFieldNumber;
const int AcrelData::kAValFieldNumber;
const int AcrelData::kBValFieldNumber;
const int AcrelData::kCValFieldNumber;
const int AcrelData::kValStatusFieldNumber;
const int AcrelData::kACurrFieldNumber;
const int AcrelData::kBCurrFieldNumber;
const int AcrelData::kCCurrFieldNumber;
const int AcrelData::kCurrStatusFieldNumber;
const int AcrelData::kTotalYgFieldNumber;
const int AcrelData::kTotalWgFieldNumber;
const int AcrelData::kTotalSzFieldNumber;
const int AcrelData::kTotalFactorFieldNumber;
const int AcrelData::kValHighSetFieldNumber;
const int AcrelData::kValLowSetFieldNumber;
const int AcrelData::kCurrHighSetFieldNumber;
const int AcrelData::kEnergyKwhFieldNumber;
const int AcrelData::kCmdFieldNumber;
const int AcrelData::kDevErrorFieldNumber;
const int AcrelData::kCtFieldNumber;
const int AcrelData::kOutputSwFieldNumber;
const int AcrelData::kSelfCheckFieldNumber;
const int AcrelData::kValHighTypeFieldNumber;
const int AcrelData::kValLowTypeFieldNumber;
const int AcrelData::kCurrHighTypeFieldNumber;
const int AcrelData::kIctFieldNumber;
const int AcrelData::kUnFieldNumber;
const int AcrelData::kInFieldNumber;
const int AcrelData::kPtFieldNumber;
const int AcrelData::kLineModeFieldNumber;
const int AcrelData::kLineOrderFieldNumber;
const int AcrelData::kVolFreqFieldNumber;
const int AcrelData::kLeakageDelayFieldNumber;
const int AcrelData::kT1DelayFieldNumber;
const int AcrelData::kT2DelayFieldNumber;
const int AcrelData::kT3DelayFieldNumber;
const int AcrelData::kT4DelayFieldNumber;
const int AcrelData::kVolHDelayFieldNumber;
const int AcrelData::kVolLDelayFieldNumber;
const int AcrelData::kCurrDelayFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

AcrelData::AcrelData()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:AcrelData)
}
AcrelData::AcrelData(const AcrelData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&channeltype_, &from.channeltype_,
    static_cast<size_t>(reinterpret_cast<char*>(&currdelay_) -
    reinterpret_cast<char*>(&channeltype_)) + sizeof(currdelay_));
  // @@protoc_insertion_point(copy_constructor:AcrelData)
}

void AcrelData::SharedCtor() {
  ::memset(&channeltype_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&currdelay_) -
      reinterpret_cast<char*>(&channeltype_)) + sizeof(currdelay_));
}

AcrelData::~AcrelData() {
  // @@protoc_insertion_point(destructor:AcrelData)
  SharedDtor();
}

void AcrelData::SharedDtor() {
}

void AcrelData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AcrelData& AcrelData::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AcrelData_MsgNode_5f1v1_5fm22_2eproto.base);
  return *internal_default_instance();
}


void AcrelData::Clear() {
// @@protoc_insertion_point(message_clear_start:AcrelData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&channeltype_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&t3val_) -
        reinterpret_cast<char*>(&channeltype_)) + sizeof(t3val_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&t4val_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&t4th_) -
        reinterpret_cast<char*>(&t4val_)) + sizeof(t4th_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&passwd_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ccurr_) -
        reinterpret_cast<char*>(&passwd_)) + sizeof(ccurr_));
  }
  if (cached_has_bits & 0xff000000u) {
    ::memset(&currstatus_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&currhighset_) -
        reinterpret_cast<char*>(&currstatus_)) + sizeof(currhighset_));
  }
  cached_has_bits = _has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&energykwh_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&vallowtype_) -
        reinterpret_cast<char*>(&energykwh_)) + sizeof(vallowtype_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&currhightype_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&volfreq_) -
        reinterpret_cast<char*>(&currhightype_)) + sizeof(volfreq_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&leakagedelay_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&currdelay_) -
        reinterpret_cast<char*>(&leakagedelay_)) + sizeof(currdelay_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* AcrelData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 channelType = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          HasBitSetters::set_has_channeltype(&_has_bits_);
          channeltype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 shortCircuit = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          HasBitSetters::set_has_shortcircuit(&_has_bits_);
          shortcircuit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 openCircuit = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          HasBitSetters::set_has_opencircuit(&_has_bits_);
          opencircuit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 chStatus = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          HasBitSetters::set_has_chstatus(&_has_bits_);
          chstatus_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional sint32 leakageVal = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          HasBitSetters::set_has_leakageval(&_has_bits_);
          leakageval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional sint32 t1Val = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          HasBitSetters::set_has_t1val(&_has_bits_);
          t1val_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional sint32 t2Val = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          HasBitSetters::set_has_t2val(&_has_bits_);
          t2val_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional sint32 t3Val = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          HasBitSetters::set_has_t3val(&_has_bits_);
          t3val_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional sint32 t4Val = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          HasBitSetters::set_has_t4val(&_has_bits_);
          t4val_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 connectSw = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          HasBitSetters::set_has_connectsw(&_has_bits_);
          connectsw_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 chEnable = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          HasBitSetters::set_has_chenable(&_has_bits_);
          chenable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 leakageTh = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          HasBitSetters::set_has_leakageth(&_has_bits_);
          leakageth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 t1Th = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          HasBitSetters::set_has_t1th(&_has_bits_);
          t1th_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 t2Th = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 112)) {
          HasBitSetters::set_has_t2th(&_has_bits_);
          t2th_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 t3Th = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 120)) {
          HasBitSetters::set_has_t3th(&_has_bits_);
          t3th_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 t4Th = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 128)) {
          HasBitSetters::set_has_t4th(&_has_bits_);
          t4th_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 passwd = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 136)) {
          HasBitSetters::set_has_passwd(&_has_bits_);
          passwd_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 aVal = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 144)) {
          HasBitSetters::set_has_aval(&_has_bits_);
          aval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 bVal = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 152)) {
          HasBitSetters::set_has_bval(&_has_bits_);
          bval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 cVal = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 160)) {
          HasBitSetters::set_has_cval(&_has_bits_);
          cval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 valStatus = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 168)) {
          HasBitSetters::set_has_valstatus(&_has_bits_);
          valstatus_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 aCurr = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 176)) {
          HasBitSetters::set_has_acurr(&_has_bits_);
          acurr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 bCurr = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 184)) {
          HasBitSetters::set_has_bcurr(&_has_bits_);
          bcurr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 cCurr = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 192)) {
          HasBitSetters::set_has_ccurr(&_has_bits_);
          ccurr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 currStatus = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 200)) {
          HasBitSetters::set_has_currstatus(&_has_bits_);
          currstatus_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 totalYg = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 208)) {
          HasBitSetters::set_has_totalyg(&_has_bits_);
          totalyg_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 totalWg = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 216)) {
          HasBitSetters::set_has_totalwg(&_has_bits_);
          totalwg_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 totalSz = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 224)) {
          HasBitSetters::set_has_totalsz(&_has_bits_);
          totalsz_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 totalFactor = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 232)) {
          HasBitSetters::set_has_totalfactor(&_has_bits_);
          totalfactor_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 valHighSet = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 240)) {
          HasBitSetters::set_has_valhighset(&_has_bits_);
          valhighset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 valLowSet = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 248)) {
          HasBitSetters::set_has_vallowset(&_has_bits_);
          vallowset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 currHighSet = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 0)) {
          HasBitSetters::set_has_currhighset(&_has_bits_);
          currhighset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 energyKwh = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          HasBitSetters::set_has_energykwh(&_has_bits_);
          energykwh_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 cmd = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          HasBitSetters::set_has_cmd(&_has_bits_);
          cmd_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 devError = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          HasBitSetters::set_has_deverror(&_has_bits_);
          deverror_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 ct = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          HasBitSetters::set_has_ct(&_has_bits_);
          ct_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 outputSw = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          HasBitSetters::set_has_outputsw(&_has_bits_);
          outputsw_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 selfCheck = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          HasBitSetters::set_has_selfcheck(&_has_bits_);
          selfcheck_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 valHighType = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          HasBitSetters::set_has_valhightype(&_has_bits_);
          valhightype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 valLowType = 41;
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          HasBitSetters::set_has_vallowtype(&_has_bits_);
          vallowtype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 currHighType = 42;
      case 42:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          HasBitSetters::set_has_currhightype(&_has_bits_);
          currhightype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 ict = 43;
      case 43:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          HasBitSetters::set_has_ict(&_has_bits_);
          ict_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 un = 44;
      case 44:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          HasBitSetters::set_has_un(&_has_bits_);
          un_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 in = 45;
      case 45:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          HasBitSetters::set_has_in(&_has_bits_);
          in_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 pt = 46;
      case 46:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 112)) {
          HasBitSetters::set_has_pt(&_has_bits_);
          pt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 lineMode = 47;
      case 47:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 120)) {
          HasBitSetters::set_has_linemode(&_has_bits_);
          linemode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 lineOrder = 48;
      case 48:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 128)) {
          HasBitSetters::set_has_lineorder(&_has_bits_);
          lineorder_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 volFreq = 49;
      case 49:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 136)) {
          HasBitSetters::set_has_volfreq(&_has_bits_);
          volfreq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 leakageDelay = 50;
      case 50:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 144)) {
          HasBitSetters::set_has_leakagedelay(&_has_bits_);
          leakagedelay_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 T1Delay = 51;
      case 51:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 152)) {
          HasBitSetters::set_has_t1delay(&_has_bits_);
          t1delay_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 T2Delay = 52;
      case 52:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 160)) {
          HasBitSetters::set_has_t2delay(&_has_bits_);
          t2delay_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 T3Delay = 53;
      case 53:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 168)) {
          HasBitSetters::set_has_t3delay(&_has_bits_);
          t3delay_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 T4Delay = 54;
      case 54:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 176)) {
          HasBitSetters::set_has_t4delay(&_has_bits_);
          t4delay_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 volHDelay = 55;
      case 55:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 184)) {
          HasBitSetters::set_has_volhdelay(&_has_bits_);
          volhdelay_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 volLDelay = 56;
      case 56:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 192)) {
          HasBitSetters::set_has_volldelay(&_has_bits_);
          volldelay_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 currDelay = 57;
      case 57:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 200)) {
          HasBitSetters::set_has_currdelay(&_has_bits_);
          currdelay_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool AcrelData::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:AcrelData)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 channelType = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_channeltype(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &channeltype_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 shortCircuit = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_shortcircuit(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &shortcircuit_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 openCircuit = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_opencircuit(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &opencircuit_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 chStatus = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_chstatus(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &chstatus_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional sint32 leakageVal = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_leakageval(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_SINT32>(
                 input, &leakageval_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional sint32 t1Val = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          HasBitSetters::set_has_t1val(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_SINT32>(
                 input, &t1val_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional sint32 t2Val = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          HasBitSetters::set_has_t2val(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_SINT32>(
                 input, &t2val_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional sint32 t3Val = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (64 & 0xFF)) {
          HasBitSetters::set_has_t3val(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_SINT32>(
                 input, &t3val_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional sint32 t4Val = 9;
      case 9: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (72 & 0xFF)) {
          HasBitSetters::set_has_t4val(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_SINT32>(
                 input, &t4val_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 connectSw = 10;
      case 10: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (80 & 0xFF)) {
          HasBitSetters::set_has_connectsw(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &connectsw_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 chEnable = 11;
      case 11: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (88 & 0xFF)) {
          HasBitSetters::set_has_chenable(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &chenable_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 leakageTh = 12;
      case 12: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (96 & 0xFF)) {
          HasBitSetters::set_has_leakageth(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &leakageth_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 t1Th = 13;
      case 13: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (104 & 0xFF)) {
          HasBitSetters::set_has_t1th(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &t1th_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 t2Th = 14;
      case 14: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (112 & 0xFF)) {
          HasBitSetters::set_has_t2th(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &t2th_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 t3Th = 15;
      case 15: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (120 & 0xFF)) {
          HasBitSetters::set_has_t3th(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &t3th_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 t4Th = 16;
      case 16: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (128 & 0xFF)) {
          HasBitSetters::set_has_t4th(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &t4th_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 passwd = 17;
      case 17: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (136 & 0xFF)) {
          HasBitSetters::set_has_passwd(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &passwd_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 aVal = 18;
      case 18: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (144 & 0xFF)) {
          HasBitSetters::set_has_aval(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &aval_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 bVal = 19;
      case 19: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (152 & 0xFF)) {
          HasBitSetters::set_has_bval(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &bval_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 cVal = 20;
      case 20: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (160 & 0xFF)) {
          HasBitSetters::set_has_cval(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cval_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 valStatus = 21;
      case 21: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (168 & 0xFF)) {
          HasBitSetters::set_has_valstatus(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &valstatus_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 aCurr = 22;
      case 22: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (176 & 0xFF)) {
          HasBitSetters::set_has_acurr(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &acurr_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 bCurr = 23;
      case 23: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (184 & 0xFF)) {
          HasBitSetters::set_has_bcurr(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &bcurr_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 cCurr = 24;
      case 24: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (192 & 0xFF)) {
          HasBitSetters::set_has_ccurr(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ccurr_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 currStatus = 25;
      case 25: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (200 & 0xFF)) {
          HasBitSetters::set_has_currstatus(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &currstatus_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 totalYg = 26;
      case 26: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (208 & 0xFF)) {
          HasBitSetters::set_has_totalyg(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &totalyg_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 totalWg = 27;
      case 27: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (216 & 0xFF)) {
          HasBitSetters::set_has_totalwg(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &totalwg_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 totalSz = 28;
      case 28: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (224 & 0xFF)) {
          HasBitSetters::set_has_totalsz(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &totalsz_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 totalFactor = 29;
      case 29: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (232 & 0xFF)) {
          HasBitSetters::set_has_totalfactor(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &totalfactor_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 valHighSet = 30;
      case 30: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (240 & 0xFF)) {
          HasBitSetters::set_has_valhighset(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &valhighset_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 valLowSet = 31;
      case 31: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (248 & 0xFF)) {
          HasBitSetters::set_has_vallowset(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &vallowset_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 currHighSet = 32;
      case 32: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (256 & 0xFF)) {
          HasBitSetters::set_has_currhighset(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &currhighset_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 energyKwh = 33;
      case 33: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (264 & 0xFF)) {
          HasBitSetters::set_has_energykwh(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &energykwh_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 cmd = 35;
      case 35: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (280 & 0xFF)) {
          HasBitSetters::set_has_cmd(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cmd_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 devError = 36;
      case 36: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (288 & 0xFF)) {
          HasBitSetters::set_has_deverror(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &deverror_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 ct = 37;
      case 37: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (296 & 0xFF)) {
          HasBitSetters::set_has_ct(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ct_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 outputSw = 38;
      case 38: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (304 & 0xFF)) {
          HasBitSetters::set_has_outputsw(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &outputsw_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 selfCheck = 39;
      case 39: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (312 & 0xFF)) {
          HasBitSetters::set_has_selfcheck(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &selfcheck_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 valHighType = 40;
      case 40: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (320 & 0xFF)) {
          HasBitSetters::set_has_valhightype(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &valhightype_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 valLowType = 41;
      case 41: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (328 & 0xFF)) {
          HasBitSetters::set_has_vallowtype(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &vallowtype_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 currHighType = 42;
      case 42: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (336 & 0xFF)) {
          HasBitSetters::set_has_currhightype(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &currhightype_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 ict = 43;
      case 43: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (344 & 0xFF)) {
          HasBitSetters::set_has_ict(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ict_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 un = 44;
      case 44: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (352 & 0xFF)) {
          HasBitSetters::set_has_un(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &un_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 in = 45;
      case 45: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (360 & 0xFF)) {
          HasBitSetters::set_has_in(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &in_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 pt = 46;
      case 46: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (368 & 0xFF)) {
          HasBitSetters::set_has_pt(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &pt_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 lineMode = 47;
      case 47: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (376 & 0xFF)) {
          HasBitSetters::set_has_linemode(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &linemode_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 lineOrder = 48;
      case 48: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (384 & 0xFF)) {
          HasBitSetters::set_has_lineorder(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &lineorder_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 volFreq = 49;
      case 49: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (392 & 0xFF)) {
          HasBitSetters::set_has_volfreq(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &volfreq_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 leakageDelay = 50;
      case 50: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (400 & 0xFF)) {
          HasBitSetters::set_has_leakagedelay(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &leakagedelay_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 T1Delay = 51;
      case 51: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (408 & 0xFF)) {
          HasBitSetters::set_has_t1delay(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &t1delay_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 T2Delay = 52;
      case 52: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (416 & 0xFF)) {
          HasBitSetters::set_has_t2delay(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &t2delay_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 T3Delay = 53;
      case 53: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (424 & 0xFF)) {
          HasBitSetters::set_has_t3delay(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &t3delay_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 T4Delay = 54;
      case 54: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (432 & 0xFF)) {
          HasBitSetters::set_has_t4delay(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &t4delay_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 volHDelay = 55;
      case 55: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (440 & 0xFF)) {
          HasBitSetters::set_has_volhdelay(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &volhdelay_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 volLDelay = 56;
      case 56: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (448 & 0xFF)) {
          HasBitSetters::set_has_volldelay(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &volldelay_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 currDelay = 57;
      case 57: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (456 & 0xFF)) {
          HasBitSetters::set_has_currdelay(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &currdelay_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:AcrelData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:AcrelData)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void AcrelData::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:AcrelData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 channelType = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(1, this->channeltype(), output);
  }

  // optional uint32 shortCircuit = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(2, this->shortcircuit(), output);
  }

  // optional uint32 openCircuit = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->opencircuit(), output);
  }

  // optional uint32 chStatus = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->chstatus(), output);
  }

  // optional sint32 leakageVal = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32(5, this->leakageval(), output);
  }

  // optional sint32 t1Val = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32(6, this->t1val(), output);
  }

  // optional sint32 t2Val = 7;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32(7, this->t2val(), output);
  }

  // optional sint32 t3Val = 8;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32(8, this->t3val(), output);
  }

  // optional sint32 t4Val = 9;
  if (cached_has_bits & 0x00000100u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32(9, this->t4val(), output);
  }

  // optional uint32 connectSw = 10;
  if (cached_has_bits & 0x00000200u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(10, this->connectsw(), output);
  }

  // optional uint32 chEnable = 11;
  if (cached_has_bits & 0x00000400u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(11, this->chenable(), output);
  }

  // optional uint32 leakageTh = 12;
  if (cached_has_bits & 0x00000800u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(12, this->leakageth(), output);
  }

  // optional uint32 t1Th = 13;
  if (cached_has_bits & 0x00001000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(13, this->t1th(), output);
  }

  // optional uint32 t2Th = 14;
  if (cached_has_bits & 0x00002000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(14, this->t2th(), output);
  }

  // optional uint32 t3Th = 15;
  if (cached_has_bits & 0x00004000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(15, this->t3th(), output);
  }

  // optional uint32 t4Th = 16;
  if (cached_has_bits & 0x00008000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(16, this->t4th(), output);
  }

  // optional uint32 passwd = 17;
  if (cached_has_bits & 0x00010000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(17, this->passwd(), output);
  }

  // optional uint32 aVal = 18;
  if (cached_has_bits & 0x00020000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(18, this->aval(), output);
  }

  // optional uint32 bVal = 19;
  if (cached_has_bits & 0x00040000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(19, this->bval(), output);
  }

  // optional uint32 cVal = 20;
  if (cached_has_bits & 0x00080000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(20, this->cval(), output);
  }

  // optional uint32 valStatus = 21;
  if (cached_has_bits & 0x00100000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(21, this->valstatus(), output);
  }

  // optional uint32 aCurr = 22;
  if (cached_has_bits & 0x00200000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(22, this->acurr(), output);
  }

  // optional uint32 bCurr = 23;
  if (cached_has_bits & 0x00400000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(23, this->bcurr(), output);
  }

  // optional uint32 cCurr = 24;
  if (cached_has_bits & 0x00800000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(24, this->ccurr(), output);
  }

  // optional uint32 currStatus = 25;
  if (cached_has_bits & 0x01000000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(25, this->currstatus(), output);
  }

  // optional uint32 totalYg = 26;
  if (cached_has_bits & 0x02000000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(26, this->totalyg(), output);
  }

  // optional uint32 totalWg = 27;
  if (cached_has_bits & 0x04000000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(27, this->totalwg(), output);
  }

  // optional uint32 totalSz = 28;
  if (cached_has_bits & 0x08000000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(28, this->totalsz(), output);
  }

  // optional uint32 totalFactor = 29;
  if (cached_has_bits & 0x10000000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(29, this->totalfactor(), output);
  }

  // optional uint32 valHighSet = 30;
  if (cached_has_bits & 0x20000000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(30, this->valhighset(), output);
  }

  // optional uint32 valLowSet = 31;
  if (cached_has_bits & 0x40000000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(31, this->vallowset(), output);
  }

  // optional uint32 currHighSet = 32;
  if (cached_has_bits & 0x80000000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(32, this->currhighset(), output);
  }

  cached_has_bits = _has_bits_[1];
  // optional uint32 energyKwh = 33;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(33, this->energykwh(), output);
  }

  // optional uint32 cmd = 35;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(35, this->cmd(), output);
  }

  // optional uint32 devError = 36;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(36, this->deverror(), output);
  }

  // optional uint32 ct = 37;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(37, this->ct(), output);
  }

  // optional uint32 outputSw = 38;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(38, this->outputsw(), output);
  }

  // optional uint32 selfCheck = 39;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(39, this->selfcheck(), output);
  }

  // optional uint32 valHighType = 40;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(40, this->valhightype(), output);
  }

  // optional uint32 valLowType = 41;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(41, this->vallowtype(), output);
  }

  // optional uint32 currHighType = 42;
  if (cached_has_bits & 0x00000100u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(42, this->currhightype(), output);
  }

  // optional uint32 ict = 43;
  if (cached_has_bits & 0x00000200u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(43, this->ict(), output);
  }

  // optional uint32 un = 44;
  if (cached_has_bits & 0x00000400u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(44, this->un(), output);
  }

  // optional uint32 in = 45;
  if (cached_has_bits & 0x00000800u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(45, this->in(), output);
  }

  // optional uint32 pt = 46;
  if (cached_has_bits & 0x00001000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(46, this->pt(), output);
  }

  // optional uint32 lineMode = 47;
  if (cached_has_bits & 0x00002000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(47, this->linemode(), output);
  }

  // optional uint32 lineOrder = 48;
  if (cached_has_bits & 0x00004000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(48, this->lineorder(), output);
  }

  // optional uint32 volFreq = 49;
  if (cached_has_bits & 0x00008000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(49, this->volfreq(), output);
  }

  // optional uint32 leakageDelay = 50;
  if (cached_has_bits & 0x00010000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(50, this->leakagedelay(), output);
  }

  // optional uint32 T1Delay = 51;
  if (cached_has_bits & 0x00020000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(51, this->t1delay(), output);
  }

  // optional uint32 T2Delay = 52;
  if (cached_has_bits & 0x00040000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(52, this->t2delay(), output);
  }

  // optional uint32 T3Delay = 53;
  if (cached_has_bits & 0x00080000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(53, this->t3delay(), output);
  }

  // optional uint32 T4Delay = 54;
  if (cached_has_bits & 0x00100000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(54, this->t4delay(), output);
  }

  // optional uint32 volHDelay = 55;
  if (cached_has_bits & 0x00200000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(55, this->volhdelay(), output);
  }

  // optional uint32 volLDelay = 56;
  if (cached_has_bits & 0x00400000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(56, this->volldelay(), output);
  }

  // optional uint32 currDelay = 57;
  if (cached_has_bits & 0x00800000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(57, this->currdelay(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:AcrelData)
}

::PROTOBUF_NAMESPACE_ID::uint8* AcrelData::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:AcrelData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 channelType = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->channeltype(), target);
  }

  // optional uint32 shortCircuit = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->shortcircuit(), target);
  }

  // optional uint32 openCircuit = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->opencircuit(), target);
  }

  // optional uint32 chStatus = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->chstatus(), target);
  }

  // optional sint32 leakageVal = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(5, this->leakageval(), target);
  }

  // optional sint32 t1Val = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(6, this->t1val(), target);
  }

  // optional sint32 t2Val = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(7, this->t2val(), target);
  }

  // optional sint32 t3Val = 8;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(8, this->t3val(), target);
  }

  // optional sint32 t4Val = 9;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(9, this->t4val(), target);
  }

  // optional uint32 connectSw = 10;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(10, this->connectsw(), target);
  }

  // optional uint32 chEnable = 11;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(11, this->chenable(), target);
  }

  // optional uint32 leakageTh = 12;
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(12, this->leakageth(), target);
  }

  // optional uint32 t1Th = 13;
  if (cached_has_bits & 0x00001000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(13, this->t1th(), target);
  }

  // optional uint32 t2Th = 14;
  if (cached_has_bits & 0x00002000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(14, this->t2th(), target);
  }

  // optional uint32 t3Th = 15;
  if (cached_has_bits & 0x00004000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(15, this->t3th(), target);
  }

  // optional uint32 t4Th = 16;
  if (cached_has_bits & 0x00008000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(16, this->t4th(), target);
  }

  // optional uint32 passwd = 17;
  if (cached_has_bits & 0x00010000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(17, this->passwd(), target);
  }

  // optional uint32 aVal = 18;
  if (cached_has_bits & 0x00020000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(18, this->aval(), target);
  }

  // optional uint32 bVal = 19;
  if (cached_has_bits & 0x00040000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(19, this->bval(), target);
  }

  // optional uint32 cVal = 20;
  if (cached_has_bits & 0x00080000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(20, this->cval(), target);
  }

  // optional uint32 valStatus = 21;
  if (cached_has_bits & 0x00100000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(21, this->valstatus(), target);
  }

  // optional uint32 aCurr = 22;
  if (cached_has_bits & 0x00200000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(22, this->acurr(), target);
  }

  // optional uint32 bCurr = 23;
  if (cached_has_bits & 0x00400000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(23, this->bcurr(), target);
  }

  // optional uint32 cCurr = 24;
  if (cached_has_bits & 0x00800000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(24, this->ccurr(), target);
  }

  // optional uint32 currStatus = 25;
  if (cached_has_bits & 0x01000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(25, this->currstatus(), target);
  }

  // optional uint32 totalYg = 26;
  if (cached_has_bits & 0x02000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(26, this->totalyg(), target);
  }

  // optional uint32 totalWg = 27;
  if (cached_has_bits & 0x04000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(27, this->totalwg(), target);
  }

  // optional uint32 totalSz = 28;
  if (cached_has_bits & 0x08000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(28, this->totalsz(), target);
  }

  // optional uint32 totalFactor = 29;
  if (cached_has_bits & 0x10000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(29, this->totalfactor(), target);
  }

  // optional uint32 valHighSet = 30;
  if (cached_has_bits & 0x20000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(30, this->valhighset(), target);
  }

  // optional uint32 valLowSet = 31;
  if (cached_has_bits & 0x40000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(31, this->vallowset(), target);
  }

  // optional uint32 currHighSet = 32;
  if (cached_has_bits & 0x80000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(32, this->currhighset(), target);
  }

  cached_has_bits = _has_bits_[1];
  // optional uint32 energyKwh = 33;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(33, this->energykwh(), target);
  }

  // optional uint32 cmd = 35;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(35, this->cmd(), target);
  }

  // optional uint32 devError = 36;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(36, this->deverror(), target);
  }

  // optional uint32 ct = 37;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(37, this->ct(), target);
  }

  // optional uint32 outputSw = 38;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(38, this->outputsw(), target);
  }

  // optional uint32 selfCheck = 39;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(39, this->selfcheck(), target);
  }

  // optional uint32 valHighType = 40;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(40, this->valhightype(), target);
  }

  // optional uint32 valLowType = 41;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(41, this->vallowtype(), target);
  }

  // optional uint32 currHighType = 42;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(42, this->currhightype(), target);
  }

  // optional uint32 ict = 43;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(43, this->ict(), target);
  }

  // optional uint32 un = 44;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(44, this->un(), target);
  }

  // optional uint32 in = 45;
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(45, this->in(), target);
  }

  // optional uint32 pt = 46;
  if (cached_has_bits & 0x00001000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(46, this->pt(), target);
  }

  // optional uint32 lineMode = 47;
  if (cached_has_bits & 0x00002000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(47, this->linemode(), target);
  }

  // optional uint32 lineOrder = 48;
  if (cached_has_bits & 0x00004000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(48, this->lineorder(), target);
  }

  // optional uint32 volFreq = 49;
  if (cached_has_bits & 0x00008000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(49, this->volfreq(), target);
  }

  // optional uint32 leakageDelay = 50;
  if (cached_has_bits & 0x00010000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(50, this->leakagedelay(), target);
  }

  // optional uint32 T1Delay = 51;
  if (cached_has_bits & 0x00020000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(51, this->t1delay(), target);
  }

  // optional uint32 T2Delay = 52;
  if (cached_has_bits & 0x00040000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(52, this->t2delay(), target);
  }

  // optional uint32 T3Delay = 53;
  if (cached_has_bits & 0x00080000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(53, this->t3delay(), target);
  }

  // optional uint32 T4Delay = 54;
  if (cached_has_bits & 0x00100000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(54, this->t4delay(), target);
  }

  // optional uint32 volHDelay = 55;
  if (cached_has_bits & 0x00200000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(55, this->volhdelay(), target);
  }

  // optional uint32 volLDelay = 56;
  if (cached_has_bits & 0x00400000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(56, this->volldelay(), target);
  }

  // optional uint32 currDelay = 57;
  if (cached_has_bits & 0x00800000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(57, this->currdelay(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AcrelData)
  return target;
}

size_t AcrelData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AcrelData)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint32 channelType = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->channeltype());
    }

    // optional uint32 shortCircuit = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->shortcircuit());
    }

    // optional uint32 openCircuit = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->opencircuit());
    }

    // optional uint32 chStatus = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->chstatus());
    }

    // optional sint32 leakageVal = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32Size(
          this->leakageval());
    }

    // optional sint32 t1Val = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32Size(
          this->t1val());
    }

    // optional sint32 t2Val = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32Size(
          this->t2val());
    }

    // optional sint32 t3Val = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32Size(
          this->t3val());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional sint32 t4Val = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32Size(
          this->t4val());
    }

    // optional uint32 connectSw = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->connectsw());
    }

    // optional uint32 chEnable = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->chenable());
    }

    // optional uint32 leakageTh = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->leakageth());
    }

    // optional uint32 t1Th = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->t1th());
    }

    // optional uint32 t2Th = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->t2th());
    }

    // optional uint32 t3Th = 15;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->t3th());
    }

    // optional uint32 t4Th = 16;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->t4th());
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional uint32 passwd = 17;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->passwd());
    }

    // optional uint32 aVal = 18;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->aval());
    }

    // optional uint32 bVal = 19;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->bval());
    }

    // optional uint32 cVal = 20;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->cval());
    }

    // optional uint32 valStatus = 21;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->valstatus());
    }

    // optional uint32 aCurr = 22;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->acurr());
    }

    // optional uint32 bCurr = 23;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->bcurr());
    }

    // optional uint32 cCurr = 24;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->ccurr());
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional uint32 currStatus = 25;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->currstatus());
    }

    // optional uint32 totalYg = 26;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->totalyg());
    }

    // optional uint32 totalWg = 27;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->totalwg());
    }

    // optional uint32 totalSz = 28;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->totalsz());
    }

    // optional uint32 totalFactor = 29;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->totalfactor());
    }

    // optional uint32 valHighSet = 30;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->valhighset());
    }

    // optional uint32 valLowSet = 31;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->vallowset());
    }

    // optional uint32 currHighSet = 32;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->currhighset());
    }

  }
  cached_has_bits = _has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint32 energyKwh = 33;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->energykwh());
    }

    // optional uint32 cmd = 35;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->cmd());
    }

    // optional uint32 devError = 36;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->deverror());
    }

    // optional uint32 ct = 37;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->ct());
    }

    // optional uint32 outputSw = 38;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->outputsw());
    }

    // optional uint32 selfCheck = 39;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->selfcheck());
    }

    // optional uint32 valHighType = 40;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->valhightype());
    }

    // optional uint32 valLowType = 41;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->vallowtype());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional uint32 currHighType = 42;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->currhightype());
    }

    // optional uint32 ict = 43;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->ict());
    }

    // optional uint32 un = 44;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->un());
    }

    // optional uint32 in = 45;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->in());
    }

    // optional uint32 pt = 46;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->pt());
    }

    // optional uint32 lineMode = 47;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->linemode());
    }

    // optional uint32 lineOrder = 48;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->lineorder());
    }

    // optional uint32 volFreq = 49;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->volfreq());
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional uint32 leakageDelay = 50;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->leakagedelay());
    }

    // optional uint32 T1Delay = 51;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->t1delay());
    }

    // optional uint32 T2Delay = 52;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->t2delay());
    }

    // optional uint32 T3Delay = 53;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->t3delay());
    }

    // optional uint32 T4Delay = 54;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->t4delay());
    }

    // optional uint32 volHDelay = 55;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->volhdelay());
    }

    // optional uint32 volLDelay = 56;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->volldelay());
    }

    // optional uint32 currDelay = 57;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->currdelay());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AcrelData::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:AcrelData)
  GOOGLE_DCHECK_NE(&from, this);
  const AcrelData* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<AcrelData>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:AcrelData)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:AcrelData)
    MergeFrom(*source);
  }
}

void AcrelData::MergeFrom(const AcrelData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AcrelData)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      channeltype_ = from.channeltype_;
    }
    if (cached_has_bits & 0x00000002u) {
      shortcircuit_ = from.shortcircuit_;
    }
    if (cached_has_bits & 0x00000004u) {
      opencircuit_ = from.opencircuit_;
    }
    if (cached_has_bits & 0x00000008u) {
      chstatus_ = from.chstatus_;
    }
    if (cached_has_bits & 0x00000010u) {
      leakageval_ = from.leakageval_;
    }
    if (cached_has_bits & 0x00000020u) {
      t1val_ = from.t1val_;
    }
    if (cached_has_bits & 0x00000040u) {
      t2val_ = from.t2val_;
    }
    if (cached_has_bits & 0x00000080u) {
      t3val_ = from.t3val_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      t4val_ = from.t4val_;
    }
    if (cached_has_bits & 0x00000200u) {
      connectsw_ = from.connectsw_;
    }
    if (cached_has_bits & 0x00000400u) {
      chenable_ = from.chenable_;
    }
    if (cached_has_bits & 0x00000800u) {
      leakageth_ = from.leakageth_;
    }
    if (cached_has_bits & 0x00001000u) {
      t1th_ = from.t1th_;
    }
    if (cached_has_bits & 0x00002000u) {
      t2th_ = from.t2th_;
    }
    if (cached_has_bits & 0x00004000u) {
      t3th_ = from.t3th_;
    }
    if (cached_has_bits & 0x00008000u) {
      t4th_ = from.t4th_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      passwd_ = from.passwd_;
    }
    if (cached_has_bits & 0x00020000u) {
      aval_ = from.aval_;
    }
    if (cached_has_bits & 0x00040000u) {
      bval_ = from.bval_;
    }
    if (cached_has_bits & 0x00080000u) {
      cval_ = from.cval_;
    }
    if (cached_has_bits & 0x00100000u) {
      valstatus_ = from.valstatus_;
    }
    if (cached_has_bits & 0x00200000u) {
      acurr_ = from.acurr_;
    }
    if (cached_has_bits & 0x00400000u) {
      bcurr_ = from.bcurr_;
    }
    if (cached_has_bits & 0x00800000u) {
      ccurr_ = from.ccurr_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      currstatus_ = from.currstatus_;
    }
    if (cached_has_bits & 0x02000000u) {
      totalyg_ = from.totalyg_;
    }
    if (cached_has_bits & 0x04000000u) {
      totalwg_ = from.totalwg_;
    }
    if (cached_has_bits & 0x08000000u) {
      totalsz_ = from.totalsz_;
    }
    if (cached_has_bits & 0x10000000u) {
      totalfactor_ = from.totalfactor_;
    }
    if (cached_has_bits & 0x20000000u) {
      valhighset_ = from.valhighset_;
    }
    if (cached_has_bits & 0x40000000u) {
      vallowset_ = from.vallowset_;
    }
    if (cached_has_bits & 0x80000000u) {
      currhighset_ = from.currhighset_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  cached_has_bits = from._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      energykwh_ = from.energykwh_;
    }
    if (cached_has_bits & 0x00000002u) {
      cmd_ = from.cmd_;
    }
    if (cached_has_bits & 0x00000004u) {
      deverror_ = from.deverror_;
    }
    if (cached_has_bits & 0x00000008u) {
      ct_ = from.ct_;
    }
    if (cached_has_bits & 0x00000010u) {
      outputsw_ = from.outputsw_;
    }
    if (cached_has_bits & 0x00000020u) {
      selfcheck_ = from.selfcheck_;
    }
    if (cached_has_bits & 0x00000040u) {
      valhightype_ = from.valhightype_;
    }
    if (cached_has_bits & 0x00000080u) {
      vallowtype_ = from.vallowtype_;
    }
    _has_bits_[1] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      currhightype_ = from.currhightype_;
    }
    if (cached_has_bits & 0x00000200u) {
      ict_ = from.ict_;
    }
    if (cached_has_bits & 0x00000400u) {
      un_ = from.un_;
    }
    if (cached_has_bits & 0x00000800u) {
      in_ = from.in_;
    }
    if (cached_has_bits & 0x00001000u) {
      pt_ = from.pt_;
    }
    if (cached_has_bits & 0x00002000u) {
      linemode_ = from.linemode_;
    }
    if (cached_has_bits & 0x00004000u) {
      lineorder_ = from.lineorder_;
    }
    if (cached_has_bits & 0x00008000u) {
      volfreq_ = from.volfreq_;
    }
    _has_bits_[1] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      leakagedelay_ = from.leakagedelay_;
    }
    if (cached_has_bits & 0x00020000u) {
      t1delay_ = from.t1delay_;
    }
    if (cached_has_bits & 0x00040000u) {
      t2delay_ = from.t2delay_;
    }
    if (cached_has_bits & 0x00080000u) {
      t3delay_ = from.t3delay_;
    }
    if (cached_has_bits & 0x00100000u) {
      t4delay_ = from.t4delay_;
    }
    if (cached_has_bits & 0x00200000u) {
      volhdelay_ = from.volhdelay_;
    }
    if (cached_has_bits & 0x00400000u) {
      volldelay_ = from.volldelay_;
    }
    if (cached_has_bits & 0x00800000u) {
      currdelay_ = from.currdelay_;
    }
    _has_bits_[1] |= cached_has_bits;
  }
}

void AcrelData::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:AcrelData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AcrelData::CopyFrom(const AcrelData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AcrelData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AcrelData::IsInitialized() const {
  return true;
}

void AcrelData::Swap(AcrelData* other) {
  if (other == this) return;
  InternalSwap(other);
}
void AcrelData::InternalSwap(AcrelData* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(_has_bits_[1], other->_has_bits_[1]);
  swap(channeltype_, other->channeltype_);
  swap(shortcircuit_, other->shortcircuit_);
  swap(opencircuit_, other->opencircuit_);
  swap(chstatus_, other->chstatus_);
  swap(leakageval_, other->leakageval_);
  swap(t1val_, other->t1val_);
  swap(t2val_, other->t2val_);
  swap(t3val_, other->t3val_);
  swap(t4val_, other->t4val_);
  swap(connectsw_, other->connectsw_);
  swap(chenable_, other->chenable_);
  swap(leakageth_, other->leakageth_);
  swap(t1th_, other->t1th_);
  swap(t2th_, other->t2th_);
  swap(t3th_, other->t3th_);
  swap(t4th_, other->t4th_);
  swap(passwd_, other->passwd_);
  swap(aval_, other->aval_);
  swap(bval_, other->bval_);
  swap(cval_, other->cval_);
  swap(valstatus_, other->valstatus_);
  swap(acurr_, other->acurr_);
  swap(bcurr_, other->bcurr_);
  swap(ccurr_, other->ccurr_);
  swap(currstatus_, other->currstatus_);
  swap(totalyg_, other->totalyg_);
  swap(totalwg_, other->totalwg_);
  swap(totalsz_, other->totalsz_);
  swap(totalfactor_, other->totalfactor_);
  swap(valhighset_, other->valhighset_);
  swap(vallowset_, other->vallowset_);
  swap(currhighset_, other->currhighset_);
  swap(energykwh_, other->energykwh_);
  swap(cmd_, other->cmd_);
  swap(deverror_, other->deverror_);
  swap(ct_, other->ct_);
  swap(outputsw_, other->outputsw_);
  swap(selfcheck_, other->selfcheck_);
  swap(valhightype_, other->valhightype_);
  swap(vallowtype_, other->vallowtype_);
  swap(currhightype_, other->currhightype_);
  swap(ict_, other->ict_);
  swap(un_, other->un_);
  swap(in_, other->in_);
  swap(pt_, other->pt_);
  swap(linemode_, other->linemode_);
  swap(lineorder_, other->lineorder_);
  swap(volfreq_, other->volfreq_);
  swap(leakagedelay_, other->leakagedelay_);
  swap(t1delay_, other->t1delay_);
  swap(t2delay_, other->t2delay_);
  swap(t3delay_, other->t3delay_);
  swap(t4delay_, other->t4delay_);
  swap(volhdelay_, other->volhdelay_);
  swap(volldelay_, other->volldelay_);
  swap(currdelay_, other->currdelay_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AcrelData::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Baymax::InitAsDefaultInstance() {
}
class Baymax::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<Baymax>()._has_bits_);
  static void set_has_gasdevclass(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_gasdensity(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_gasdensityl1(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gasdensityl2(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_gasdensityl3(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_gasdisassembly(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_gaslosepwr(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_gasemvalve(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_gasdevicestatus(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_gasdeviceopstate(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_gasdevicecomsdown(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_gasdevicecmd(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_gasdevicesilentmode(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Baymax::kGasDevClassFieldNumber;
const int Baymax::kGasDensityFieldNumber;
const int Baymax::kGasDensityL1FieldNumber;
const int Baymax::kGasDensityL2FieldNumber;
const int Baymax::kGasDensityL3FieldNumber;
const int Baymax::kGasDisassemblyFieldNumber;
const int Baymax::kGasLosePwrFieldNumber;
const int Baymax::kGasEMValveFieldNumber;
const int Baymax::kGasDeviceStatusFieldNumber;
const int Baymax::kGasDeviceOpStateFieldNumber;
const int Baymax::kGasDeviceComsDownFieldNumber;
const int Baymax::kGasDeviceCMDFieldNumber;
const int Baymax::kGasDeviceSilentModeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Baymax::Baymax()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Baymax)
}
Baymax::Baymax(const Baymax& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&gasdevclass_, &from.gasdevclass_,
    static_cast<size_t>(reinterpret_cast<char*>(&gasdevicesilentmode_) -
    reinterpret_cast<char*>(&gasdevclass_)) + sizeof(gasdevicesilentmode_));
  // @@protoc_insertion_point(copy_constructor:Baymax)
}

void Baymax::SharedCtor() {
  ::memset(&gasdevclass_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&gasdevicesilentmode_) -
      reinterpret_cast<char*>(&gasdevclass_)) + sizeof(gasdevicesilentmode_));
}

Baymax::~Baymax() {
  // @@protoc_insertion_point(destructor:Baymax)
  SharedDtor();
}

void Baymax::SharedDtor() {
}

void Baymax::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Baymax& Baymax::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Baymax_MsgNode_5f1v1_5fm22_2eproto.base);
  return *internal_default_instance();
}


void Baymax::Clear() {
// @@protoc_insertion_point(message_clear_start:Baymax)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&gasdevclass_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&gasemvalve_) -
        reinterpret_cast<char*>(&gasdevclass_)) + sizeof(gasemvalve_));
  }
  if (cached_has_bits & 0x00001f00u) {
    ::memset(&gasdevicestatus_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&gasdevicesilentmode_) -
        reinterpret_cast<char*>(&gasdevicestatus_)) + sizeof(gasdevicesilentmode_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Baymax::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  HasBitSetters::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 gasDevClass = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          HasBitSetters::set_has_gasdevclass(&has_bits);
          gasdevclass_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 gasDensity = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          HasBitSetters::set_has_gasdensity(&has_bits);
          gasdensity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 gasDensityL1 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          HasBitSetters::set_has_gasdensityl1(&has_bits);
          gasdensityl1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 gasDensityL2 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          HasBitSetters::set_has_gasdensityl2(&has_bits);
          gasdensityl2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 gasDensityL3 = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          HasBitSetters::set_has_gasdensityl3(&has_bits);
          gasdensityl3_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 gasDisassembly = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          HasBitSetters::set_has_gasdisassembly(&has_bits);
          gasdisassembly_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 gasLosePwr = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          HasBitSetters::set_has_gaslosepwr(&has_bits);
          gaslosepwr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 gasEMValve = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          HasBitSetters::set_has_gasemvalve(&has_bits);
          gasemvalve_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 gasDeviceStatus = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          HasBitSetters::set_has_gasdevicestatus(&has_bits);
          gasdevicestatus_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 gasDeviceOpState = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          HasBitSetters::set_has_gasdeviceopstate(&has_bits);
          gasdeviceopstate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 gasDeviceComsDown = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          HasBitSetters::set_has_gasdevicecomsdown(&has_bits);
          gasdevicecomsdown_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 gasDeviceCMD = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          HasBitSetters::set_has_gasdevicecmd(&has_bits);
          gasdevicecmd_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 gasDeviceSilentMode = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          HasBitSetters::set_has_gasdevicesilentmode(&has_bits);
          gasdevicesilentmode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Baymax::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:Baymax)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 gasDevClass = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_gasdevclass(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gasdevclass_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 gasDensity = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_gasdensity(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gasdensity_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 gasDensityL1 = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_gasdensityl1(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gasdensityl1_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 gasDensityL2 = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_gasdensityl2(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gasdensityl2_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 gasDensityL3 = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_gasdensityl3(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gasdensityl3_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 gasDisassembly = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          HasBitSetters::set_has_gasdisassembly(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gasdisassembly_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 gasLosePwr = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          HasBitSetters::set_has_gaslosepwr(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gaslosepwr_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 gasEMValve = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (64 & 0xFF)) {
          HasBitSetters::set_has_gasemvalve(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gasemvalve_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 gasDeviceStatus = 9;
      case 9: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (72 & 0xFF)) {
          HasBitSetters::set_has_gasdevicestatus(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gasdevicestatus_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 gasDeviceOpState = 10;
      case 10: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (80 & 0xFF)) {
          HasBitSetters::set_has_gasdeviceopstate(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gasdeviceopstate_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 gasDeviceComsDown = 11;
      case 11: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (88 & 0xFF)) {
          HasBitSetters::set_has_gasdevicecomsdown(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gasdevicecomsdown_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 gasDeviceCMD = 12;
      case 12: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (96 & 0xFF)) {
          HasBitSetters::set_has_gasdevicecmd(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gasdevicecmd_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 gasDeviceSilentMode = 13;
      case 13: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (104 & 0xFF)) {
          HasBitSetters::set_has_gasdevicesilentmode(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gasdevicesilentmode_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Baymax)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Baymax)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Baymax::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Baymax)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 gasDevClass = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(1, this->gasdevclass(), output);
  }

  // optional uint32 gasDensity = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(2, this->gasdensity(), output);
  }

  // optional uint32 gasDensityL1 = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->gasdensityl1(), output);
  }

  // optional uint32 gasDensityL2 = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->gasdensityl2(), output);
  }

  // optional uint32 gasDensityL3 = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(5, this->gasdensityl3(), output);
  }

  // optional uint32 gasDisassembly = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(6, this->gasdisassembly(), output);
  }

  // optional uint32 gasLosePwr = 7;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(7, this->gaslosepwr(), output);
  }

  // optional uint32 gasEMValve = 8;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(8, this->gasemvalve(), output);
  }

  // optional uint32 gasDeviceStatus = 9;
  if (cached_has_bits & 0x00000100u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(9, this->gasdevicestatus(), output);
  }

  // optional uint32 gasDeviceOpState = 10;
  if (cached_has_bits & 0x00000200u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(10, this->gasdeviceopstate(), output);
  }

  // optional uint32 gasDeviceComsDown = 11;
  if (cached_has_bits & 0x00000400u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(11, this->gasdevicecomsdown(), output);
  }

  // optional uint32 gasDeviceCMD = 12;
  if (cached_has_bits & 0x00000800u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(12, this->gasdevicecmd(), output);
  }

  // optional uint32 gasDeviceSilentMode = 13;
  if (cached_has_bits & 0x00001000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(13, this->gasdevicesilentmode(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Baymax)
}

::PROTOBUF_NAMESPACE_ID::uint8* Baymax::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Baymax)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 gasDevClass = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->gasdevclass(), target);
  }

  // optional uint32 gasDensity = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->gasdensity(), target);
  }

  // optional uint32 gasDensityL1 = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->gasdensityl1(), target);
  }

  // optional uint32 gasDensityL2 = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->gasdensityl2(), target);
  }

  // optional uint32 gasDensityL3 = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->gasdensityl3(), target);
  }

  // optional uint32 gasDisassembly = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(6, this->gasdisassembly(), target);
  }

  // optional uint32 gasLosePwr = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(7, this->gaslosepwr(), target);
  }

  // optional uint32 gasEMValve = 8;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(8, this->gasemvalve(), target);
  }

  // optional uint32 gasDeviceStatus = 9;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(9, this->gasdevicestatus(), target);
  }

  // optional uint32 gasDeviceOpState = 10;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(10, this->gasdeviceopstate(), target);
  }

  // optional uint32 gasDeviceComsDown = 11;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(11, this->gasdevicecomsdown(), target);
  }

  // optional uint32 gasDeviceCMD = 12;
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(12, this->gasdevicecmd(), target);
  }

  // optional uint32 gasDeviceSilentMode = 13;
  if (cached_has_bits & 0x00001000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(13, this->gasdevicesilentmode(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Baymax)
  return target;
}

size_t Baymax::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Baymax)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint32 gasDevClass = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->gasdevclass());
    }

    // optional uint32 gasDensity = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->gasdensity());
    }

    // optional uint32 gasDensityL1 = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->gasdensityl1());
    }

    // optional uint32 gasDensityL2 = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->gasdensityl2());
    }

    // optional uint32 gasDensityL3 = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->gasdensityl3());
    }

    // optional uint32 gasDisassembly = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->gasdisassembly());
    }

    // optional uint32 gasLosePwr = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->gaslosepwr());
    }

    // optional uint32 gasEMValve = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->gasemvalve());
    }

  }
  if (cached_has_bits & 0x00001f00u) {
    // optional uint32 gasDeviceStatus = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->gasdevicestatus());
    }

    // optional uint32 gasDeviceOpState = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->gasdeviceopstate());
    }

    // optional uint32 gasDeviceComsDown = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->gasdevicecomsdown());
    }

    // optional uint32 gasDeviceCMD = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->gasdevicecmd());
    }

    // optional uint32 gasDeviceSilentMode = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->gasdevicesilentmode());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Baymax::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Baymax)
  GOOGLE_DCHECK_NE(&from, this);
  const Baymax* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Baymax>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Baymax)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Baymax)
    MergeFrom(*source);
  }
}

void Baymax::MergeFrom(const Baymax& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Baymax)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      gasdevclass_ = from.gasdevclass_;
    }
    if (cached_has_bits & 0x00000002u) {
      gasdensity_ = from.gasdensity_;
    }
    if (cached_has_bits & 0x00000004u) {
      gasdensityl1_ = from.gasdensityl1_;
    }
    if (cached_has_bits & 0x00000008u) {
      gasdensityl2_ = from.gasdensityl2_;
    }
    if (cached_has_bits & 0x00000010u) {
      gasdensityl3_ = from.gasdensityl3_;
    }
    if (cached_has_bits & 0x00000020u) {
      gasdisassembly_ = from.gasdisassembly_;
    }
    if (cached_has_bits & 0x00000040u) {
      gaslosepwr_ = from.gaslosepwr_;
    }
    if (cached_has_bits & 0x00000080u) {
      gasemvalve_ = from.gasemvalve_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00001f00u) {
    if (cached_has_bits & 0x00000100u) {
      gasdevicestatus_ = from.gasdevicestatus_;
    }
    if (cached_has_bits & 0x00000200u) {
      gasdeviceopstate_ = from.gasdeviceopstate_;
    }
    if (cached_has_bits & 0x00000400u) {
      gasdevicecomsdown_ = from.gasdevicecomsdown_;
    }
    if (cached_has_bits & 0x00000800u) {
      gasdevicecmd_ = from.gasdevicecmd_;
    }
    if (cached_has_bits & 0x00001000u) {
      gasdevicesilentmode_ = from.gasdevicesilentmode_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Baymax::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Baymax)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Baymax::CopyFrom(const Baymax& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Baymax)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Baymax::IsInitialized() const {
  return true;
}

void Baymax::Swap(Baymax* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Baymax::InternalSwap(Baymax* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(gasdevclass_, other->gasdevclass_);
  swap(gasdensity_, other->gasdensity_);
  swap(gasdensityl1_, other->gasdensityl1_);
  swap(gasdensityl2_, other->gasdensityl2_);
  swap(gasdensityl3_, other->gasdensityl3_);
  swap(gasdisassembly_, other->gasdisassembly_);
  swap(gaslosepwr_, other->gaslosepwr_);
  swap(gasemvalve_, other->gasemvalve_);
  swap(gasdevicestatus_, other->gasdevicestatus_);
  swap(gasdeviceopstate_, other->gasdeviceopstate_);
  swap(gasdevicecomsdown_, other->gasdevicecomsdown_);
  swap(gasdevicecmd_, other->gasdevicecmd_);
  swap(gasdevicesilentmode_, other->gasdevicesilentmode_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Baymax::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void MsgNode::InitAsDefaultInstance() {
  ::_MsgNode_default_instance_._instance.get_mutable()->lpwanparam_ = const_cast< ::LpwanParam*>(
      ::LpwanParam::internal_default_instance());
  ::_MsgNode_default_instance_._instance.get_mutable()->bleparam_ = const_cast< ::BleParam*>(
      ::BleParam::internal_default_instance());
  ::_MsgNode_default_instance_._instance.get_mutable()->appparam_ = const_cast< ::AppParam*>(
      ::AppParam::internal_default_instance());
  ::_MsgNode_default_instance_._instance.get_mutable()->gps_ = const_cast< ::GpsData*>(
      ::GpsData::internal_default_instance());
  ::_MsgNode_default_instance_._instance.get_mutable()->acceleration_ = const_cast< ::AxisData*>(
      ::AxisData::internal_default_instance());
  ::_MsgNode_default_instance_._instance.get_mutable()->magnetism_ = const_cast< ::AxisData*>(
      ::AxisData::internal_default_instance());
  ::_MsgNode_default_instance_._instance.get_mutable()->gyroscope_ = const_cast< ::AxisData*>(
      ::AxisData::internal_default_instance());
  ::_MsgNode_default_instance_._instance.get_mutable()->temperature_ = const_cast< ::SensorData*>(
      ::SensorData::internal_default_instance());
  ::_MsgNode_default_instance_._instance.get_mutable()->humidity_ = const_cast< ::SensorData*>(
      ::SensorData::internal_default_instance());
  ::_MsgNode_default_instance_._instance.get_mutable()->light_ = const_cast< ::SensorData*>(
      ::SensorData::internal_default_instance());
  ::_MsgNode_default_instance_._instance.get_mutable()->leak_ = const_cast< ::SensorData*>(
      ::SensorData::internal_default_instance());
  ::_MsgNode_default_instance_._instance.get_mutable()->co_ = const_cast< ::SensorData*>(
      ::SensorData::internal_default_instance());
  ::_MsgNode_default_instance_._instance.get_mutable()->co2_ = const_cast< ::SensorData*>(
      ::SensorData::internal_default_instance());
  ::_MsgNode_default_instance_._instance.get_mutable()->so2_ = const_cast< ::SensorData*>(
      ::SensorData::internal_default_instance());
  ::_MsgNode_default_instance_._instance.get_mutable()->no2_ = const_cast< ::SensorData*>(
      ::SensorData::internal_default_instance());
  ::_MsgNode_default_instance_._instance.get_mutable()->ch4_ = const_cast< ::SensorData*>(
      ::SensorData::internal_default_instance());
  ::_MsgNode_default_instance_._instance.get_mutable()->ch2o_ = const_cast< ::SensorData*>(
      ::SensorData::internal_default_instance());
  ::_MsgNode_default_instance_._instance.get_mutable()->lpg_ = const_cast< ::SensorData*>(
      ::SensorData::internal_default_instance());
  ::_MsgNode_default_instance_._instance.get_mutable()->o3_ = const_cast< ::SensorData*>(
      ::SensorData::internal_default_instance());
  ::_MsgNode_default_instance_._instance.get_mutable()->pm1_ = const_cast< ::SensorData*>(
      ::SensorData::internal_default_instance());
  ::_MsgNode_default_instance_._instance.get_mutable()->pm2_5_ = const_cast< ::SensorData*>(
      ::SensorData::internal_default_instance());
  ::_MsgNode_default_instance_._instance.get_mutable()->pm10_ = const_cast< ::SensorData*>(
      ::SensorData::internal_default_instance());
  ::_MsgNode_default_instance_._instance.get_mutable()->angle_ = const_cast< ::SensorData*>(
      ::SensorData::internal_default_instance());
  ::_MsgNode_default_instance_._instance.get_mutable()->cover_ = const_cast< ::SensorData*>(
      ::SensorData::internal_default_instance());
  ::_MsgNode_default_instance_._instance.get_mutable()->level_ = const_cast< ::SensorData*>(
      ::SensorData::internal_default_instance());
  ::_MsgNode_default_instance_._instance.get_mutable()->smoke_ = const_cast< ::SensorData*>(
      ::SensorData::internal_default_instance());
  ::_MsgNode_default_instance_._instance.get_mutable()->pitch_ = const_cast< ::SensorData*>(
      ::SensorData::internal_default_instance());
  ::_MsgNode_default_instance_._instance.get_mutable()->roll_ = const_cast< ::SensorData*>(
      ::SensorData::internal_default_instance());
  ::_MsgNode_default_instance_._instance.get_mutable()->yaw_ = const_cast< ::SensorData*>(
      ::SensorData::internal_default_instance());
  ::_MsgNode_default_instance_._instance.get_mutable()->flame_ = const_cast< ::SensorDataInt*>(
      ::SensorDataInt::internal_default_instance());
  ::_MsgNode_default_instance_._instance.get_mutable()->artificialgas_ = const_cast< ::SensorData*>(
      ::SensorData::internal_default_instance());
  ::_MsgNode_default_instance_._instance.get_mutable()->multitemp_ = const_cast< ::MultiSensorDataInt*>(
      ::MultiSensorDataInt::internal_default_instance());
  ::_MsgNode_default_instance_._instance.get_mutable()->waterpressure_ = const_cast< ::SensorData*>(
      ::SensorData::internal_default_instance());
  ::_MsgNode_default_instance_._instance.get_mutable()->ibeacon_ = const_cast< ::iBeacon*>(
      ::iBeacon::internal_default_instance());
  ::_MsgNode_default_instance_._instance.get_mutable()->extsmoke_ = const_cast< ::ExtSmoke*>(
      ::ExtSmoke::internal_default_instance());
  ::_MsgNode_default_instance_._instance.get_mutable()->firedata_ = const_cast< ::ElecFireData*>(
      ::ElecFireData::internal_default_instance());
  ::_MsgNode_default_instance_._instance.get_mutable()->acreldata_ = const_cast< ::AcrelData*>(
      ::AcrelData::internal_default_instance());
  ::_MsgNode_default_instance_._instance.get_mutable()->caymandata_ = const_cast< ::Cayman*>(
      ::Cayman::internal_default_instance());
  ::_MsgNode_default_instance_._instance.get_mutable()->baymaxdata_ = const_cast< ::Baymax*>(
      ::Baymax::internal_default_instance());
}
class MsgNode::HasBitSetters {
 public:
  using HasBits = decltype(std::declval<MsgNode>()._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[1] |= 128u;
  }
  static void set_has_cmd(HasBits* has_bits) {
    (*has_bits)[1] |= 256u;
  }
  static void set_has_cmdret(HasBits* has_bits) {
    (*has_bits)[1] |= 512u;
  }
  static const ::LpwanParam& lpwanparam(const MsgNode* msg);
  static void set_has_lpwanparam(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::BleParam& bleparam(const MsgNode* msg);
  static void set_has_bleparam(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::AppParam& appparam(const MsgNode* msg);
  static void set_has_appparam(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_battery(HasBits* has_bits) {
    (*has_bits)[1] |= 1024u;
  }
  static const ::GpsData& gps(const MsgNode* msg);
  static void set_has_gps(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::AxisData& acceleration(const MsgNode* msg);
  static void set_has_acceleration(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::AxisData& magnetism(const MsgNode* msg);
  static void set_has_magnetism(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::AxisData& gyroscope(const MsgNode* msg);
  static void set_has_gyroscope(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::SensorData& temperature(const MsgNode* msg);
  static void set_has_temperature(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::SensorData& humidity(const MsgNode* msg);
  static void set_has_humidity(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::SensorData& light(const MsgNode* msg);
  static void set_has_light(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::SensorData& leak(const MsgNode* msg);
  static void set_has_leak(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::SensorData& co(const MsgNode* msg);
  static void set_has_co(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::SensorData& co2(const MsgNode* msg);
  static void set_has_co2(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static const ::SensorData& so2(const MsgNode* msg);
  static void set_has_so2(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static const ::SensorData& no2(const MsgNode* msg);
  static void set_has_no2(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static const ::SensorData& ch4(const MsgNode* msg);
  static void set_has_ch4(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static const ::SensorData& ch2o(const MsgNode* msg);
  static void set_has_ch2o(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static const ::SensorData& lpg(const MsgNode* msg);
  static void set_has_lpg(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static const ::SensorData& o3(const MsgNode* msg);
  static void set_has_o3(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static const ::SensorData& pm1(const MsgNode* msg);
  static void set_has_pm1(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static const ::SensorData& pm2_5(const MsgNode* msg);
  static void set_has_pm2_5(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static const ::SensorData& pm10(const MsgNode* msg);
  static void set_has_pm10(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static const ::SensorData& angle(const MsgNode* msg);
  static void set_has_angle(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static const ::SensorData& cover(const MsgNode* msg);
  static void set_has_cover(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static const ::SensorData& level(const MsgNode* msg);
  static void set_has_level(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static const ::SensorData& smoke(const MsgNode* msg);
  static void set_has_smoke(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static const ::SensorData& pitch(const MsgNode* msg);
  static void set_has_pitch(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static const ::SensorData& roll(const MsgNode* msg);
  static void set_has_roll(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static const ::SensorData& yaw(const MsgNode* msg);
  static void set_has_yaw(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static const ::SensorDataInt& flame(const MsgNode* msg);
  static void set_has_flame(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static const ::SensorData& artificialgas(const MsgNode* msg);
  static void set_has_artificialgas(HasBits* has_bits) {
    (*has_bits)[0] |= 1073741824u;
  }
  static const ::MultiSensorDataInt& multitemp(const MsgNode* msg);
  static void set_has_multitemp(HasBits* has_bits) {
    (*has_bits)[0] |= 2147483648u;
  }
  static const ::SensorData& waterpressure(const MsgNode* msg);
  static void set_has_waterpressure(HasBits* has_bits) {
    (*has_bits)[1] |= 1u;
  }
  static const ::iBeacon& ibeacon(const MsgNode* msg);
  static void set_has_ibeacon(HasBits* has_bits) {
    (*has_bits)[1] |= 2u;
  }
  static void set_has_installed(HasBits* has_bits) {
    (*has_bits)[1] |= 2048u;
  }
  static const ::ExtSmoke& extsmoke(const MsgNode* msg);
  static void set_has_extsmoke(HasBits* has_bits) {
    (*has_bits)[1] |= 4u;
  }
  static const ::ElecFireData& firedata(const MsgNode* msg);
  static void set_has_firedata(HasBits* has_bits) {
    (*has_bits)[1] |= 8u;
  }
  static const ::AcrelData& acreldata(const MsgNode* msg);
  static void set_has_acreldata(HasBits* has_bits) {
    (*has_bits)[1] |= 16u;
  }
  static const ::Cayman& caymandata(const MsgNode* msg);
  static void set_has_caymandata(HasBits* has_bits) {
    (*has_bits)[1] |= 32u;
  }
  static const ::Baymax& baymaxdata(const MsgNode* msg);
  static void set_has_baymaxdata(HasBits* has_bits) {
    (*has_bits)[1] |= 64u;
  }
};

const ::LpwanParam&
MsgNode::HasBitSetters::lpwanparam(const MsgNode* msg) {
  return *msg->lpwanparam_;
}
const ::BleParam&
MsgNode::HasBitSetters::bleparam(const MsgNode* msg) {
  return *msg->bleparam_;
}
const ::AppParam&
MsgNode::HasBitSetters::appparam(const MsgNode* msg) {
  return *msg->appparam_;
}
const ::GpsData&
MsgNode::HasBitSetters::gps(const MsgNode* msg) {
  return *msg->gps_;
}
const ::AxisData&
MsgNode::HasBitSetters::acceleration(const MsgNode* msg) {
  return *msg->acceleration_;
}
const ::AxisData&
MsgNode::HasBitSetters::magnetism(const MsgNode* msg) {
  return *msg->magnetism_;
}
const ::AxisData&
MsgNode::HasBitSetters::gyroscope(const MsgNode* msg) {
  return *msg->gyroscope_;
}
const ::SensorData&
MsgNode::HasBitSetters::temperature(const MsgNode* msg) {
  return *msg->temperature_;
}
const ::SensorData&
MsgNode::HasBitSetters::humidity(const MsgNode* msg) {
  return *msg->humidity_;
}
const ::SensorData&
MsgNode::HasBitSetters::light(const MsgNode* msg) {
  return *msg->light_;
}
const ::SensorData&
MsgNode::HasBitSetters::leak(const MsgNode* msg) {
  return *msg->leak_;
}
const ::SensorData&
MsgNode::HasBitSetters::co(const MsgNode* msg) {
  return *msg->co_;
}
const ::SensorData&
MsgNode::HasBitSetters::co2(const MsgNode* msg) {
  return *msg->co2_;
}
const ::SensorData&
MsgNode::HasBitSetters::so2(const MsgNode* msg) {
  return *msg->so2_;
}
const ::SensorData&
MsgNode::HasBitSetters::no2(const MsgNode* msg) {
  return *msg->no2_;
}
const ::SensorData&
MsgNode::HasBitSetters::ch4(const MsgNode* msg) {
  return *msg->ch4_;
}
const ::SensorData&
MsgNode::HasBitSetters::ch2o(const MsgNode* msg) {
  return *msg->ch2o_;
}
const ::SensorData&
MsgNode::HasBitSetters::lpg(const MsgNode* msg) {
  return *msg->lpg_;
}
const ::SensorData&
MsgNode::HasBitSetters::o3(const MsgNode* msg) {
  return *msg->o3_;
}
const ::SensorData&
MsgNode::HasBitSetters::pm1(const MsgNode* msg) {
  return *msg->pm1_;
}
const ::SensorData&
MsgNode::HasBitSetters::pm2_5(const MsgNode* msg) {
  return *msg->pm2_5_;
}
const ::SensorData&
MsgNode::HasBitSetters::pm10(const MsgNode* msg) {
  return *msg->pm10_;
}
const ::SensorData&
MsgNode::HasBitSetters::angle(const MsgNode* msg) {
  return *msg->angle_;
}
const ::SensorData&
MsgNode::HasBitSetters::cover(const MsgNode* msg) {
  return *msg->cover_;
}
const ::SensorData&
MsgNode::HasBitSetters::level(const MsgNode* msg) {
  return *msg->level_;
}
const ::SensorData&
MsgNode::HasBitSetters::smoke(const MsgNode* msg) {
  return *msg->smoke_;
}
const ::SensorData&
MsgNode::HasBitSetters::pitch(const MsgNode* msg) {
  return *msg->pitch_;
}
const ::SensorData&
MsgNode::HasBitSetters::roll(const MsgNode* msg) {
  return *msg->roll_;
}
const ::SensorData&
MsgNode::HasBitSetters::yaw(const MsgNode* msg) {
  return *msg->yaw_;
}
const ::SensorDataInt&
MsgNode::HasBitSetters::flame(const MsgNode* msg) {
  return *msg->flame_;
}
const ::SensorData&
MsgNode::HasBitSetters::artificialgas(const MsgNode* msg) {
  return *msg->artificialgas_;
}
const ::MultiSensorDataInt&
MsgNode::HasBitSetters::multitemp(const MsgNode* msg) {
  return *msg->multitemp_;
}
const ::SensorData&
MsgNode::HasBitSetters::waterpressure(const MsgNode* msg) {
  return *msg->waterpressure_;
}
const ::iBeacon&
MsgNode::HasBitSetters::ibeacon(const MsgNode* msg) {
  return *msg->ibeacon_;
}
const ::ExtSmoke&
MsgNode::HasBitSetters::extsmoke(const MsgNode* msg) {
  return *msg->extsmoke_;
}
const ::ElecFireData&
MsgNode::HasBitSetters::firedata(const MsgNode* msg) {
  return *msg->firedata_;
}
const ::AcrelData&
MsgNode::HasBitSetters::acreldata(const MsgNode* msg) {
  return *msg->acreldata_;
}
const ::Cayman&
MsgNode::HasBitSetters::caymandata(const MsgNode* msg) {
  return *msg->caymandata_;
}
const ::Baymax&
MsgNode::HasBitSetters::baymaxdata(const MsgNode* msg) {
  return *msg->baymaxdata_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MsgNode::kIdFieldNumber;
const int MsgNode::kCmdFieldNumber;
const int MsgNode::kCmdRetFieldNumber;
const int MsgNode::kLpwanParamFieldNumber;
const int MsgNode::kBleParamFieldNumber;
const int MsgNode::kAppParamFieldNumber;
const int MsgNode::kBatteryFieldNumber;
const int MsgNode::kGpsFieldNumber;
const int MsgNode::kAccelerationFieldNumber;
const int MsgNode::kMagnetismFieldNumber;
const int MsgNode::kGyroscopeFieldNumber;
const int MsgNode::kTemperatureFieldNumber;
const int MsgNode::kHumidityFieldNumber;
const int MsgNode::kLightFieldNumber;
const int MsgNode::kLeakFieldNumber;
const int MsgNode::kCoFieldNumber;
const int MsgNode::kCo2FieldNumber;
const int MsgNode::kSo2FieldNumber;
const int MsgNode::kNo2FieldNumber;
const int MsgNode::kCh4FieldNumber;
const int MsgNode::kCh2OFieldNumber;
const int MsgNode::kLpgFieldNumber;
const int MsgNode::kO3FieldNumber;
const int MsgNode::kPm1FieldNumber;
const int MsgNode::kPm25FieldNumber;
const int MsgNode::kPm10FieldNumber;
const int MsgNode::kAngleFieldNumber;
const int MsgNode::kCoverFieldNumber;
const int MsgNode::kLevelFieldNumber;
const int MsgNode::kSmokeFieldNumber;
const int MsgNode::kPitchFieldNumber;
const int MsgNode::kRollFieldNumber;
const int MsgNode::kYawFieldNumber;
const int MsgNode::kFlameFieldNumber;
const int MsgNode::kArtificialGasFieldNumber;
const int MsgNode::kMultiTempFieldNumber;
const int MsgNode::kWaterPressureFieldNumber;
const int MsgNode::kIbeaconFieldNumber;
const int MsgNode::kSensorsFieldNumber;
const int MsgNode::kInstalledFieldNumber;
const int MsgNode::kExtSmokeFieldNumber;
const int MsgNode::kFireDataFieldNumber;
const int MsgNode::kMtunDataFieldNumber;
const int MsgNode::kAcrelDataFieldNumber;
const int MsgNode::kCaymanDataFieldNumber;
const int MsgNode::kBaymaxDataFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

MsgNode::MsgNode()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MsgNode)
}
MsgNode::MsgNode(const MsgNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      sensors_(from.sensors_),
      mtundata_(from.mtundata_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_lpwanparam()) {
    lpwanparam_ = new ::LpwanParam(*from.lpwanparam_);
  } else {
    lpwanparam_ = nullptr;
  }
  if (from.has_bleparam()) {
    bleparam_ = new ::BleParam(*from.bleparam_);
  } else {
    bleparam_ = nullptr;
  }
  if (from.has_appparam()) {
    appparam_ = new ::AppParam(*from.appparam_);
  } else {
    appparam_ = nullptr;
  }
  if (from.has_gps()) {
    gps_ = new ::GpsData(*from.gps_);
  } else {
    gps_ = nullptr;
  }
  if (from.has_acceleration()) {
    acceleration_ = new ::AxisData(*from.acceleration_);
  } else {
    acceleration_ = nullptr;
  }
  if (from.has_magnetism()) {
    magnetism_ = new ::AxisData(*from.magnetism_);
  } else {
    magnetism_ = nullptr;
  }
  if (from.has_gyroscope()) {
    gyroscope_ = new ::AxisData(*from.gyroscope_);
  } else {
    gyroscope_ = nullptr;
  }
  if (from.has_temperature()) {
    temperature_ = new ::SensorData(*from.temperature_);
  } else {
    temperature_ = nullptr;
  }
  if (from.has_humidity()) {
    humidity_ = new ::SensorData(*from.humidity_);
  } else {
    humidity_ = nullptr;
  }
  if (from.has_light()) {
    light_ = new ::SensorData(*from.light_);
  } else {
    light_ = nullptr;
  }
  if (from.has_leak()) {
    leak_ = new ::SensorData(*from.leak_);
  } else {
    leak_ = nullptr;
  }
  if (from.has_co()) {
    co_ = new ::SensorData(*from.co_);
  } else {
    co_ = nullptr;
  }
  if (from.has_co2()) {
    co2_ = new ::SensorData(*from.co2_);
  } else {
    co2_ = nullptr;
  }
  if (from.has_so2()) {
    so2_ = new ::SensorData(*from.so2_);
  } else {
    so2_ = nullptr;
  }
  if (from.has_no2()) {
    no2_ = new ::SensorData(*from.no2_);
  } else {
    no2_ = nullptr;
  }
  if (from.has_ch4()) {
    ch4_ = new ::SensorData(*from.ch4_);
  } else {
    ch4_ = nullptr;
  }
  if (from.has_ch2o()) {
    ch2o_ = new ::SensorData(*from.ch2o_);
  } else {
    ch2o_ = nullptr;
  }
  if (from.has_lpg()) {
    lpg_ = new ::SensorData(*from.lpg_);
  } else {
    lpg_ = nullptr;
  }
  if (from.has_o3()) {
    o3_ = new ::SensorData(*from.o3_);
  } else {
    o3_ = nullptr;
  }
  if (from.has_pm1()) {
    pm1_ = new ::SensorData(*from.pm1_);
  } else {
    pm1_ = nullptr;
  }
  if (from.has_pm2_5()) {
    pm2_5_ = new ::SensorData(*from.pm2_5_);
  } else {
    pm2_5_ = nullptr;
  }
  if (from.has_pm10()) {
    pm10_ = new ::SensorData(*from.pm10_);
  } else {
    pm10_ = nullptr;
  }
  if (from.has_angle()) {
    angle_ = new ::SensorData(*from.angle_);
  } else {
    angle_ = nullptr;
  }
  if (from.has_cover()) {
    cover_ = new ::SensorData(*from.cover_);
  } else {
    cover_ = nullptr;
  }
  if (from.has_level()) {
    level_ = new ::SensorData(*from.level_);
  } else {
    level_ = nullptr;
  }
  if (from.has_smoke()) {
    smoke_ = new ::SensorData(*from.smoke_);
  } else {
    smoke_ = nullptr;
  }
  if (from.has_pitch()) {
    pitch_ = new ::SensorData(*from.pitch_);
  } else {
    pitch_ = nullptr;
  }
  if (from.has_roll()) {
    roll_ = new ::SensorData(*from.roll_);
  } else {
    roll_ = nullptr;
  }
  if (from.has_yaw()) {
    yaw_ = new ::SensorData(*from.yaw_);
  } else {
    yaw_ = nullptr;
  }
  if (from.has_flame()) {
    flame_ = new ::SensorDataInt(*from.flame_);
  } else {
    flame_ = nullptr;
  }
  if (from.has_artificialgas()) {
    artificialgas_ = new ::SensorData(*from.artificialgas_);
  } else {
    artificialgas_ = nullptr;
  }
  if (from.has_multitemp()) {
    multitemp_ = new ::MultiSensorDataInt(*from.multitemp_);
  } else {
    multitemp_ = nullptr;
  }
  if (from.has_waterpressure()) {
    waterpressure_ = new ::SensorData(*from.waterpressure_);
  } else {
    waterpressure_ = nullptr;
  }
  if (from.has_ibeacon()) {
    ibeacon_ = new ::iBeacon(*from.ibeacon_);
  } else {
    ibeacon_ = nullptr;
  }
  if (from.has_extsmoke()) {
    extsmoke_ = new ::ExtSmoke(*from.extsmoke_);
  } else {
    extsmoke_ = nullptr;
  }
  if (from.has_firedata()) {
    firedata_ = new ::ElecFireData(*from.firedata_);
  } else {
    firedata_ = nullptr;
  }
  if (from.has_acreldata()) {
    acreldata_ = new ::AcrelData(*from.acreldata_);
  } else {
    acreldata_ = nullptr;
  }
  if (from.has_caymandata()) {
    caymandata_ = new ::Cayman(*from.caymandata_);
  } else {
    caymandata_ = nullptr;
  }
  if (from.has_baymaxdata()) {
    baymaxdata_ = new ::Baymax(*from.baymaxdata_);
  } else {
    baymaxdata_ = nullptr;
  }
  ::memcpy(&id_, &from.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&installed_) -
    reinterpret_cast<char*>(&id_)) + sizeof(installed_));
  // @@protoc_insertion_point(copy_constructor:MsgNode)
}

void MsgNode::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_MsgNode_MsgNode_5f1v1_5fm22_2eproto.base);
  ::memset(&lpwanparam_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&installed_) -
      reinterpret_cast<char*>(&lpwanparam_)) + sizeof(installed_));
}

MsgNode::~MsgNode() {
  // @@protoc_insertion_point(destructor:MsgNode)
  SharedDtor();
}

void MsgNode::SharedDtor() {
  if (this != internal_default_instance()) delete lpwanparam_;
  if (this != internal_default_instance()) delete bleparam_;
  if (this != internal_default_instance()) delete appparam_;
  if (this != internal_default_instance()) delete gps_;
  if (this != internal_default_instance()) delete acceleration_;
  if (this != internal_default_instance()) delete magnetism_;
  if (this != internal_default_instance()) delete gyroscope_;
  if (this != internal_default_instance()) delete temperature_;
  if (this != internal_default_instance()) delete humidity_;
  if (this != internal_default_instance()) delete light_;
  if (this != internal_default_instance()) delete leak_;
  if (this != internal_default_instance()) delete co_;
  if (this != internal_default_instance()) delete co2_;
  if (this != internal_default_instance()) delete so2_;
  if (this != internal_default_instance()) delete no2_;
  if (this != internal_default_instance()) delete ch4_;
  if (this != internal_default_instance()) delete ch2o_;
  if (this != internal_default_instance()) delete lpg_;
  if (this != internal_default_instance()) delete o3_;
  if (this != internal_default_instance()) delete pm1_;
  if (this != internal_default_instance()) delete pm2_5_;
  if (this != internal_default_instance()) delete pm10_;
  if (this != internal_default_instance()) delete angle_;
  if (this != internal_default_instance()) delete cover_;
  if (this != internal_default_instance()) delete level_;
  if (this != internal_default_instance()) delete smoke_;
  if (this != internal_default_instance()) delete pitch_;
  if (this != internal_default_instance()) delete roll_;
  if (this != internal_default_instance()) delete yaw_;
  if (this != internal_default_instance()) delete flame_;
  if (this != internal_default_instance()) delete artificialgas_;
  if (this != internal_default_instance()) delete multitemp_;
  if (this != internal_default_instance()) delete waterpressure_;
  if (this != internal_default_instance()) delete ibeacon_;
  if (this != internal_default_instance()) delete extsmoke_;
  if (this != internal_default_instance()) delete firedata_;
  if (this != internal_default_instance()) delete acreldata_;
  if (this != internal_default_instance()) delete caymandata_;
  if (this != internal_default_instance()) delete baymaxdata_;
}

void MsgNode::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const MsgNode& MsgNode::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_MsgNode_MsgNode_5f1v1_5fm22_2eproto.base);
  return *internal_default_instance();
}


void MsgNode::Clear() {
// @@protoc_insertion_point(message_clear_start:MsgNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  sensors_.Clear();
  mtundata_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(lpwanparam_ != nullptr);
      lpwanparam_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(bleparam_ != nullptr);
      bleparam_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(appparam_ != nullptr);
      appparam_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(gps_ != nullptr);
      gps_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(acceleration_ != nullptr);
      acceleration_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(magnetism_ != nullptr);
      magnetism_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(gyroscope_ != nullptr);
      gyroscope_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(temperature_ != nullptr);
      temperature_->Clear();
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(humidity_ != nullptr);
      humidity_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(light_ != nullptr);
      light_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(leak_ != nullptr);
      leak_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(co_ != nullptr);
      co_->Clear();
    }
    if (cached_has_bits & 0x00001000u) {
      GOOGLE_DCHECK(co2_ != nullptr);
      co2_->Clear();
    }
    if (cached_has_bits & 0x00002000u) {
      GOOGLE_DCHECK(so2_ != nullptr);
      so2_->Clear();
    }
    if (cached_has_bits & 0x00004000u) {
      GOOGLE_DCHECK(no2_ != nullptr);
      no2_->Clear();
    }
    if (cached_has_bits & 0x00008000u) {
      GOOGLE_DCHECK(ch4_ != nullptr);
      ch4_->Clear();
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      GOOGLE_DCHECK(ch2o_ != nullptr);
      ch2o_->Clear();
    }
    if (cached_has_bits & 0x00020000u) {
      GOOGLE_DCHECK(lpg_ != nullptr);
      lpg_->Clear();
    }
    if (cached_has_bits & 0x00040000u) {
      GOOGLE_DCHECK(o3_ != nullptr);
      o3_->Clear();
    }
    if (cached_has_bits & 0x00080000u) {
      GOOGLE_DCHECK(pm1_ != nullptr);
      pm1_->Clear();
    }
    if (cached_has_bits & 0x00100000u) {
      GOOGLE_DCHECK(pm2_5_ != nullptr);
      pm2_5_->Clear();
    }
    if (cached_has_bits & 0x00200000u) {
      GOOGLE_DCHECK(pm10_ != nullptr);
      pm10_->Clear();
    }
    if (cached_has_bits & 0x00400000u) {
      GOOGLE_DCHECK(angle_ != nullptr);
      angle_->Clear();
    }
    if (cached_has_bits & 0x00800000u) {
      GOOGLE_DCHECK(cover_ != nullptr);
      cover_->Clear();
    }
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      GOOGLE_DCHECK(level_ != nullptr);
      level_->Clear();
    }
    if (cached_has_bits & 0x02000000u) {
      GOOGLE_DCHECK(smoke_ != nullptr);
      smoke_->Clear();
    }
    if (cached_has_bits & 0x04000000u) {
      GOOGLE_DCHECK(pitch_ != nullptr);
      pitch_->Clear();
    }
    if (cached_has_bits & 0x08000000u) {
      GOOGLE_DCHECK(roll_ != nullptr);
      roll_->Clear();
    }
    if (cached_has_bits & 0x10000000u) {
      GOOGLE_DCHECK(yaw_ != nullptr);
      yaw_->Clear();
    }
    if (cached_has_bits & 0x20000000u) {
      GOOGLE_DCHECK(flame_ != nullptr);
      flame_->Clear();
    }
    if (cached_has_bits & 0x40000000u) {
      GOOGLE_DCHECK(artificialgas_ != nullptr);
      artificialgas_->Clear();
    }
    if (cached_has_bits & 0x80000000u) {
      GOOGLE_DCHECK(multitemp_ != nullptr);
      multitemp_->Clear();
    }
  }
  cached_has_bits = _has_bits_[1];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(waterpressure_ != nullptr);
      waterpressure_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(ibeacon_ != nullptr);
      ibeacon_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(extsmoke_ != nullptr);
      extsmoke_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(firedata_ != nullptr);
      firedata_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(acreldata_ != nullptr);
      acreldata_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(caymandata_ != nullptr);
      caymandata_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(baymaxdata_ != nullptr);
      baymaxdata_->Clear();
    }
  }
  id_ = 0u;
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&cmd_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&installed_) -
        reinterpret_cast<char*>(&cmd_)) + sizeof(installed_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* MsgNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          HasBitSetters::set_has_id(&_has_bits_);
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 cmd = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          HasBitSetters::set_has_cmd(&_has_bits_);
          cmd_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 cmdRet = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          HasBitSetters::set_has_cmdret(&_has_bits_);
          cmdret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .LpwanParam lpwanParam = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(mutable_lpwanparam(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .BleParam bleParam = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(mutable_bleparam(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .AppParam appParam = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(mutable_appparam(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional sint32 battery = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          HasBitSetters::set_has_battery(&_has_bits_);
          battery_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .GpsData gps = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr = ctx->ParseMessage(mutable_gps(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .AxisData acceleration = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr = ctx->ParseMessage(mutable_acceleration(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .AxisData magnetism = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr = ctx->ParseMessage(mutable_magnetism(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .AxisData gyroscope = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          ptr = ctx->ParseMessage(mutable_gyroscope(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .SensorData temperature = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 98)) {
          ptr = ctx->ParseMessage(mutable_temperature(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .SensorData humidity = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 106)) {
          ptr = ctx->ParseMessage(mutable_humidity(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .SensorData light = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 114)) {
          ptr = ctx->ParseMessage(mutable_light(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .SensorData leak = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 122)) {
          ptr = ctx->ParseMessage(mutable_leak(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .SensorData co = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 130)) {
          ptr = ctx->ParseMessage(mutable_co(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .SensorData co2 = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 138)) {
          ptr = ctx->ParseMessage(mutable_co2(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .SensorData so2 = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 146)) {
          ptr = ctx->ParseMessage(mutable_so2(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .SensorData no2 = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 154)) {
          ptr = ctx->ParseMessage(mutable_no2(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .SensorData ch4 = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 162)) {
          ptr = ctx->ParseMessage(mutable_ch4(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .SensorData ch2o = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 170)) {
          ptr = ctx->ParseMessage(mutable_ch2o(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .SensorData lpg = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 178)) {
          ptr = ctx->ParseMessage(mutable_lpg(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .SensorData o3 = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 186)) {
          ptr = ctx->ParseMessage(mutable_o3(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .SensorData pm1 = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 194)) {
          ptr = ctx->ParseMessage(mutable_pm1(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .SensorData pm2_5 = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 202)) {
          ptr = ctx->ParseMessage(mutable_pm2_5(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .SensorData pm10 = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 210)) {
          ptr = ctx->ParseMessage(mutable_pm10(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .SensorData angle = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 218)) {
          ptr = ctx->ParseMessage(mutable_angle(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .SensorData cover = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 226)) {
          ptr = ctx->ParseMessage(mutable_cover(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .SensorData level = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 234)) {
          ptr = ctx->ParseMessage(mutable_level(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .SensorData smoke = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 242)) {
          ptr = ctx->ParseMessage(mutable_smoke(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .SensorData pitch = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 250)) {
          ptr = ctx->ParseMessage(mutable_pitch(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .SensorData roll = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 2)) {
          ptr = ctx->ParseMessage(mutable_roll(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .SensorData yaw = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(mutable_yaw(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .SensorDataInt flame = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(mutable_flame(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .SensorData artificialGas = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(mutable_artificialgas(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .MultiSensorDataInt multiTemp = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(mutable_multitemp(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .SensorData waterPressure = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(mutable_waterpressure(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .iBeacon ibeacon = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(mutable_ibeacon(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .SensorData sensors = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(add_sensors(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint16>(ptr) == 698);
        } else goto handle_unusual;
        continue;
      // optional bool installed = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          HasBitSetters::set_has_installed(&_has_bits_);
          installed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .ExtSmoke extSmoke = 41;
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr = ctx->ParseMessage(mutable_extsmoke(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .ElecFireData fireData = 42;
      case 42:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr = ctx->ParseMessage(mutable_firedata(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .MantunData mtunData = 43;
      case 43:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(add_mtundata(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint16>(ptr) == 730);
        } else goto handle_unusual;
        continue;
      // optional .AcrelData acrelData = 44;
      case 44:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 98)) {
          ptr = ctx->ParseMessage(mutable_acreldata(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .Cayman caymanData = 45;
      case 45:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 106)) {
          ptr = ctx->ParseMessage(mutable_caymandata(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .Baymax baymaxData = 46;
      case 46:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 114)) {
          ptr = ctx->ParseMessage(mutable_baymaxdata(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool MsgNode::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:MsgNode)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 id = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_id(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 cmd = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_cmd(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cmd_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 cmdRet = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_cmdret(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cmdret_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .LpwanParam lpwanParam = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_lpwanparam()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .BleParam bleParam = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (42 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_bleparam()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .AppParam appParam = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (50 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_appparam()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional sint32 battery = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {
          HasBitSetters::set_has_battery(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_SINT32>(
                 input, &battery_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .GpsData gps = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (66 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_gps()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .AxisData acceleration = 9;
      case 9: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (74 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_acceleration()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .AxisData magnetism = 10;
      case 10: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (82 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_magnetism()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .AxisData gyroscope = 11;
      case 11: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (90 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_gyroscope()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .SensorData temperature = 12;
      case 12: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (98 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_temperature()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .SensorData humidity = 13;
      case 13: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (106 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_humidity()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .SensorData light = 14;
      case 14: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (114 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_light()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .SensorData leak = 15;
      case 15: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (122 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_leak()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .SensorData co = 16;
      case 16: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (130 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_co()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .SensorData co2 = 17;
      case 17: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (138 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_co2()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .SensorData so2 = 18;
      case 18: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (146 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_so2()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .SensorData no2 = 19;
      case 19: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (154 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_no2()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .SensorData ch4 = 20;
      case 20: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (162 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_ch4()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .SensorData ch2o = 21;
      case 21: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (170 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_ch2o()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .SensorData lpg = 22;
      case 22: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (178 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_lpg()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .SensorData o3 = 23;
      case 23: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (186 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_o3()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .SensorData pm1 = 24;
      case 24: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (194 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_pm1()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .SensorData pm2_5 = 25;
      case 25: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (202 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_pm2_5()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .SensorData pm10 = 26;
      case 26: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (210 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_pm10()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .SensorData angle = 27;
      case 27: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (218 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_angle()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .SensorData cover = 28;
      case 28: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (226 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_cover()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .SensorData level = 29;
      case 29: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (234 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_level()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .SensorData smoke = 30;
      case 30: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (242 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_smoke()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .SensorData pitch = 31;
      case 31: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (250 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_pitch()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .SensorData roll = 32;
      case 32: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (258 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_roll()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .SensorData yaw = 33;
      case 33: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (266 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_yaw()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .SensorDataInt flame = 34;
      case 34: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (274 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_flame()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .SensorData artificialGas = 35;
      case 35: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (282 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_artificialgas()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .MultiSensorDataInt multiTemp = 36;
      case 36: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (290 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_multitemp()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .SensorData waterPressure = 37;
      case 37: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (298 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_waterpressure()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .iBeacon ibeacon = 38;
      case 38: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (306 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_ibeacon()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .SensorData sensors = 39;
      case 39: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (314 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_sensors()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool installed = 40;
      case 40: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (320 & 0xFF)) {
          HasBitSetters::set_has_installed(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &installed_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .ExtSmoke extSmoke = 41;
      case 41: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (330 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_extsmoke()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .ElecFireData fireData = 42;
      case 42: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (338 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_firedata()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .MantunData mtunData = 43;
      case 43: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (346 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_mtundata()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .AcrelData acrelData = 44;
      case 44: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (354 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_acreldata()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Cayman caymanData = 45;
      case 45: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (362 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_caymandata()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .Baymax baymaxData = 46;
      case 46: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (370 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_baymaxdata()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MsgNode)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MsgNode)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void MsgNode::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MsgNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[1];
  // optional uint32 id = 1;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // optional uint32 cmd = 2;
  if (cached_has_bits & 0x00000100u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(2, this->cmd(), output);
  }

  // optional uint32 cmdRet = 3;
  if (cached_has_bits & 0x00000200u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->cmdret(), output);
  }

  cached_has_bits = _has_bits_[0];
  // optional .LpwanParam lpwanParam = 4;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, HasBitSetters::lpwanparam(this), output);
  }

  // optional .BleParam bleParam = 5;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, HasBitSetters::bleparam(this), output);
  }

  // optional .AppParam appParam = 6;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, HasBitSetters::appparam(this), output);
  }

  cached_has_bits = _has_bits_[1];
  // optional sint32 battery = 7;
  if (cached_has_bits & 0x00000400u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32(7, this->battery(), output);
  }

  cached_has_bits = _has_bits_[0];
  // optional .GpsData gps = 8;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, HasBitSetters::gps(this), output);
  }

  // optional .AxisData acceleration = 9;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, HasBitSetters::acceleration(this), output);
  }

  // optional .AxisData magnetism = 10;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, HasBitSetters::magnetism(this), output);
  }

  // optional .AxisData gyroscope = 11;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, HasBitSetters::gyroscope(this), output);
  }

  // optional .SensorData temperature = 12;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      12, HasBitSetters::temperature(this), output);
  }

  // optional .SensorData humidity = 13;
  if (cached_has_bits & 0x00000100u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      13, HasBitSetters::humidity(this), output);
  }

  // optional .SensorData light = 14;
  if (cached_has_bits & 0x00000200u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      14, HasBitSetters::light(this), output);
  }

  // optional .SensorData leak = 15;
  if (cached_has_bits & 0x00000400u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      15, HasBitSetters::leak(this), output);
  }

  // optional .SensorData co = 16;
  if (cached_has_bits & 0x00000800u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      16, HasBitSetters::co(this), output);
  }

  // optional .SensorData co2 = 17;
  if (cached_has_bits & 0x00001000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      17, HasBitSetters::co2(this), output);
  }

  // optional .SensorData so2 = 18;
  if (cached_has_bits & 0x00002000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      18, HasBitSetters::so2(this), output);
  }

  // optional .SensorData no2 = 19;
  if (cached_has_bits & 0x00004000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      19, HasBitSetters::no2(this), output);
  }

  // optional .SensorData ch4 = 20;
  if (cached_has_bits & 0x00008000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      20, HasBitSetters::ch4(this), output);
  }

  // optional .SensorData ch2o = 21;
  if (cached_has_bits & 0x00010000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      21, HasBitSetters::ch2o(this), output);
  }

  // optional .SensorData lpg = 22;
  if (cached_has_bits & 0x00020000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      22, HasBitSetters::lpg(this), output);
  }

  // optional .SensorData o3 = 23;
  if (cached_has_bits & 0x00040000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      23, HasBitSetters::o3(this), output);
  }

  // optional .SensorData pm1 = 24;
  if (cached_has_bits & 0x00080000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      24, HasBitSetters::pm1(this), output);
  }

  // optional .SensorData pm2_5 = 25;
  if (cached_has_bits & 0x00100000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      25, HasBitSetters::pm2_5(this), output);
  }

  // optional .SensorData pm10 = 26;
  if (cached_has_bits & 0x00200000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      26, HasBitSetters::pm10(this), output);
  }

  // optional .SensorData angle = 27;
  if (cached_has_bits & 0x00400000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      27, HasBitSetters::angle(this), output);
  }

  // optional .SensorData cover = 28;
  if (cached_has_bits & 0x00800000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      28, HasBitSetters::cover(this), output);
  }

  // optional .SensorData level = 29;
  if (cached_has_bits & 0x01000000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      29, HasBitSetters::level(this), output);
  }

  // optional .SensorData smoke = 30;
  if (cached_has_bits & 0x02000000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      30, HasBitSetters::smoke(this), output);
  }

  // optional .SensorData pitch = 31;
  if (cached_has_bits & 0x04000000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      31, HasBitSetters::pitch(this), output);
  }

  // optional .SensorData roll = 32;
  if (cached_has_bits & 0x08000000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      32, HasBitSetters::roll(this), output);
  }

  // optional .SensorData yaw = 33;
  if (cached_has_bits & 0x10000000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      33, HasBitSetters::yaw(this), output);
  }

  // optional .SensorDataInt flame = 34;
  if (cached_has_bits & 0x20000000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      34, HasBitSetters::flame(this), output);
  }

  // optional .SensorData artificialGas = 35;
  if (cached_has_bits & 0x40000000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      35, HasBitSetters::artificialgas(this), output);
  }

  // optional .MultiSensorDataInt multiTemp = 36;
  if (cached_has_bits & 0x80000000u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      36, HasBitSetters::multitemp(this), output);
  }

  cached_has_bits = _has_bits_[1];
  // optional .SensorData waterPressure = 37;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      37, HasBitSetters::waterpressure(this), output);
  }

  // optional .iBeacon ibeacon = 38;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      38, HasBitSetters::ibeacon(this), output);
  }

  // repeated .SensorData sensors = 39;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->sensors_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      39,
      this->sensors(static_cast<int>(i)),
      output);
  }

  // optional bool installed = 40;
  if (cached_has_bits & 0x00000800u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(40, this->installed(), output);
  }

  // optional .ExtSmoke extSmoke = 41;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      41, HasBitSetters::extsmoke(this), output);
  }

  // optional .ElecFireData fireData = 42;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      42, HasBitSetters::firedata(this), output);
  }

  // repeated .MantunData mtunData = 43;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->mtundata_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      43,
      this->mtundata(static_cast<int>(i)),
      output);
  }

  // optional .AcrelData acrelData = 44;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      44, HasBitSetters::acreldata(this), output);
  }

  // optional .Cayman caymanData = 45;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      45, HasBitSetters::caymandata(this), output);
  }

  // optional .Baymax baymaxData = 46;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      46, HasBitSetters::baymaxdata(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:MsgNode)
}

::PROTOBUF_NAMESPACE_ID::uint8* MsgNode::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:MsgNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[1];
  // optional uint32 id = 1;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->id(), target);
  }

  // optional uint32 cmd = 2;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->cmd(), target);
  }

  // optional uint32 cmdRet = 3;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->cmdret(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional .LpwanParam lpwanParam = 4;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, HasBitSetters::lpwanparam(this), target);
  }

  // optional .BleParam bleParam = 5;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        5, HasBitSetters::bleparam(this), target);
  }

  // optional .AppParam appParam = 6;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        6, HasBitSetters::appparam(this), target);
  }

  cached_has_bits = _has_bits_[1];
  // optional sint32 battery = 7;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(7, this->battery(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional .GpsData gps = 8;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        8, HasBitSetters::gps(this), target);
  }

  // optional .AxisData acceleration = 9;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        9, HasBitSetters::acceleration(this), target);
  }

  // optional .AxisData magnetism = 10;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        10, HasBitSetters::magnetism(this), target);
  }

  // optional .AxisData gyroscope = 11;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        11, HasBitSetters::gyroscope(this), target);
  }

  // optional .SensorData temperature = 12;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        12, HasBitSetters::temperature(this), target);
  }

  // optional .SensorData humidity = 13;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        13, HasBitSetters::humidity(this), target);
  }

  // optional .SensorData light = 14;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        14, HasBitSetters::light(this), target);
  }

  // optional .SensorData leak = 15;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        15, HasBitSetters::leak(this), target);
  }

  // optional .SensorData co = 16;
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        16, HasBitSetters::co(this), target);
  }

  // optional .SensorData co2 = 17;
  if (cached_has_bits & 0x00001000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        17, HasBitSetters::co2(this), target);
  }

  // optional .SensorData so2 = 18;
  if (cached_has_bits & 0x00002000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        18, HasBitSetters::so2(this), target);
  }

  // optional .SensorData no2 = 19;
  if (cached_has_bits & 0x00004000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        19, HasBitSetters::no2(this), target);
  }

  // optional .SensorData ch4 = 20;
  if (cached_has_bits & 0x00008000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        20, HasBitSetters::ch4(this), target);
  }

  // optional .SensorData ch2o = 21;
  if (cached_has_bits & 0x00010000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        21, HasBitSetters::ch2o(this), target);
  }

  // optional .SensorData lpg = 22;
  if (cached_has_bits & 0x00020000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        22, HasBitSetters::lpg(this), target);
  }

  // optional .SensorData o3 = 23;
  if (cached_has_bits & 0x00040000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        23, HasBitSetters::o3(this), target);
  }

  // optional .SensorData pm1 = 24;
  if (cached_has_bits & 0x00080000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        24, HasBitSetters::pm1(this), target);
  }

  // optional .SensorData pm2_5 = 25;
  if (cached_has_bits & 0x00100000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        25, HasBitSetters::pm2_5(this), target);
  }

  // optional .SensorData pm10 = 26;
  if (cached_has_bits & 0x00200000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        26, HasBitSetters::pm10(this), target);
  }

  // optional .SensorData angle = 27;
  if (cached_has_bits & 0x00400000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        27, HasBitSetters::angle(this), target);
  }

  // optional .SensorData cover = 28;
  if (cached_has_bits & 0x00800000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        28, HasBitSetters::cover(this), target);
  }

  // optional .SensorData level = 29;
  if (cached_has_bits & 0x01000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        29, HasBitSetters::level(this), target);
  }

  // optional .SensorData smoke = 30;
  if (cached_has_bits & 0x02000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        30, HasBitSetters::smoke(this), target);
  }

  // optional .SensorData pitch = 31;
  if (cached_has_bits & 0x04000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        31, HasBitSetters::pitch(this), target);
  }

  // optional .SensorData roll = 32;
  if (cached_has_bits & 0x08000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        32, HasBitSetters::roll(this), target);
  }

  // optional .SensorData yaw = 33;
  if (cached_has_bits & 0x10000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        33, HasBitSetters::yaw(this), target);
  }

  // optional .SensorDataInt flame = 34;
  if (cached_has_bits & 0x20000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        34, HasBitSetters::flame(this), target);
  }

  // optional .SensorData artificialGas = 35;
  if (cached_has_bits & 0x40000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        35, HasBitSetters::artificialgas(this), target);
  }

  // optional .MultiSensorDataInt multiTemp = 36;
  if (cached_has_bits & 0x80000000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        36, HasBitSetters::multitemp(this), target);
  }

  cached_has_bits = _has_bits_[1];
  // optional .SensorData waterPressure = 37;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        37, HasBitSetters::waterpressure(this), target);
  }

  // optional .iBeacon ibeacon = 38;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        38, HasBitSetters::ibeacon(this), target);
  }

  // repeated .SensorData sensors = 39;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->sensors_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        39, this->sensors(static_cast<int>(i)), target);
  }

  // optional bool installed = 40;
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(40, this->installed(), target);
  }

  // optional .ExtSmoke extSmoke = 41;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        41, HasBitSetters::extsmoke(this), target);
  }

  // optional .ElecFireData fireData = 42;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        42, HasBitSetters::firedata(this), target);
  }

  // repeated .MantunData mtunData = 43;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->mtundata_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        43, this->mtundata(static_cast<int>(i)), target);
  }

  // optional .AcrelData acrelData = 44;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        44, HasBitSetters::acreldata(this), target);
  }

  // optional .Cayman caymanData = 45;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        45, HasBitSetters::caymandata(this), target);
  }

  // optional .Baymax baymaxData = 46;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        46, HasBitSetters::baymaxdata(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MsgNode)
  return target;
}

size_t MsgNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:MsgNode)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .SensorData sensors = 39;
  {
    unsigned int count = static_cast<unsigned int>(this->sensors_size());
    total_size += 2UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->sensors(static_cast<int>(i)));
    }
  }

  // repeated .MantunData mtunData = 43;
  {
    unsigned int count = static_cast<unsigned int>(this->mtundata_size());
    total_size += 2UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->mtundata(static_cast<int>(i)));
    }
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .LpwanParam lpwanParam = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *lpwanparam_);
    }

    // optional .BleParam bleParam = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *bleparam_);
    }

    // optional .AppParam appParam = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *appparam_);
    }

    // optional .GpsData gps = 8;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *gps_);
    }

    // optional .AxisData acceleration = 9;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *acceleration_);
    }

    // optional .AxisData magnetism = 10;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *magnetism_);
    }

    // optional .AxisData gyroscope = 11;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *gyroscope_);
    }

    // optional .SensorData temperature = 12;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *temperature_);
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional .SensorData humidity = 13;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *humidity_);
    }

    // optional .SensorData light = 14;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *light_);
    }

    // optional .SensorData leak = 15;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *leak_);
    }

    // optional .SensorData co = 16;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *co_);
    }

    // optional .SensorData co2 = 17;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *co2_);
    }

    // optional .SensorData so2 = 18;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *so2_);
    }

    // optional .SensorData no2 = 19;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *no2_);
    }

    // optional .SensorData ch4 = 20;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *ch4_);
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional .SensorData ch2o = 21;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *ch2o_);
    }

    // optional .SensorData lpg = 22;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *lpg_);
    }

    // optional .SensorData o3 = 23;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *o3_);
    }

    // optional .SensorData pm1 = 24;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *pm1_);
    }

    // optional .SensorData pm2_5 = 25;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *pm2_5_);
    }

    // optional .SensorData pm10 = 26;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *pm10_);
    }

    // optional .SensorData angle = 27;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *angle_);
    }

    // optional .SensorData cover = 28;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *cover_);
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional .SensorData level = 29;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *level_);
    }

    // optional .SensorData smoke = 30;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *smoke_);
    }

    // optional .SensorData pitch = 31;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *pitch_);
    }

    // optional .SensorData roll = 32;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *roll_);
    }

    // optional .SensorData yaw = 33;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *yaw_);
    }

    // optional .SensorDataInt flame = 34;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *flame_);
    }

    // optional .SensorData artificialGas = 35;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *artificialgas_);
    }

    // optional .MultiSensorDataInt multiTemp = 36;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *multitemp_);
    }

  }
  cached_has_bits = _has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    // optional .SensorData waterPressure = 37;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *waterpressure_);
    }

    // optional .iBeacon ibeacon = 38;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *ibeacon_);
    }

    // optional .ExtSmoke extSmoke = 41;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *extsmoke_);
    }

    // optional .ElecFireData fireData = 42;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *firedata_);
    }

    // optional .AcrelData acrelData = 44;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *acreldata_);
    }

    // optional .Cayman caymanData = 45;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *caymandata_);
    }

    // optional .Baymax baymaxData = 46;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *baymaxdata_);
    }

    // optional uint32 id = 1;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->id());
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional uint32 cmd = 2;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->cmd());
    }

    // optional uint32 cmdRet = 3;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->cmdret());
    }

    // optional sint32 battery = 7;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32Size(
          this->battery());
    }

    // optional bool installed = 40;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 + 1;
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MsgNode::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:MsgNode)
  GOOGLE_DCHECK_NE(&from, this);
  const MsgNode* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<MsgNode>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:MsgNode)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:MsgNode)
    MergeFrom(*source);
  }
}

void MsgNode::MergeFrom(const MsgNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:MsgNode)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  sensors_.MergeFrom(from.sensors_);
  mtundata_.MergeFrom(from.mtundata_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_lpwanparam()->::LpwanParam::MergeFrom(from.lpwanparam());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_bleparam()->::BleParam::MergeFrom(from.bleparam());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_appparam()->::AppParam::MergeFrom(from.appparam());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_gps()->::GpsData::MergeFrom(from.gps());
    }
    if (cached_has_bits & 0x00000010u) {
      mutable_acceleration()->::AxisData::MergeFrom(from.acceleration());
    }
    if (cached_has_bits & 0x00000020u) {
      mutable_magnetism()->::AxisData::MergeFrom(from.magnetism());
    }
    if (cached_has_bits & 0x00000040u) {
      mutable_gyroscope()->::AxisData::MergeFrom(from.gyroscope());
    }
    if (cached_has_bits & 0x00000080u) {
      mutable_temperature()->::SensorData::MergeFrom(from.temperature());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      mutable_humidity()->::SensorData::MergeFrom(from.humidity());
    }
    if (cached_has_bits & 0x00000200u) {
      mutable_light()->::SensorData::MergeFrom(from.light());
    }
    if (cached_has_bits & 0x00000400u) {
      mutable_leak()->::SensorData::MergeFrom(from.leak());
    }
    if (cached_has_bits & 0x00000800u) {
      mutable_co()->::SensorData::MergeFrom(from.co());
    }
    if (cached_has_bits & 0x00001000u) {
      mutable_co2()->::SensorData::MergeFrom(from.co2());
    }
    if (cached_has_bits & 0x00002000u) {
      mutable_so2()->::SensorData::MergeFrom(from.so2());
    }
    if (cached_has_bits & 0x00004000u) {
      mutable_no2()->::SensorData::MergeFrom(from.no2());
    }
    if (cached_has_bits & 0x00008000u) {
      mutable_ch4()->::SensorData::MergeFrom(from.ch4());
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      mutable_ch2o()->::SensorData::MergeFrom(from.ch2o());
    }
    if (cached_has_bits & 0x00020000u) {
      mutable_lpg()->::SensorData::MergeFrom(from.lpg());
    }
    if (cached_has_bits & 0x00040000u) {
      mutable_o3()->::SensorData::MergeFrom(from.o3());
    }
    if (cached_has_bits & 0x00080000u) {
      mutable_pm1()->::SensorData::MergeFrom(from.pm1());
    }
    if (cached_has_bits & 0x00100000u) {
      mutable_pm2_5()->::SensorData::MergeFrom(from.pm2_5());
    }
    if (cached_has_bits & 0x00200000u) {
      mutable_pm10()->::SensorData::MergeFrom(from.pm10());
    }
    if (cached_has_bits & 0x00400000u) {
      mutable_angle()->::SensorData::MergeFrom(from.angle());
    }
    if (cached_has_bits & 0x00800000u) {
      mutable_cover()->::SensorData::MergeFrom(from.cover());
    }
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      mutable_level()->::SensorData::MergeFrom(from.level());
    }
    if (cached_has_bits & 0x02000000u) {
      mutable_smoke()->::SensorData::MergeFrom(from.smoke());
    }
    if (cached_has_bits & 0x04000000u) {
      mutable_pitch()->::SensorData::MergeFrom(from.pitch());
    }
    if (cached_has_bits & 0x08000000u) {
      mutable_roll()->::SensorData::MergeFrom(from.roll());
    }
    if (cached_has_bits & 0x10000000u) {
      mutable_yaw()->::SensorData::MergeFrom(from.yaw());
    }
    if (cached_has_bits & 0x20000000u) {
      mutable_flame()->::SensorDataInt::MergeFrom(from.flame());
    }
    if (cached_has_bits & 0x40000000u) {
      mutable_artificialgas()->::SensorData::MergeFrom(from.artificialgas());
    }
    if (cached_has_bits & 0x80000000u) {
      mutable_multitemp()->::MultiSensorDataInt::MergeFrom(from.multitemp());
    }
  }
  cached_has_bits = from._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_waterpressure()->::SensorData::MergeFrom(from.waterpressure());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_ibeacon()->::iBeacon::MergeFrom(from.ibeacon());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_extsmoke()->::ExtSmoke::MergeFrom(from.extsmoke());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_firedata()->::ElecFireData::MergeFrom(from.firedata());
    }
    if (cached_has_bits & 0x00000010u) {
      mutable_acreldata()->::AcrelData::MergeFrom(from.acreldata());
    }
    if (cached_has_bits & 0x00000020u) {
      mutable_caymandata()->::Cayman::MergeFrom(from.caymandata());
    }
    if (cached_has_bits & 0x00000040u) {
      mutable_baymaxdata()->::Baymax::MergeFrom(from.baymaxdata());
    }
    if (cached_has_bits & 0x00000080u) {
      id_ = from.id_;
    }
    _has_bits_[1] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      cmd_ = from.cmd_;
    }
    if (cached_has_bits & 0x00000200u) {
      cmdret_ = from.cmdret_;
    }
    if (cached_has_bits & 0x00000400u) {
      battery_ = from.battery_;
    }
    if (cached_has_bits & 0x00000800u) {
      installed_ = from.installed_;
    }
    _has_bits_[1] |= cached_has_bits;
  }
}

void MsgNode::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:MsgNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MsgNode::CopyFrom(const MsgNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:MsgNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgNode::IsInitialized() const {
  if (has_lpwanparam()) {
    if (!this->lpwanparam_->IsInitialized()) return false;
  }
  return true;
}

void MsgNode::Swap(MsgNode* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MsgNode::InternalSwap(MsgNode* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(_has_bits_[1], other->_has_bits_[1]);
  CastToBase(&sensors_)->InternalSwap(CastToBase(&other->sensors_));
  CastToBase(&mtundata_)->InternalSwap(CastToBase(&other->mtundata_));
  swap(lpwanparam_, other->lpwanparam_);
  swap(bleparam_, other->bleparam_);
  swap(appparam_, other->appparam_);
  swap(gps_, other->gps_);
  swap(acceleration_, other->acceleration_);
  swap(magnetism_, other->magnetism_);
  swap(gyroscope_, other->gyroscope_);
  swap(temperature_, other->temperature_);
  swap(humidity_, other->humidity_);
  swap(light_, other->light_);
  swap(leak_, other->leak_);
  swap(co_, other->co_);
  swap(co2_, other->co2_);
  swap(so2_, other->so2_);
  swap(no2_, other->no2_);
  swap(ch4_, other->ch4_);
  swap(ch2o_, other->ch2o_);
  swap(lpg_, other->lpg_);
  swap(o3_, other->o3_);
  swap(pm1_, other->pm1_);
  swap(pm2_5_, other->pm2_5_);
  swap(pm10_, other->pm10_);
  swap(angle_, other->angle_);
  swap(cover_, other->cover_);
  swap(level_, other->level_);
  swap(smoke_, other->smoke_);
  swap(pitch_, other->pitch_);
  swap(roll_, other->roll_);
  swap(yaw_, other->yaw_);
  swap(flame_, other->flame_);
  swap(artificialgas_, other->artificialgas_);
  swap(multitemp_, other->multitemp_);
  swap(waterpressure_, other->waterpressure_);
  swap(ibeacon_, other->ibeacon_);
  swap(extsmoke_, other->extsmoke_);
  swap(firedata_, other->firedata_);
  swap(acreldata_, other->acreldata_);
  swap(caymandata_, other->caymandata_);
  swap(baymaxdata_, other->baymaxdata_);
  swap(id_, other->id_);
  swap(cmd_, other->cmd_);
  swap(cmdret_, other->cmdret_);
  swap(battery_, other->battery_);
  swap(installed_, other->installed_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MsgNode::GetMetadata() const {
  return GetMetadataStatic();
}


// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::Channel* Arena::CreateMaybeMessage< ::Channel >(Arena* arena) {
  return Arena::CreateInternal< ::Channel >(arena);
}
template<> PROTOBUF_NOINLINE ::LpwanParam* Arena::CreateMaybeMessage< ::LpwanParam >(Arena* arena) {
  return Arena::CreateInternal< ::LpwanParam >(arena);
}
template<> PROTOBUF_NOINLINE ::BleParam* Arena::CreateMaybeMessage< ::BleParam >(Arena* arena) {
  return Arena::CreateInternal< ::BleParam >(arena);
}
template<> PROTOBUF_NOINLINE ::SensorData* Arena::CreateMaybeMessage< ::SensorData >(Arena* arena) {
  return Arena::CreateInternal< ::SensorData >(arena);
}
template<> PROTOBUF_NOINLINE ::SensorDataInt* Arena::CreateMaybeMessage< ::SensorDataInt >(Arena* arena) {
  return Arena::CreateInternal< ::SensorDataInt >(arena);
}
template<> PROTOBUF_NOINLINE ::SensorDataFloat* Arena::CreateMaybeMessage< ::SensorDataFloat >(Arena* arena) {
  return Arena::CreateInternal< ::SensorDataFloat >(arena);
}
template<> PROTOBUF_NOINLINE ::MultiSensorData* Arena::CreateMaybeMessage< ::MultiSensorData >(Arena* arena) {
  return Arena::CreateInternal< ::MultiSensorData >(arena);
}
template<> PROTOBUF_NOINLINE ::MultiSensorDataInt* Arena::CreateMaybeMessage< ::MultiSensorDataInt >(Arena* arena) {
  return Arena::CreateInternal< ::MultiSensorDataInt >(arena);
}
template<> PROTOBUF_NOINLINE ::GpsData* Arena::CreateMaybeMessage< ::GpsData >(Arena* arena) {
  return Arena::CreateInternal< ::GpsData >(arena);
}
template<> PROTOBUF_NOINLINE ::AxisData* Arena::CreateMaybeMessage< ::AxisData >(Arena* arena) {
  return Arena::CreateInternal< ::AxisData >(arena);
}
template<> PROTOBUF_NOINLINE ::iBeacon* Arena::CreateMaybeMessage< ::iBeacon >(Arena* arena) {
  return Arena::CreateInternal< ::iBeacon >(arena);
}
template<> PROTOBUF_NOINLINE ::ExtSmoke* Arena::CreateMaybeMessage< ::ExtSmoke >(Arena* arena) {
  return Arena::CreateInternal< ::ExtSmoke >(arena);
}
template<> PROTOBUF_NOINLINE ::AppParam* Arena::CreateMaybeMessage< ::AppParam >(Arena* arena) {
  return Arena::CreateInternal< ::AppParam >(arena);
}
template<> PROTOBUF_NOINLINE ::ElecFireData* Arena::CreateMaybeMessage< ::ElecFireData >(Arena* arena) {
  return Arena::CreateInternal< ::ElecFireData >(arena);
}
template<> PROTOBUF_NOINLINE ::MantunData* Arena::CreateMaybeMessage< ::MantunData >(Arena* arena) {
  return Arena::CreateInternal< ::MantunData >(arena);
}
template<> PROTOBUF_NOINLINE ::Cayman* Arena::CreateMaybeMessage< ::Cayman >(Arena* arena) {
  return Arena::CreateInternal< ::Cayman >(arena);
}
template<> PROTOBUF_NOINLINE ::AcrelData* Arena::CreateMaybeMessage< ::AcrelData >(Arena* arena) {
  return Arena::CreateInternal< ::AcrelData >(arena);
}
template<> PROTOBUF_NOINLINE ::Baymax* Arena::CreateMaybeMessage< ::Baymax >(Arena* arena) {
  return Arena::CreateInternal< ::Baymax >(arena);
}
template<> PROTOBUF_NOINLINE ::MsgNode* Arena::CreateMaybeMessage< ::MsgNode >(Arena* arena) {
  return Arena::CreateInternal< ::MsgNode >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
