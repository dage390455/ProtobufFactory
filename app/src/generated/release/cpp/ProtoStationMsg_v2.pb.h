// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ProtoStationMsg_v2.proto

#ifndef PROTOBUF_ProtoStationMsg_5fv2_2eproto__INCLUDED
#define PROTOBUF_ProtoStationMsg_5fv2_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ProtoStationMsg_5fv2_2eproto();
void protobuf_AssignDesc_ProtoStationMsg_5fv2_2eproto();
void protobuf_ShutdownFile_ProtoStationMsg_5fv2_2eproto();

class StationMsg;

enum CmdRet {
  CMD_RET_NONE = 0,
  CMD_RET_SUC = 1,
  CMD_RET_INVALID_CMD = 2,
  CMD_RET_INVALID_ARG = 3,
  CMD_RET_INVALID_STATE = 4
};
bool CmdRet_IsValid(int value);
const CmdRet CmdRet_MIN = CMD_RET_NONE;
const CmdRet CmdRet_MAX = CMD_RET_INVALID_STATE;
const int CmdRet_ARRAYSIZE = CmdRet_MAX + 1;

const ::google::protobuf::EnumDescriptor* CmdRet_descriptor();
inline const ::std::string& CmdRet_Name(CmdRet value) {
  return ::google::protobuf::internal::NameOfEnum(
    CmdRet_descriptor(), value);
}
inline bool CmdRet_Parse(
    const ::std::string& name, CmdRet* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CmdRet>(
    CmdRet_descriptor(), name, value);
}
enum NwkAccessMode {
  NWK_MODE_ETH = 0,
  NWK_MODE_WIFI = 1,
  NWK_MODE_CELLULAR = 2
};
bool NwkAccessMode_IsValid(int value);
const NwkAccessMode NwkAccessMode_MIN = NWK_MODE_ETH;
const NwkAccessMode NwkAccessMode_MAX = NWK_MODE_CELLULAR;
const int NwkAccessMode_ARRAYSIZE = NwkAccessMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* NwkAccessMode_descriptor();
inline const ::std::string& NwkAccessMode_Name(NwkAccessMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    NwkAccessMode_descriptor(), value);
}
inline bool NwkAccessMode_Parse(
    const ::std::string& name, NwkAccessMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NwkAccessMode>(
    NwkAccessMode_descriptor(), name, value);
}
enum IPAllocationMode {
  IP_ALLOC_DHCP = 0,
  IP_ALLOC_STATIC = 1
};
bool IPAllocationMode_IsValid(int value);
const IPAllocationMode IPAllocationMode_MIN = IP_ALLOC_DHCP;
const IPAllocationMode IPAllocationMode_MAX = IP_ALLOC_STATIC;
const int IPAllocationMode_ARRAYSIZE = IPAllocationMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* IPAllocationMode_descriptor();
inline const ::std::string& IPAllocationMode_Name(IPAllocationMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    IPAllocationMode_descriptor(), value);
}
inline bool IPAllocationMode_Parse(
    const ::std::string& name, IPAllocationMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<IPAllocationMode>(
    IPAllocationMode_descriptor(), name, value);
}
// ===================================================================

class StationMsg : public ::google::protobuf::Message {
 public:
  StationMsg();
  virtual ~StationMsg();

  StationMsg(const StationMsg& from);

  inline StationMsg& operator=(const StationMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StationMsg& default_instance();

  void Swap(StationMsg* other);

  // implements Message ----------------------------------------------

  StationMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StationMsg& from);
  void MergeFrom(const StationMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .CmdRet ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::CmdRet ret() const;
  inline void set_ret(::CmdRet value);

  // optional string sn = 2;
  inline bool has_sn() const;
  inline void clear_sn();
  static const int kSnFieldNumber = 2;
  inline const ::std::string& sn() const;
  inline void set_sn(const ::std::string& value);
  inline void set_sn(const char* value);
  inline void set_sn(const char* value, size_t size);
  inline ::std::string* mutable_sn();
  inline ::std::string* release_sn();
  inline void set_allocated_sn(::std::string* sn);

  // optional string netid = 3;
  inline bool has_netid() const;
  inline void clear_netid();
  static const int kNetidFieldNumber = 3;
  inline const ::std::string& netid() const;
  inline void set_netid(const ::std::string& value);
  inline void set_netid(const char* value);
  inline void set_netid(const char* value, size_t size);
  inline ::std::string* mutable_netid();
  inline ::std::string* release_netid();
  inline void set_allocated_netid(::std::string* netid);

  // optional string mcdomain = 4;
  inline bool has_mcdomain() const;
  inline void clear_mcdomain();
  static const int kMcdomainFieldNumber = 4;
  inline const ::std::string& mcdomain() const;
  inline void set_mcdomain(const ::std::string& value);
  inline void set_mcdomain(const char* value);
  inline void set_mcdomain(const char* value, size_t size);
  inline ::std::string* mutable_mcdomain();
  inline ::std::string* release_mcdomain();
  inline void set_allocated_mcdomain(::std::string* mcdomain);

  // optional string mcport = 5;
  inline bool has_mcport() const;
  inline void clear_mcport();
  static const int kMcportFieldNumber = 5;
  inline const ::std::string& mcport() const;
  inline void set_mcport(const ::std::string& value);
  inline void set_mcport(const char* value);
  inline void set_mcport(const char* value, size_t size);
  inline ::std::string* mutable_mcport();
  inline ::std::string* release_mcport();
  inline void set_allocated_mcport(::std::string* mcport);

  // optional string key = 6;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 6;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional .NwkAccessMode nwk_access_mode = 7;
  inline bool has_nwk_access_mode() const;
  inline void clear_nwk_access_mode();
  static const int kNwkAccessModeFieldNumber = 7;
  inline ::NwkAccessMode nwk_access_mode() const;
  inline void set_nwk_access_mode(::NwkAccessMode value);

  // optional .IPAllocationMode ip_alloc = 8;
  inline bool has_ip_alloc() const;
  inline void clear_ip_alloc();
  static const int kIpAllocFieldNumber = 8;
  inline ::IPAllocationMode ip_alloc() const;
  inline void set_ip_alloc(::IPAllocationMode value);

  // optional string ip = 9;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 9;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional string gateway = 10;
  inline bool has_gateway() const;
  inline void clear_gateway();
  static const int kGatewayFieldNumber = 10;
  inline const ::std::string& gateway() const;
  inline void set_gateway(const ::std::string& value);
  inline void set_gateway(const char* value);
  inline void set_gateway(const char* value, size_t size);
  inline ::std::string* mutable_gateway();
  inline ::std::string* release_gateway();
  inline void set_allocated_gateway(::std::string* gateway);

  // optional string mask = 11;
  inline bool has_mask() const;
  inline void clear_mask();
  static const int kMaskFieldNumber = 11;
  inline const ::std::string& mask() const;
  inline void set_mask(const ::std::string& value);
  inline void set_mask(const char* value);
  inline void set_mask(const char* value, size_t size);
  inline ::std::string* mutable_mask();
  inline ::std::string* release_mask();
  inline void set_allocated_mask(::std::string* mask);

  // optional string pdns = 12;
  inline bool has_pdns() const;
  inline void clear_pdns();
  static const int kPdnsFieldNumber = 12;
  inline const ::std::string& pdns() const;
  inline void set_pdns(const ::std::string& value);
  inline void set_pdns(const char* value);
  inline void set_pdns(const char* value, size_t size);
  inline ::std::string* mutable_pdns();
  inline ::std::string* release_pdns();
  inline void set_allocated_pdns(::std::string* pdns);

  // optional string adns = 13;
  inline bool has_adns() const;
  inline void clear_adns();
  static const int kAdnsFieldNumber = 13;
  inline const ::std::string& adns() const;
  inline void set_adns(const ::std::string& value);
  inline void set_adns(const char* value);
  inline void set_adns(const char* value, size_t size);
  inline ::std::string* mutable_adns();
  inline ::std::string* release_adns();
  inline void set_allocated_adns(::std::string* adns);

  // optional string ssid = 14;
  inline bool has_ssid() const;
  inline void clear_ssid();
  static const int kSsidFieldNumber = 14;
  inline const ::std::string& ssid() const;
  inline void set_ssid(const ::std::string& value);
  inline void set_ssid(const char* value);
  inline void set_ssid(const char* value, size_t size);
  inline ::std::string* mutable_ssid();
  inline ::std::string* release_ssid();
  inline void set_allocated_ssid(::std::string* ssid);

  // optional string pwd = 15;
  inline bool has_pwd() const;
  inline void clear_pwd();
  static const int kPwdFieldNumber = 15;
  inline const ::std::string& pwd() const;
  inline void set_pwd(const ::std::string& value);
  inline void set_pwd(const char* value);
  inline void set_pwd(const char* value, size_t size);
  inline ::std::string* mutable_pwd();
  inline ::std::string* release_pwd();
  inline void set_allocated_pwd(::std::string* pwd);

  // optional string encrypt = 16;
  inline bool has_encrypt() const;
  inline void clear_encrypt();
  static const int kEncryptFieldNumber = 16;
  inline const ::std::string& encrypt() const;
  inline void set_encrypt(const ::std::string& value);
  inline void set_encrypt(const char* value);
  inline void set_encrypt(const char* value, size_t size);
  inline ::std::string* mutable_encrypt();
  inline ::std::string* release_encrypt();
  inline void set_allocated_encrypt(::std::string* encrypt);

  // optional uint32 self_test_code = 17;
  inline bool has_self_test_code() const;
  inline void clear_self_test_code();
  static const int kSelfTestCodeFieldNumber = 17;
  inline ::google::protobuf::uint32 self_test_code() const;
  inline void set_self_test_code(::google::protobuf::uint32 value);

  // optional uint32 sgl_freq = 18;
  inline bool has_sgl_freq() const;
  inline void clear_sgl_freq();
  static const int kSglFreqFieldNumber = 18;
  inline ::google::protobuf::uint32 sgl_freq() const;
  inline void set_sgl_freq(::google::protobuf::uint32 value);

  // optional uint32 sgl_dr = 19;
  inline bool has_sgl_dr() const;
  inline void clear_sgl_dr();
  static const int kSglDrFieldNumber = 19;
  inline ::google::protobuf::uint32 sgl_dr() const;
  inline void set_sgl_dr(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:StationMsg)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_sn();
  inline void clear_has_sn();
  inline void set_has_netid();
  inline void clear_has_netid();
  inline void set_has_mcdomain();
  inline void clear_has_mcdomain();
  inline void set_has_mcport();
  inline void clear_has_mcport();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_nwk_access_mode();
  inline void clear_has_nwk_access_mode();
  inline void set_has_ip_alloc();
  inline void clear_has_ip_alloc();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_gateway();
  inline void clear_has_gateway();
  inline void set_has_mask();
  inline void clear_has_mask();
  inline void set_has_pdns();
  inline void clear_has_pdns();
  inline void set_has_adns();
  inline void clear_has_adns();
  inline void set_has_ssid();
  inline void clear_has_ssid();
  inline void set_has_pwd();
  inline void clear_has_pwd();
  inline void set_has_encrypt();
  inline void clear_has_encrypt();
  inline void set_has_self_test_code();
  inline void clear_has_self_test_code();
  inline void set_has_sgl_freq();
  inline void clear_has_sgl_freq();
  inline void set_has_sgl_dr();
  inline void clear_has_sgl_dr();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* sn_;
  ::std::string* netid_;
  ::std::string* mcdomain_;
  int ret_;
  int nwk_access_mode_;
  ::std::string* mcport_;
  ::std::string* key_;
  ::std::string* ip_;
  ::std::string* gateway_;
  ::std::string* mask_;
  ::std::string* pdns_;
  int ip_alloc_;
  ::google::protobuf::uint32 self_test_code_;
  ::std::string* adns_;
  ::std::string* ssid_;
  ::std::string* pwd_;
  ::std::string* encrypt_;
  ::google::protobuf::uint32 sgl_freq_;
  ::google::protobuf::uint32 sgl_dr_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(19 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoStationMsg_5fv2_2eproto();
  friend void protobuf_AssignDesc_ProtoStationMsg_5fv2_2eproto();
  friend void protobuf_ShutdownFile_ProtoStationMsg_5fv2_2eproto();

  void InitAsDefaultInstance();
  static StationMsg* default_instance_;
};
// ===================================================================


// ===================================================================

// StationMsg

// optional .CmdRet ret = 1;
inline bool StationMsg::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StationMsg::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StationMsg::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StationMsg::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::CmdRet StationMsg::ret() const {
  return static_cast< ::CmdRet >(ret_);
}
inline void StationMsg::set_ret(::CmdRet value) {
  assert(::CmdRet_IsValid(value));
  set_has_ret();
  ret_ = value;
}

// optional string sn = 2;
inline bool StationMsg::has_sn() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StationMsg::set_has_sn() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StationMsg::clear_has_sn() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StationMsg::clear_sn() {
  if (sn_ != &::google::protobuf::internal::kEmptyString) {
    sn_->clear();
  }
  clear_has_sn();
}
inline const ::std::string& StationMsg::sn() const {
  return *sn_;
}
inline void StationMsg::set_sn(const ::std::string& value) {
  set_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    sn_ = new ::std::string;
  }
  sn_->assign(value);
}
inline void StationMsg::set_sn(const char* value) {
  set_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    sn_ = new ::std::string;
  }
  sn_->assign(value);
}
inline void StationMsg::set_sn(const char* value, size_t size) {
  set_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    sn_ = new ::std::string;
  }
  sn_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StationMsg::mutable_sn() {
  set_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    sn_ = new ::std::string;
  }
  return sn_;
}
inline ::std::string* StationMsg::release_sn() {
  clear_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sn_;
    sn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StationMsg::set_allocated_sn(::std::string* sn) {
  if (sn_ != &::google::protobuf::internal::kEmptyString) {
    delete sn_;
  }
  if (sn) {
    set_has_sn();
    sn_ = sn;
  } else {
    clear_has_sn();
    sn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string netid = 3;
inline bool StationMsg::has_netid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StationMsg::set_has_netid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StationMsg::clear_has_netid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StationMsg::clear_netid() {
  if (netid_ != &::google::protobuf::internal::kEmptyString) {
    netid_->clear();
  }
  clear_has_netid();
}
inline const ::std::string& StationMsg::netid() const {
  return *netid_;
}
inline void StationMsg::set_netid(const ::std::string& value) {
  set_has_netid();
  if (netid_ == &::google::protobuf::internal::kEmptyString) {
    netid_ = new ::std::string;
  }
  netid_->assign(value);
}
inline void StationMsg::set_netid(const char* value) {
  set_has_netid();
  if (netid_ == &::google::protobuf::internal::kEmptyString) {
    netid_ = new ::std::string;
  }
  netid_->assign(value);
}
inline void StationMsg::set_netid(const char* value, size_t size) {
  set_has_netid();
  if (netid_ == &::google::protobuf::internal::kEmptyString) {
    netid_ = new ::std::string;
  }
  netid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StationMsg::mutable_netid() {
  set_has_netid();
  if (netid_ == &::google::protobuf::internal::kEmptyString) {
    netid_ = new ::std::string;
  }
  return netid_;
}
inline ::std::string* StationMsg::release_netid() {
  clear_has_netid();
  if (netid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = netid_;
    netid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StationMsg::set_allocated_netid(::std::string* netid) {
  if (netid_ != &::google::protobuf::internal::kEmptyString) {
    delete netid_;
  }
  if (netid) {
    set_has_netid();
    netid_ = netid;
  } else {
    clear_has_netid();
    netid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mcdomain = 4;
inline bool StationMsg::has_mcdomain() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StationMsg::set_has_mcdomain() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StationMsg::clear_has_mcdomain() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StationMsg::clear_mcdomain() {
  if (mcdomain_ != &::google::protobuf::internal::kEmptyString) {
    mcdomain_->clear();
  }
  clear_has_mcdomain();
}
inline const ::std::string& StationMsg::mcdomain() const {
  return *mcdomain_;
}
inline void StationMsg::set_mcdomain(const ::std::string& value) {
  set_has_mcdomain();
  if (mcdomain_ == &::google::protobuf::internal::kEmptyString) {
    mcdomain_ = new ::std::string;
  }
  mcdomain_->assign(value);
}
inline void StationMsg::set_mcdomain(const char* value) {
  set_has_mcdomain();
  if (mcdomain_ == &::google::protobuf::internal::kEmptyString) {
    mcdomain_ = new ::std::string;
  }
  mcdomain_->assign(value);
}
inline void StationMsg::set_mcdomain(const char* value, size_t size) {
  set_has_mcdomain();
  if (mcdomain_ == &::google::protobuf::internal::kEmptyString) {
    mcdomain_ = new ::std::string;
  }
  mcdomain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StationMsg::mutable_mcdomain() {
  set_has_mcdomain();
  if (mcdomain_ == &::google::protobuf::internal::kEmptyString) {
    mcdomain_ = new ::std::string;
  }
  return mcdomain_;
}
inline ::std::string* StationMsg::release_mcdomain() {
  clear_has_mcdomain();
  if (mcdomain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mcdomain_;
    mcdomain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StationMsg::set_allocated_mcdomain(::std::string* mcdomain) {
  if (mcdomain_ != &::google::protobuf::internal::kEmptyString) {
    delete mcdomain_;
  }
  if (mcdomain) {
    set_has_mcdomain();
    mcdomain_ = mcdomain;
  } else {
    clear_has_mcdomain();
    mcdomain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mcport = 5;
inline bool StationMsg::has_mcport() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StationMsg::set_has_mcport() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StationMsg::clear_has_mcport() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StationMsg::clear_mcport() {
  if (mcport_ != &::google::protobuf::internal::kEmptyString) {
    mcport_->clear();
  }
  clear_has_mcport();
}
inline const ::std::string& StationMsg::mcport() const {
  return *mcport_;
}
inline void StationMsg::set_mcport(const ::std::string& value) {
  set_has_mcport();
  if (mcport_ == &::google::protobuf::internal::kEmptyString) {
    mcport_ = new ::std::string;
  }
  mcport_->assign(value);
}
inline void StationMsg::set_mcport(const char* value) {
  set_has_mcport();
  if (mcport_ == &::google::protobuf::internal::kEmptyString) {
    mcport_ = new ::std::string;
  }
  mcport_->assign(value);
}
inline void StationMsg::set_mcport(const char* value, size_t size) {
  set_has_mcport();
  if (mcport_ == &::google::protobuf::internal::kEmptyString) {
    mcport_ = new ::std::string;
  }
  mcport_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StationMsg::mutable_mcport() {
  set_has_mcport();
  if (mcport_ == &::google::protobuf::internal::kEmptyString) {
    mcport_ = new ::std::string;
  }
  return mcport_;
}
inline ::std::string* StationMsg::release_mcport() {
  clear_has_mcport();
  if (mcport_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mcport_;
    mcport_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StationMsg::set_allocated_mcport(::std::string* mcport) {
  if (mcport_ != &::google::protobuf::internal::kEmptyString) {
    delete mcport_;
  }
  if (mcport) {
    set_has_mcport();
    mcport_ = mcport;
  } else {
    clear_has_mcport();
    mcport_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string key = 6;
inline bool StationMsg::has_key() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void StationMsg::set_has_key() {
  _has_bits_[0] |= 0x00000020u;
}
inline void StationMsg::clear_has_key() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void StationMsg::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& StationMsg::key() const {
  return *key_;
}
inline void StationMsg::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void StationMsg::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void StationMsg::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StationMsg::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* StationMsg::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StationMsg::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .NwkAccessMode nwk_access_mode = 7;
inline bool StationMsg::has_nwk_access_mode() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void StationMsg::set_has_nwk_access_mode() {
  _has_bits_[0] |= 0x00000040u;
}
inline void StationMsg::clear_has_nwk_access_mode() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void StationMsg::clear_nwk_access_mode() {
  nwk_access_mode_ = 0;
  clear_has_nwk_access_mode();
}
inline ::NwkAccessMode StationMsg::nwk_access_mode() const {
  return static_cast< ::NwkAccessMode >(nwk_access_mode_);
}
inline void StationMsg::set_nwk_access_mode(::NwkAccessMode value) {
  assert(::NwkAccessMode_IsValid(value));
  set_has_nwk_access_mode();
  nwk_access_mode_ = value;
}

// optional .IPAllocationMode ip_alloc = 8;
inline bool StationMsg::has_ip_alloc() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void StationMsg::set_has_ip_alloc() {
  _has_bits_[0] |= 0x00000080u;
}
inline void StationMsg::clear_has_ip_alloc() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void StationMsg::clear_ip_alloc() {
  ip_alloc_ = 0;
  clear_has_ip_alloc();
}
inline ::IPAllocationMode StationMsg::ip_alloc() const {
  return static_cast< ::IPAllocationMode >(ip_alloc_);
}
inline void StationMsg::set_ip_alloc(::IPAllocationMode value) {
  assert(::IPAllocationMode_IsValid(value));
  set_has_ip_alloc();
  ip_alloc_ = value;
}

// optional string ip = 9;
inline bool StationMsg::has_ip() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void StationMsg::set_has_ip() {
  _has_bits_[0] |= 0x00000100u;
}
inline void StationMsg::clear_has_ip() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void StationMsg::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& StationMsg::ip() const {
  return *ip_;
}
inline void StationMsg::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void StationMsg::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void StationMsg::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StationMsg::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* StationMsg::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StationMsg::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string gateway = 10;
inline bool StationMsg::has_gateway() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void StationMsg::set_has_gateway() {
  _has_bits_[0] |= 0x00000200u;
}
inline void StationMsg::clear_has_gateway() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void StationMsg::clear_gateway() {
  if (gateway_ != &::google::protobuf::internal::kEmptyString) {
    gateway_->clear();
  }
  clear_has_gateway();
}
inline const ::std::string& StationMsg::gateway() const {
  return *gateway_;
}
inline void StationMsg::set_gateway(const ::std::string& value) {
  set_has_gateway();
  if (gateway_ == &::google::protobuf::internal::kEmptyString) {
    gateway_ = new ::std::string;
  }
  gateway_->assign(value);
}
inline void StationMsg::set_gateway(const char* value) {
  set_has_gateway();
  if (gateway_ == &::google::protobuf::internal::kEmptyString) {
    gateway_ = new ::std::string;
  }
  gateway_->assign(value);
}
inline void StationMsg::set_gateway(const char* value, size_t size) {
  set_has_gateway();
  if (gateway_ == &::google::protobuf::internal::kEmptyString) {
    gateway_ = new ::std::string;
  }
  gateway_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StationMsg::mutable_gateway() {
  set_has_gateway();
  if (gateway_ == &::google::protobuf::internal::kEmptyString) {
    gateway_ = new ::std::string;
  }
  return gateway_;
}
inline ::std::string* StationMsg::release_gateway() {
  clear_has_gateway();
  if (gateway_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gateway_;
    gateway_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StationMsg::set_allocated_gateway(::std::string* gateway) {
  if (gateway_ != &::google::protobuf::internal::kEmptyString) {
    delete gateway_;
  }
  if (gateway) {
    set_has_gateway();
    gateway_ = gateway;
  } else {
    clear_has_gateway();
    gateway_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mask = 11;
inline bool StationMsg::has_mask() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void StationMsg::set_has_mask() {
  _has_bits_[0] |= 0x00000400u;
}
inline void StationMsg::clear_has_mask() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void StationMsg::clear_mask() {
  if (mask_ != &::google::protobuf::internal::kEmptyString) {
    mask_->clear();
  }
  clear_has_mask();
}
inline const ::std::string& StationMsg::mask() const {
  return *mask_;
}
inline void StationMsg::set_mask(const ::std::string& value) {
  set_has_mask();
  if (mask_ == &::google::protobuf::internal::kEmptyString) {
    mask_ = new ::std::string;
  }
  mask_->assign(value);
}
inline void StationMsg::set_mask(const char* value) {
  set_has_mask();
  if (mask_ == &::google::protobuf::internal::kEmptyString) {
    mask_ = new ::std::string;
  }
  mask_->assign(value);
}
inline void StationMsg::set_mask(const char* value, size_t size) {
  set_has_mask();
  if (mask_ == &::google::protobuf::internal::kEmptyString) {
    mask_ = new ::std::string;
  }
  mask_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StationMsg::mutable_mask() {
  set_has_mask();
  if (mask_ == &::google::protobuf::internal::kEmptyString) {
    mask_ = new ::std::string;
  }
  return mask_;
}
inline ::std::string* StationMsg::release_mask() {
  clear_has_mask();
  if (mask_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mask_;
    mask_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StationMsg::set_allocated_mask(::std::string* mask) {
  if (mask_ != &::google::protobuf::internal::kEmptyString) {
    delete mask_;
  }
  if (mask) {
    set_has_mask();
    mask_ = mask;
  } else {
    clear_has_mask();
    mask_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string pdns = 12;
inline bool StationMsg::has_pdns() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void StationMsg::set_has_pdns() {
  _has_bits_[0] |= 0x00000800u;
}
inline void StationMsg::clear_has_pdns() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void StationMsg::clear_pdns() {
  if (pdns_ != &::google::protobuf::internal::kEmptyString) {
    pdns_->clear();
  }
  clear_has_pdns();
}
inline const ::std::string& StationMsg::pdns() const {
  return *pdns_;
}
inline void StationMsg::set_pdns(const ::std::string& value) {
  set_has_pdns();
  if (pdns_ == &::google::protobuf::internal::kEmptyString) {
    pdns_ = new ::std::string;
  }
  pdns_->assign(value);
}
inline void StationMsg::set_pdns(const char* value) {
  set_has_pdns();
  if (pdns_ == &::google::protobuf::internal::kEmptyString) {
    pdns_ = new ::std::string;
  }
  pdns_->assign(value);
}
inline void StationMsg::set_pdns(const char* value, size_t size) {
  set_has_pdns();
  if (pdns_ == &::google::protobuf::internal::kEmptyString) {
    pdns_ = new ::std::string;
  }
  pdns_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StationMsg::mutable_pdns() {
  set_has_pdns();
  if (pdns_ == &::google::protobuf::internal::kEmptyString) {
    pdns_ = new ::std::string;
  }
  return pdns_;
}
inline ::std::string* StationMsg::release_pdns() {
  clear_has_pdns();
  if (pdns_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pdns_;
    pdns_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StationMsg::set_allocated_pdns(::std::string* pdns) {
  if (pdns_ != &::google::protobuf::internal::kEmptyString) {
    delete pdns_;
  }
  if (pdns) {
    set_has_pdns();
    pdns_ = pdns;
  } else {
    clear_has_pdns();
    pdns_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string adns = 13;
inline bool StationMsg::has_adns() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void StationMsg::set_has_adns() {
  _has_bits_[0] |= 0x00001000u;
}
inline void StationMsg::clear_has_adns() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void StationMsg::clear_adns() {
  if (adns_ != &::google::protobuf::internal::kEmptyString) {
    adns_->clear();
  }
  clear_has_adns();
}
inline const ::std::string& StationMsg::adns() const {
  return *adns_;
}
inline void StationMsg::set_adns(const ::std::string& value) {
  set_has_adns();
  if (adns_ == &::google::protobuf::internal::kEmptyString) {
    adns_ = new ::std::string;
  }
  adns_->assign(value);
}
inline void StationMsg::set_adns(const char* value) {
  set_has_adns();
  if (adns_ == &::google::protobuf::internal::kEmptyString) {
    adns_ = new ::std::string;
  }
  adns_->assign(value);
}
inline void StationMsg::set_adns(const char* value, size_t size) {
  set_has_adns();
  if (adns_ == &::google::protobuf::internal::kEmptyString) {
    adns_ = new ::std::string;
  }
  adns_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StationMsg::mutable_adns() {
  set_has_adns();
  if (adns_ == &::google::protobuf::internal::kEmptyString) {
    adns_ = new ::std::string;
  }
  return adns_;
}
inline ::std::string* StationMsg::release_adns() {
  clear_has_adns();
  if (adns_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = adns_;
    adns_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StationMsg::set_allocated_adns(::std::string* adns) {
  if (adns_ != &::google::protobuf::internal::kEmptyString) {
    delete adns_;
  }
  if (adns) {
    set_has_adns();
    adns_ = adns;
  } else {
    clear_has_adns();
    adns_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ssid = 14;
inline bool StationMsg::has_ssid() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void StationMsg::set_has_ssid() {
  _has_bits_[0] |= 0x00002000u;
}
inline void StationMsg::clear_has_ssid() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void StationMsg::clear_ssid() {
  if (ssid_ != &::google::protobuf::internal::kEmptyString) {
    ssid_->clear();
  }
  clear_has_ssid();
}
inline const ::std::string& StationMsg::ssid() const {
  return *ssid_;
}
inline void StationMsg::set_ssid(const ::std::string& value) {
  set_has_ssid();
  if (ssid_ == &::google::protobuf::internal::kEmptyString) {
    ssid_ = new ::std::string;
  }
  ssid_->assign(value);
}
inline void StationMsg::set_ssid(const char* value) {
  set_has_ssid();
  if (ssid_ == &::google::protobuf::internal::kEmptyString) {
    ssid_ = new ::std::string;
  }
  ssid_->assign(value);
}
inline void StationMsg::set_ssid(const char* value, size_t size) {
  set_has_ssid();
  if (ssid_ == &::google::protobuf::internal::kEmptyString) {
    ssid_ = new ::std::string;
  }
  ssid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StationMsg::mutable_ssid() {
  set_has_ssid();
  if (ssid_ == &::google::protobuf::internal::kEmptyString) {
    ssid_ = new ::std::string;
  }
  return ssid_;
}
inline ::std::string* StationMsg::release_ssid() {
  clear_has_ssid();
  if (ssid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ssid_;
    ssid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StationMsg::set_allocated_ssid(::std::string* ssid) {
  if (ssid_ != &::google::protobuf::internal::kEmptyString) {
    delete ssid_;
  }
  if (ssid) {
    set_has_ssid();
    ssid_ = ssid;
  } else {
    clear_has_ssid();
    ssid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string pwd = 15;
inline bool StationMsg::has_pwd() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void StationMsg::set_has_pwd() {
  _has_bits_[0] |= 0x00004000u;
}
inline void StationMsg::clear_has_pwd() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void StationMsg::clear_pwd() {
  if (pwd_ != &::google::protobuf::internal::kEmptyString) {
    pwd_->clear();
  }
  clear_has_pwd();
}
inline const ::std::string& StationMsg::pwd() const {
  return *pwd_;
}
inline void StationMsg::set_pwd(const ::std::string& value) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(value);
}
inline void StationMsg::set_pwd(const char* value) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(value);
}
inline void StationMsg::set_pwd(const char* value, size_t size) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StationMsg::mutable_pwd() {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  return pwd_;
}
inline ::std::string* StationMsg::release_pwd() {
  clear_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pwd_;
    pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StationMsg::set_allocated_pwd(::std::string* pwd) {
  if (pwd_ != &::google::protobuf::internal::kEmptyString) {
    delete pwd_;
  }
  if (pwd) {
    set_has_pwd();
    pwd_ = pwd;
  } else {
    clear_has_pwd();
    pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string encrypt = 16;
inline bool StationMsg::has_encrypt() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void StationMsg::set_has_encrypt() {
  _has_bits_[0] |= 0x00008000u;
}
inline void StationMsg::clear_has_encrypt() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void StationMsg::clear_encrypt() {
  if (encrypt_ != &::google::protobuf::internal::kEmptyString) {
    encrypt_->clear();
  }
  clear_has_encrypt();
}
inline const ::std::string& StationMsg::encrypt() const {
  return *encrypt_;
}
inline void StationMsg::set_encrypt(const ::std::string& value) {
  set_has_encrypt();
  if (encrypt_ == &::google::protobuf::internal::kEmptyString) {
    encrypt_ = new ::std::string;
  }
  encrypt_->assign(value);
}
inline void StationMsg::set_encrypt(const char* value) {
  set_has_encrypt();
  if (encrypt_ == &::google::protobuf::internal::kEmptyString) {
    encrypt_ = new ::std::string;
  }
  encrypt_->assign(value);
}
inline void StationMsg::set_encrypt(const char* value, size_t size) {
  set_has_encrypt();
  if (encrypt_ == &::google::protobuf::internal::kEmptyString) {
    encrypt_ = new ::std::string;
  }
  encrypt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StationMsg::mutable_encrypt() {
  set_has_encrypt();
  if (encrypt_ == &::google::protobuf::internal::kEmptyString) {
    encrypt_ = new ::std::string;
  }
  return encrypt_;
}
inline ::std::string* StationMsg::release_encrypt() {
  clear_has_encrypt();
  if (encrypt_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encrypt_;
    encrypt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StationMsg::set_allocated_encrypt(::std::string* encrypt) {
  if (encrypt_ != &::google::protobuf::internal::kEmptyString) {
    delete encrypt_;
  }
  if (encrypt) {
    set_has_encrypt();
    encrypt_ = encrypt;
  } else {
    clear_has_encrypt();
    encrypt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 self_test_code = 17;
inline bool StationMsg::has_self_test_code() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void StationMsg::set_has_self_test_code() {
  _has_bits_[0] |= 0x00010000u;
}
inline void StationMsg::clear_has_self_test_code() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void StationMsg::clear_self_test_code() {
  self_test_code_ = 0u;
  clear_has_self_test_code();
}
inline ::google::protobuf::uint32 StationMsg::self_test_code() const {
  return self_test_code_;
}
inline void StationMsg::set_self_test_code(::google::protobuf::uint32 value) {
  set_has_self_test_code();
  self_test_code_ = value;
}

// optional uint32 sgl_freq = 18;
inline bool StationMsg::has_sgl_freq() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void StationMsg::set_has_sgl_freq() {
  _has_bits_[0] |= 0x00020000u;
}
inline void StationMsg::clear_has_sgl_freq() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void StationMsg::clear_sgl_freq() {
  sgl_freq_ = 0u;
  clear_has_sgl_freq();
}
inline ::google::protobuf::uint32 StationMsg::sgl_freq() const {
  return sgl_freq_;
}
inline void StationMsg::set_sgl_freq(::google::protobuf::uint32 value) {
  set_has_sgl_freq();
  sgl_freq_ = value;
}

// optional uint32 sgl_dr = 19;
inline bool StationMsg::has_sgl_dr() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void StationMsg::set_has_sgl_dr() {
  _has_bits_[0] |= 0x00040000u;
}
inline void StationMsg::clear_has_sgl_dr() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void StationMsg::clear_sgl_dr() {
  sgl_dr_ = 0u;
  clear_has_sgl_dr();
}
inline ::google::protobuf::uint32 StationMsg::sgl_dr() const {
  return sgl_dr_;
}
inline void StationMsg::set_sgl_dr(::google::protobuf::uint32 value) {
  set_has_sgl_dr();
  sgl_dr_ = value;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CmdRet>() {
  return ::CmdRet_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NwkAccessMode>() {
  return ::NwkAccessMode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IPAllocationMode>() {
  return ::IPAllocationMode_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ProtoStationMsg_5fv2_2eproto__INCLUDED
